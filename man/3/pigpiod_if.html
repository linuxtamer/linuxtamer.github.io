<!DOCTYPE html>
<html lang=en-US>
<head>
<meta charset=utf-8>
<title>Linux command pigpiod_if</title><meta name="description" content="Linux command pigpiod_if A C library to interface to the pigpio daemon."><meta name="keywords" content="linux, command, pigpiod_if, bsd, A C library to interface to the pigpio daemon."><meta name="robots" content="index,follow">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="container">

<h1>NAME</h1>
<p>pigpiod_if - A C library to interface to the pigpio daemon.</p>
<h1>SYNOPSIS</h1>
<p>#include &lt;pigpiod_if.h&gt;</p>
<p>gcc -Wall -pthread -o prog prog.c -lpigpiod_if -lrt</p>
<p>./prog</p>
<h1>DESCRIPTION</h1>
<p><br />
</p>
<p><br />
THIS LIBRARY IS DEPRECATED. NEW CODE SHOULD BE WRITTEN TO USE THE MORE VERSATILE pigpiod_if2 LIBRARY.</p>
<p><br />
</p>
<p><br />
pigpiod_if is a C library for the Raspberry which allows control of the GPIO via the socket interface to the pigpio daemon.<br />
</p>
<p><br />
</p>
<p><br />
</p>
<h2>Features</h2>
<p><br />
</p>
<p><br />
o hardware timed PWM on any of GPIO 0-31</p>
<p><br />
</p>
<p><br />
o hardware timed servo pulses on any of GPIO 0-31</p>
<p><br />
</p>
<p><br />
o callbacks when any of GPIO 0-31 change state</p>
<p><br />
</p>
<p><br />
o callbacks at timed intervals</p>
<p><br />
</p>
<p><br />
o reading/writing all of the GPIO in a bank as one operation</p>
<p><br />
</p>
<p><br />
o individually setting GPIO modes, reading and writing</p>
<p><br />
</p>
<p><br />
o notifications when any of GPIO 0-31 change state</p>
<p><br />
</p>
<p><br />
o the construction of output waveforms with microsecond timing</p>
<p><br />
</p>
<p><br />
o rudimentary permission control over GPIO</p>
<p><br />
</p>
<p><br />
o a simple interface to start and stop new threads</p>
<p><br />
</p>
<p><br />
o I2C, SPI, and serial link wrappers</p>
<p><br />
</p>
<p><br />
o creating and running scripts on the pigpio daemon</p>
<p><br />
</p>
<p><br />
</p>
<h2>GPIO</h2>
<p><br />
</p>
<p><br />
ALL GPIO are identified by their Broadcom number.</p>
<p><br />
</p>
<p><br />
</p>
<h2>Notes</h2>
<p><br />
</p>
<p><br />
The PWM and servo pulses are timed using the DMA and PWM/PCM peripherals.</p>
<p><br />
</p>
<p><br />
</p>
<h2>Usage</h2>
<p><br />
</p>
<p><br />
Include &lt;pigpiod_if.h&gt; in your source files.</p>
<p><br />
</p>
<p><br />
Assuming your source is in prog.c use the following command to build</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>gcc -Wall -pthread -o prog prog.c -lpigpiod_if -lrt


</code></pre>
<p><br />
</p>
<p><br />
to run make sure the pigpio daemon is running</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>sudo pigpiod





 ./prog # sudo is not required to run programs linked to pigpiod_if


</code></pre>
<p><br />
</p>
<p><br />
For examples see x_pigpiod_if.c within the pigpio archive file.</p>
<p><br />
</p>
<p><br />
</p>
<h2>Notes</h2>
<p><br />
</p>
<p><br />
All the functions which return an int return &lt; 0 on error</p>
<p><br />
</p>
<p><br />
</p>
<h1>OVERVIEW</h1>
<p><br />
</p>
<h2>ESSENTIAL</h2>
<p><br />
</p>
<p><br />
pigpio_start Connects to the pigpio daemon<br />
pigpio_stop Disconnects from the pigpio daemon<br />
</p>
<h2>BEGINNER</h2>
<p><br />
</p>
<p><br />
set_mode Set a GPIO mode<br />
get_mode Get a GPIO mode<br />
</p>
<p><br />
set_pull_up_down Set/clear GPIO pull up/down resistor<br />
</p>
<p><br />
gpio_read Read a GPIO<br />
gpio_write Write a GPIO<br />
</p>
<p><br />
set_PWM_dutycycle Start/stop PWM pulses on a GPIO<br />
get_PWM_dutycycle Get the PWM dutycycle in use on a GPIO<br />
</p>
<p><br />
set_servo_pulsewidth Start/stop servo pulses on a GPIO<br />
get_servo_pulsewidth Get the servo pulsewidth in use on a GPIO<br />
</p>
<p><br />
callback Create GPIO level change callback<br />
callback_ex Create GPIO level change callback<br />
callback_cancel Cancel a callback<br />
wait_for_edge Wait for GPIO level change<br />
</p>
<h2>INTERMEDIATE</h2>
<p><br />
</p>
<p><br />
gpio_trigger Send a trigger pulse to a GPIO.<br />
</p>
<p><br />
set_watchdog Set a watchdog on a GPIO.<br />
</p>
<p><br />
set_PWM_range Configure PWM range for a GPIO<br />
get_PWM_range Get configured PWM range for a GPIO<br />
</p>
<p><br />
set_PWM_frequency Configure PWM frequency for a GPIO<br />
get_PWM_frequency Get configured PWM frequency for a GPIO<br />
</p>
<p><br />
read_bank_1 Read all GPIO in bank 1<br />
read_bank_2 Read all GPIO in bank 2<br />
</p>
<p><br />
clear_bank_1 Clear selected GPIO in bank 1<br />
clear_bank_2 Clear selected GPIO in bank 2<br />
</p>
<p><br />
set_bank_1 Set selected GPIO in bank 1<br />
set_bank_2 Set selected GPIO in bank 2<br />
</p>
<p><br />
start_thread Start a new thread<br />
stop_thread Stop a previously started thread<br />
</p>
<h2>ADVANCED</h2>
<p><br />
</p>
<p><br />
get_PWM_real_range Get underlying PWM range for a GPIO<br />
</p>
<p><br />
notify_open Request a notification handle<br />
notify_begin Start notifications for selected GPIO<br />
notify_pause Pause notifications<br />
notify_close Close a notification<br />
</p>
<p><br />
bb_serial_read_open Opens a GPIO for bit bang serial reads<br />
bb_serial_read Reads bit bang serial data from a GPIO<br />
bb_serial_read_close Closes a GPIO for bit bang serial reads<br />
bb_serial_invert Invert serial logic (1 invert, 0 normal)<br />
</p>
<p><br />
hardware_clock Start hardware clock on supported GPIO<br />
hardware_PWM Start hardware PWM on supported GPIO<br />
</p>
<p><br />
set_glitch_filter Set a glitch filter on a GPIO<br />
set_noise_filter Set a noise filter on a GPIO<br />
</p>
<h2>SCRIPTS</h2>
<p><br />
</p>
<p><br />
store_script Store a script<br />
run_script Run a stored script<br />
script_status Get script status and parameters<br />
stop_script Stop a running script<br />
delete_script Delete a stored script<br />
</p>
<h2>WAVES</h2>
<p><br />
</p>
<p><br />
wave_clear Deletes all waveforms<br />
</p>
<p><br />
wave_add_new Starts a new waveform<br />
wave_add_generic Adds a series of pulses to the waveform<br />
wave_add_serial Adds serial data to the waveform<br />
</p>
<p><br />
wave_create Creates a waveform from added data<br />
wave_delete Deletes one or more waveforms<br />
</p>
<p><br />
wave_send_once Transmits a waveform once<br />
wave_send_repeat Transmits a waveform repeatedly<br />
</p>
<p><br />
wave_chain Transmits a chain of waveforms<br />
</p>
<p><br />
wave_tx_busy Checks to see if the waveform has ended<br />
wave_tx_stop Aborts the current waveform<br />
</p>
<p><br />
wave_get_micros Length in microseconds of the current waveform<br />
wave_get_high_micros Length of longest waveform so far<br />
wave_get_max_micros Absolute maximum allowed micros<br />
</p>
<p><br />
wave_get_pulses Length in pulses of the current waveform<br />
wave_get_high_pulses Length of longest waveform so far<br />
wave_get_max_pulses Absolute maximum allowed pulses<br />
</p>
<p><br />
wave_get_cbs Length in cbs of the current waveform<br />
wave_get_high_cbs Length of longest waveform so far<br />
wave_get_max_cbs Absolute maximum allowed cbs<br />
</p>
<h2>I2C</h2>
<p><br />
</p>
<p><br />
i2c_open Opens an I2C device<br />
i2c_close Closes an I2C device<br />
</p>
<p><br />
i2c_write_quick smbus write quick<br />
i2c_write_byte smbus write byte<br />
i2c_read_byte smbus read byte<br />
i2c_write_byte_data smbus write byte data<br />
i2c_write_word_data smbus write word data<br />
i2c_read_byte_data smbus read byte data<br />
i2c_read_word_data smbus read word data<br />
i2c_process_call smbus process call<br />
i2c_write_block_data smbus write block data<br />
i2c_read_block_data smbus read block data<br />
i2c_block_process_call smbus block process call<br />
</p>
<p><br />
i2c_write_i2c_block_data smbus write I2C block data<br />
i2c_read_i2c_block_data smbus read I2C block data<br />
</p>
<p><br />
i2c_read_device Reads the raw I2C device<br />
i2c_write_device Writes the raw I2C device<br />
</p>
<p><br />
i2c_zip Performs multiple I2C transactions<br />
</p>
<p><br />
bb_i2c_open Opens GPIO for bit banging I2C<br />
bb_i2c_close Closes GPIO for bit banging I2C<br />
bb_i2c_zip Performs multiple bit banged I2C transactions<br />
</p>
<h2>SPI</h2>
<p><br />
</p>
<p><br />
spi_open Opens a SPI device<br />
spi_close Closes a SPI device<br />
</p>
<p><br />
spi_read Reads bytes from a SPI device<br />
spi_write Writes bytes to a SPI device<br />
spi_xfer Transfers bytes with a SPI device<br />
</p>
<h2>SERIAL</h2>
<p><br />
</p>
<p><br />
serial_open Opens a serial device<br />
serial_close Closes a serial device<br />
</p>
<p><br />
serial_write_byte Writes a byte to a serial device<br />
serial_read_byte Reads a byte from a serial device<br />
serial_write Writes bytes to a serial device<br />
serial_read Reads bytes from a serial device<br />
</p>
<p><br />
serial_data_available Returns number of bytes ready to be read<br />
</p>
<h2>CUSTOM</h2>
<p><br />
</p>
<p><br />
custom_1 User custom function 1<br />
custom_2 User custom function 2<br />
</p>
<h2>UTILITIES</h2>
<p><br />
</p>
<p><br />
get_current_tick Get current tick (microseconds)<br />
</p>
<p><br />
get_hardware_revision Get hardware revision<br />
get_pigpio_version Get the pigpio version<br />
pigpiod_if_version Get the pigpiod_if version<br />
</p>
<p><br />
pigpio_error Get a text description of an error code.<br />
</p>
<p><br />
time_sleep Sleeps for a float number of seconds<br />
time_time Float number of seconds since the epoch<br />
</p>
<h1>FUNCTIONS</h1>
<ul>
<li></li>
<li><p>Return the current time in seconds since the Epoch.</p></li>
</ul>
<ul>
<li></li>
<li><p>Delay execution for a given number of seconds.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>seconds: the number of seconds to delay.


</code></pre>
<ul>
<li></li>
<li><p>Return a text description for an error code.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>errnum: the error code.


</code></pre>
<ul>
<li></li>
<li><p>Return the pigpiod_if version.</p></li>
</ul>
<ul>
<li></li>
<li><p>Starts a new thread of execution with thread_func as the main routine.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>thread_func: the main function for the new thread.


   userdata: a pointer to an arbitrary argument.


</code></pre>
<p><br />
</p>
<p><br />
Returns a pointer to pthread_t if OK, otherwise NULL.</p>
<p><br />
</p>
<p><br />
The function is passed the single argument userdata.</p>
<p><br />
</p>
<p><br />
The thread can be cancelled by passing the pointer to pthread_t to <strong>stop_thread</strong>.</p>
<ul>
<li></li>
<li><p>Cancels the thread pointed at by pth.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>pth: the thread to be stopped.


</code></pre>
<p><br />
</p>
<p><br />
No value is returned.</p>
<p><br />
</p>
<p><br />
The thread to be stopped should have been started with <strong>start_thread</strong>.</p>
<ul>
<li></li>
<li><p>Connect to the pigpio daemon. Reserving command and notification streams.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>addrStr: specifies the host or IP address of the Pi running the


         pigpio daemon.  It may be NULL in which case localhost


         is used unless overridden by the PIGPIO_ADDR environment


         variable.





portStr: specifies the port address used by the Pi running the


         pigpio daemon.  It may be NULL in which case &quot;8888&quot;


         is used unless overridden by the PIGPIO_PORT environment


         variable.


</code></pre>
<ul>
<li></li>
<li><p>Terminates the connection to the pigpio daemon and releases resources used by the library.</p></li>
</ul>
<ul>
<li></li>
<li><p>Set the GPIO mode.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>gpio: 0-53.


mode: PI_INPUT, PI_OUTPUT, PI_ALT0, PI_ALT1,


      PI_ALT2, PI_ALT3, PI_ALT4, PI_ALT5.


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_GPIO, PI_BAD_MODE, or PI_NOT_PERMITTED.</p>
<ul>
<li></li>
<li><p>Get the GPIO mode.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>gpio: 0-53.


</code></pre>
<p><br />
</p>
<p><br />
Returns the GPIO mode if OK, otherwise PI_BAD_GPIO.</p>
<ul>
<li></li>
<li><p>Set or clear the GPIO pull-up/down resistor.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>gpio: 0-53.


 pud: PI_PUD_UP, PI_PUD_DOWN, PI_PUD_OFF.


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_GPIO, PI_BAD_PUD, or PI_NOT_PERMITTED.</p>
<ul>
<li></li>
<li><p>Read the GPIO level.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>gpio:0-53.


</code></pre>
<p><br />
</p>
<p><br />
Returns the GPIO level if OK, otherwise PI_BAD_GPIO.</p>
<ul>
<li></li>
<li><p>Write the GPIO level.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code> gpio: 0-53.


level: 0, 1.


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_GPIO, PI_BAD_LEVEL, or PI_NOT_PERMITTED.</p>
<p><br />
</p>
<p><br />
Notes</p>
<p><br />
</p>
<p><br />
If PWM or servo pulses are active on the GPIO they are switched off.</p>
<ul>
<li></li>
<li><p>Start (non-zero dutycycle) or stop (0) PWM pulses on the GPIO.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_gpio: 0-31.


dutycycle: 0-range (range defaults to 255).


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_USER_GPIO, PI_BAD_DUTYCYCLE, or PI_NOT_PERMITTED. Notes</p>
<p><br />
</p>
<p><br />
The <strong>set_PWM_range</strong> function may be used to change the default range of 255.</p>
<ul>
<li></li>
<li><p>Return the PWM dutycycle in use on a GPIO.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_gpio: 0-31.


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_USER_GPIO or PI_NOT_PWM_GPIO.</p>
<p><br />
</p>
<p><br />
For normal PWM the dutycycle will be out of the defined range for the GPIO (see <strong>get_PWM_range</strong>).</p>
<p><br />
</p>
<p><br />
If a hardware clock is active on the GPIO the reported dutycycle will be 500000 (500k) out of 1000000 (1M).</p>
<p><br />
</p>
<p><br />
If hardware PWM is active on the GPIO the reported dutycycle will be out of a 1000000 (1M).</p>
<ul>
<li></li>
<li><p>Set the range of PWM values to be used on the GPIO.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_gpio: 0-31.


    range: 25-40000.


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_USER_GPIO, PI_BAD_DUTYRANGE, or PI_NOT_PERMITTED.</p>
<p><br />
</p>
<p><br />
Notes</p>
<p><br />
</p>
<p><br />
If PWM is currently active on the GPIO its dutycycle will be scaled to reflect the new range.</p>
<p><br />
</p>
<p><br />
The real range, the number of steps between fully off and fully on for each of the 18 available GPIO frequencies is</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>  25(#1),    50(#2),   100(#3),   125(#4),    200(#5),    250(#6),


 400(#7),   500(#8),   625(#9),   800(#10),  1000(#11),  1250(#12),


2000(#13), 2500(#14), 4000(#15), 5000(#16), 10000(#17), 20000(#18)


</code></pre>
<p><br />
</p>
<p><br />
The real value set by set_PWM_range is (dutycycle * real range) / range.</p>
<ul>
<li></li>
<li><p>Get the range of PWM values being used on the GPIO.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_gpio: 0-31.


</code></pre>
<p><br />
</p>
<p><br />
Returns the dutycycle range used for the GPIO if OK, otherwise PI_BAD_USER_GPIO.</p>
<p><br />
</p>
<p><br />
If a hardware clock or hardware PWM is active on the GPIO the reported range will be 1000000 (1M).</p>
<ul>
<li></li>
<li><p>Get the real underlying range of PWM values being used on the GPIO.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_gpio: 0-31.


</code></pre>
<p><br />
</p>
<p><br />
Returns the real range used for the GPIO if OK, otherwise PI_BAD_USER_GPIO.</p>
<p><br />
</p>
<p><br />
If a hardware clock is active on the GPIO the reported real range will be 1000000 (1M).</p>
<p><br />
</p>
<p><br />
If hardware PWM is active on the GPIO the reported real range will be approximately 250M divided by the set PWM frequency.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
<li><p>Set the frequency (in Hz) of the PWM to be used on the GPIO.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_gpio: 0-31.


frequency: &gt;=0 (Hz).


</code></pre>
<p><br />
</p>
<p><br />
Returns the numerically closest frequency if OK, otherwise PI_BAD_USER_GPIO or PI_NOT_PERMITTED.</p>
<p><br />
</p>
<p><br />
If PWM is currently active on the GPIO it will be switched off and then back on at the new frequency.</p>
<p><br />
</p>
<p><br />
Each GPIO can be independently set to one of 18 different PWM frequencies.</p>
<p><br />
</p>
<p><br />
The selectable frequencies depend upon the sample rate which may be 1, 2, 4, 5, 8, or 10 microseconds (default 5). The sample rate is set when the pigpio daemon is started.</p>
<p><br />
</p>
<p><br />
The frequencies for each sample rate are:</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>                       Hertz





       1: 40000 20000 10000 8000 5000 4000 2500 2000 1600


           1250  1000   800  500  400  250  200  100   50





       2: 20000 10000  5000 4000 2500 2000 1250 1000  800


            625   500   400  250  200  125  100   50   25





       4: 10000  5000  2500 2000 1250 1000  625  500  400


            313   250   200  125  100   63   50   25   13


sample


 rate


 (us)  5:  8000  4000  2000 1600 1000  800  500  400  320


            250   200   160  100   80   50   40   20   10





       8:  5000  2500  1250 1000  625  500  313  250  200


            156   125   100   63   50   31   25   13    6





      10:  4000  2000  1000  800  500  400  250  200  160


            125   100    80   50   40   25   20   10    5


</code></pre>
<ul>
<li></li>
<li><p>Get the frequency of PWM being used on the GPIO.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_gpio: 0-31.


</code></pre>
<p><br />
</p>
<p><br />
For normal PWM the frequency will be that defined for the GPIO by <strong>set_PWM_frequency</strong>.</p>
<p><br />
</p>
<p><br />
If a hardware clock is active on the GPIO the reported frequency will be that set by <strong>hardware_clock</strong>.</p>
<p><br />
</p>
<p><br />
If hardware PWM is active on the GPIO the reported frequency will be that set by <strong>hardware_PWM</strong>.</p>
<p><br />
</p>
<p><br />
Returns the frequency (in hertz) used for the GPIO if OK, otherwise PI_BAD_USER_GPIO.</p>
<ul>
<li></li>
<li><p>Start (500-2500) or stop (0) servo pulses on the GPIO.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code> user_gpio: 0-31.


pulsewidth: 0 (off), 500 (anti-clockwise) - 2500 (clockwise).


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_USER_GPIO, PI_BAD_PULSEWIDTH or PI_NOT_PERMITTED.</p>
<p><br />
</p>
<p><br />
The selected pulsewidth will continue to be transmitted until changed by a subsequent call to set_servo_pulsewidth.</p>
<p><br />
</p>
<p><br />
The pulsewidths supported by servos varies and should probably be determined by experiment. A value of 1500 should always be safe and represents the mid-point of rotation.</p>
<p><br />
</p>
<p><br />
You can DAMAGE a servo if you command it to move beyond its limits.</p>
<p><br />
</p>
<p><br />
OTHER UPDATE RATES:</p>
<p><br />
</p>
<p><br />
This function updates servos at 50Hz. If you wish to use a different update frequency you will have to use the PWM functions.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>Update Rate (Hz)     50   100  200  400  500


1E6/Hz            20000 10000 5000 2500 2000


</code></pre>
<p><br />
</p>
<p><br />
Firstly set the desired PWM frequency using <strong>set_PWM_frequency</strong>.</p>
<p><br />
</p>
<p><br />
Then set the PWM range using <strong>set_PWM_range</strong> to 1E6/Hz. Doing this allows you to use units of microseconds when setting the servo pulsewidth.</p>
<p><br />
</p>
<p><br />
E.g. If you want to update a servo connected to GPIO 25 at 400Hz</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>set_PWM_frequency(25, 400);


set_PWM_range(25, 2500);


</code></pre>
<p><br />
</p>
<p><br />
Thereafter use the <strong>set_PWM_dutycycle</strong> function to move the servo, e.g. set_PWM_dutycycle(25, 1500) will set a 1500 us pulse.<br />
</p>
<ul>
<li></li>
<li><p>Return the servo pulsewidth in use on a GPIO.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_gpio: 0-31.


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_USER_GPIO or PI_NOT_SERVO_GPIO.</p>
<ul>
<li></li>
<li><p>Get a free notification handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
Returns a handle greater than or equal to zero if OK, otherwise PI_NO_HANDLE.</p>
<p><br />
</p>
<p><br />
A notification is a method for being notified of GPIO state changes via a pipe.</p>
<p><br />
</p>
<p><br />
Pipes are only accessible from the local machine so this function serves no purpose if you are using the library from a remote machine. The in-built (socket) notifications provided by <strong>callback</strong> should be used instead.</p>
<p><br />
</p>
<p><br />
Notifications for handle x will be available at the pipe named /dev/pigpiox (where x is the handle number). E.g. if the function returns 15 then the notifications must be read from /dev/pigpio15.</p>
<ul>
<li></li>
<li><p>Start notifications on a previously opened handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: 0-31 (as returned by notify_open)


  bits: a mask indicating the GPIO to be notified.


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_HANDLE.</p>
<p><br />
</p>
<p><br />
The notification sends state changes for each GPIO whose corresponding bit in bits is set.</p>
<p><br />
</p>
<p><br />
Each notification occupies 12 bytes in the fifo as follows:</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>typedef struct


{


   uint16_t seqno;


   uint16_t flags;


   uint32_t tick;


   uint32_t level;


} gpioReport_t;


</code></pre>
<p><br />
</p>
<p><br />
seqno: starts at 0 each time the handle is opened and then increments by one for each report.</p>
<p><br />
</p>
<p><br />
flags: two flags are defined, PI_NTFY_FLAGS_WDOG and PI_NTFY_FLAGS_ALIVE.</p>
<p><br />
</p>
<p><br />
PI_NTFY_FLAGS_WDOG, if bit 5 is set then bits 0-4 of the flags indicate a GPIO which has had a watchdog timeout.</p>
<p><br />
</p>
<p><br />
PI_NTFY_FLAGS_ALIVE, if bit 6 is set this indicates a keep alive signal on the pipe/socket and is sent once a minute in the absence of other notification activity.</p>
<p><br />
</p>
<p><br />
tick: the number of microseconds since system boot. It wraps around after 1h12m.</p>
<p><br />
</p>
<p><br />
level: indicates the level of each GPIO. If bit 1&lt;&lt;x is set then GPIO x is high.</p>
<ul>
<li></li>
<li><p>Pause notifications on a previously opened handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: 0-31 (as returned by notify_open)


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_HANDLE.</p>
<p><br />
</p>
<p><br />
Notifications for the handle are suspended until <strong>notify_begin</strong> is called again.</p>
<ul>
<li></li>
<li><p>Stop notifications on a previously opened handle and release the handle for reuse.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: 0-31 (as returned by notify_open)


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_HANDLE.</p>
<ul>
<li></li>
<li><p>Sets a watchdog for a GPIO.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_gpio: 0-31.


  timeout: 0-60000.


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_USER_GPIO or PI_BAD_WDOG_TIMEOUT.</p>
<p><br />
</p>
<p><br />
The watchdog is nominally in milliseconds.</p>
<p><br />
</p>
<p><br />
Only one watchdog may be registered per GPIO.</p>
<p><br />
</p>
<p><br />
The watchdog may be cancelled by setting timeout to 0.</p>
<p><br />
</p>
<p><br />
Once a watchdog has been started callbacks for the GPIO will be triggered every timeout interval after the last GPIO activity.</p>
<p><br />
</p>
<p><br />
The callback will receive the special level PI_TIMEOUT.</p>
<ul>
<li></li>
<li><p>Sets a glitch filter on a GPIO.</p></li>
</ul>
<p><br />
</p>
<p><br />
Level changes on the GPIO are not reported unless the level has been stable for at least <strong>steady</strong> microseconds. The level is then reported. Level changes of less than <strong>steady</strong> microseconds are ignored.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_gpio: 0-31


   steady: 0-300000


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_USER_GPIO, or PI_BAD_FILTER.</p>
<p><br />
</p>
<p><br />
This filter affects the GPIO samples returned to callbacks set up with <strong>callback</strong>, <strong>callback_ex</strong> and <strong>wait_for_edge</strong>.</p>
<p><br />
</p>
<p><br />
It does not affect levels read by <strong>gpio_read</strong>, <strong>read_bank_1</strong>, or <strong>read_bank_2</strong>. Each (stable) edge will be timestamped <strong>steady</strong> microseconds after it was first detected.</p>
<ul>
<li></li>
<li><p>Sets a noise filter on a GPIO.</p></li>
</ul>
<p><br />
</p>
<p><br />
Level changes on the GPIO are ignored until a level which has been stable for <strong>steady</strong> microseconds is detected. Level changes on the GPIO are then reported for <strong>active</strong> microseconds after which the process repeats.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_gpio: 0-31


   steady: 0-300000


   active: 0-1000000


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_USER_GPIO, or PI_BAD_FILTER.</p>
<p><br />
</p>
<p><br />
This filter affects the GPIO samples returned to callbacks set up with <strong>callback</strong>, <strong>callback_ex</strong> and <strong>wait_for_edge</strong>.</p>
<p><br />
</p>
<p><br />
It does not affect levels read by <strong>gpio_read</strong>, <strong>read_bank_1</strong>, or <strong>read_bank_2</strong>.</p>
<p><br />
</p>
<p><br />
Level changes before and after the active period may be reported. Your software must be designed to cope with such reports.</p>
<ul>
<li></li>
<li><p>Read the levels of the bank 1 GPIO (GPIO 0-31).</p></li>
</ul>
<p><br />
</p>
<p><br />
The returned 32 bit integer has a bit set if the corresponding GPIO is logic 1. GPIO n has bit value (1&lt;&lt;n).</p>
<ul>
<li></li>
<li><p>Read the levels of the bank 2 GPIO (GPIO 32-53).</p></li>
</ul>
<p><br />
</p>
<p><br />
The returned 32 bit integer has a bit set if the corresponding GPIO is logic 1. GPIO n has bit value (1&lt;&lt;(n-32)).</p>
<ul>
<li></li>
<li><p>Clears GPIO 0-31 if the corresponding bit in bits is set.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>bits: a bit mask with 1 set if the corresponding GPIO is


      to be cleared.


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_SOME_PERMITTED.</p>
<p><br />
</p>
<p><br />
A status of PI_SOME_PERMITTED indicates that the user is not allowed to write to one or more of the GPIO.</p>
<ul>
<li></li>
<li><p>Clears GPIO 32-53 if the corresponding bit (0-21) in bits is set.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>bits: a bit mask with 1 set if the corresponding GPIO is


      to be cleared.


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_SOME_PERMITTED.</p>
<p><br />
</p>
<p><br />
A status of PI_SOME_PERMITTED indicates that the user is not allowed to write to one or more of the GPIO.</p>
<ul>
<li></li>
<li><p>Sets GPIO 0-31 if the corresponding bit in bits is set.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>bits: a bit mask with 1 set if the corresponding GPIO is


      to be set.


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_SOME_PERMITTED.</p>
<p><br />
</p>
<p><br />
A status of PI_SOME_PERMITTED indicates that the user is not allowed to write to one or more of the GPIO.</p>
<ul>
<li></li>
<li><p>Sets GPIO 32-53 if the corresponding bit (0-21) in bits is set.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>bits: a bit mask with 1 set if the corresponding GPIO is


      to be set.


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_SOME_PERMITTED.</p>
<p><br />
</p>
<p><br />
A status of PI_SOME_PERMITTED indicates that the user is not allowed to write to one or more of the GPIO.</p>
<ul>
<li></li>
<li><p>Starts a hardware clock on a GPIO at the specified frequency. Frequencies above 30MHz are unlikely to work.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>     gpio: see description


frequency: 0 (off) or 4689-250000000 (250M)


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_NOT_PERMITTED, PI_BAD_GPIO, PI_NOT_HCLK_GPIO, PI_BAD_HCLK_FREQ,or PI_BAD_HCLK_PASS.</p>
<p><br />
</p>
<p><br />
The same clock is available on multiple GPIO. The latest frequency setting will be used by all GPIO which share a clock.</p>
<p><br />
</p>
<p><br />
The GPIO must be one of the following.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>4   clock 0  All models


5   clock 1  All models but A and B (reserved for system use)


6   clock 2  All models but A and B


20  clock 0  All models but A and B


21  clock 1  All models but A and Rev.2 B (reserved for system use)





32  clock 0  Compute module only


34  clock 0  Compute module only


42  clock 1  Compute module only (reserved for system use)


43  clock 2  Compute module only


44  clock 1  Compute module only (reserved for system use)


</code></pre>
<p><br />
</p>
<p><br />
Access to clock 1 is protected by a password as its use will likely crash the Pi. The password is given by or'ing 0x5A000000 with the GPIO number.</p>
<ul>
<li></li>
<li><p>Starts hardware PWM on a GPIO at the specified frequency and dutycycle. Frequencies above 30MHz are unlikely to work.</p></li>
</ul>
<p><br />
</p>
<p><br />
NOTE: Any waveform started by <strong>wave_send_once</strong>, <strong>wave_send_repeat</strong>, or <strong>wave_chain</strong> will be cancelled.</p>
<p><br />
</p>
<p><br />
This function is only valid if the pigpio main clock is PCM. The main clock defaults to PCM but may be overridden when the pigpio daemon is started (option -t).</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>   gpio: see descripton


PWMfreq: 0 (off) or 1-125000000 (125M)


PWMduty: 0 (off) to 1000000 (1M)(fully on)


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_NOT_PERMITTED, PI_BAD_GPIO, PI_NOT_HPWM_GPIO, PI_BAD_HPWM_DUTY, PI_BAD_HPWM_FREQ, or PI_HPWM_ILLEGAL.</p>
<p><br />
</p>
<p><br />
The same PWM channel is available on multiple GPIO. The latest frequency and dutycycle setting will be used by all GPIO which share a PWM channel.</p>
<p><br />
</p>
<p><br />
The GPIO must be one of the following.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>12  PWM channel 0  All models but A and B


13  PWM channel 1  All models but A and B


18  PWM channel 0  All models


19  PWM channel 1  All models but A and B





40  PWM channel 0  Compute module only


41  PWM channel 1  Compute module only


45  PWM channel 1  Compute module only


52  PWM channel 0  Compute module only


53  PWM channel 1  Compute module only


</code></pre>
<ul>
<li></li>
<li><p>Gets the current system tick.</p></li>
</ul>
<p><br />
</p>
<p><br />
Tick is the number of microseconds since system boot.</p>
<p><br />
</p>
<p><br />
As tick is an unsigned 32 bit quantity it wraps around after 2**32 microseconds, which is approximately 1 hour 12 minutes.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
<li><p>Get the Pi's hardware revision number.</p></li>
</ul>
<p><br />
</p>
<p><br />
The hardware revision is the last few characters on the Revision line of /proc/cpuinfo.</p>
<p><br />
</p>
<p><br />
If the hardware revision can not be found or is not a valid hexadecimal number the function returns 0.</p>
<p><br />
</p>
<p><br />
The revision number can be used to determine the assignment of GPIO to pins (see <strong>gpio</strong>).</p>
<p><br />
</p>
<p><br />
There are at least three types of board.</p>
<p><br />
</p>
<p><br />
Type 1 boards have hardware revision numbers of 2 and 3.</p>
<p><br />
</p>
<p><br />
Type 2 boards have hardware revision numbers of 4, 5, 6, and 15.</p>
<p><br />
</p>
<p><br />
Type 3 boards have hardware revision numbers of 16 or greater.</p>
<ul>
<li></li>
<li><p>Returns the pigpio version.</p></li>
</ul>
<ul>
<li></li>
<li><p>This function clears all waveforms and any data added by calls to the <strong>wave_add_*</strong> functions.</p></li>
</ul>
<p><br />
</p>
<p><br />
Returns 0 if OK.</p>
<ul>
<li></li>
<li><p>This function starts a new empty waveform. You wouldn't normally need to call this function as it is automatically called after a waveform is created with the <strong>wave_create</strong> function.</p></li>
</ul>
<p><br />
</p>
<p><br />
Returns 0 if OK.</p>
<ul>
<li></li>
<li><p>This function adds a number of pulses to the current waveform.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>numPulses: the number of pulses.


   pulses: an array of pulses.


</code></pre>
<p><br />
</p>
<p><br />
Returns the new total number of pulses in the current waveform if OK, otherwise PI_TOO_MANY_PULSES.</p>
<p><br />
</p>
<p><br />
The pulses are interleaved in time order within the existing waveform (if any).</p>
<p><br />
</p>
<p><br />
Merging allows the waveform to be built in parts, that is the settings for GPIO#1 can be added, and then GPIO#2 etc.</p>
<p><br />
</p>
<p><br />
If the added waveform is intended to start after or within the existing waveform then the first pulse should consist solely of a delay.</p>
<ul>
<li></li>
<li><p>This function adds a waveform representing serial data to the existing waveform (if any). The serial data starts offset microseconds from the start of the waveform.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_gpio: 0-31.


     baud: 50-1000000


data_bits: number of data bits (1-32)


stop_bits: number of stop half bits (2-8)


   offset: &gt;=0


 numBytes: &gt;=1


      str: an array of chars.


</code></pre>
<p><br />
</p>
<p><br />
Returns the new total number of pulses in the current waveform if OK, otherwise PI_BAD_USER_GPIO, PI_BAD_WAVE_BAUD, PI_BAD_DATABITS, PI_BAD_STOP_BITS, PI_TOO_MANY_CHARS, PI_BAD_SER_OFFSET, or PI_TOO_MANY_PULSES.</p>
<p><br />
</p>
<p><br />
NOTES:</p>
<p><br />
</p>
<p><br />
The serial data is formatted as one start bit, <strong>data_bits</strong> data bits, and <strong>stop_bits</strong>/2 stop bits.</p>
<p><br />
</p>
<p><br />
It is legal to add serial data streams with different baud rates to the same waveform.</p>
<p><br />
</p>
<p><br />
<strong>numBytes</strong> is the number of bytes of data in str.</p>
<p><br />
</p>
<p><br />
The bytes required for each character depend upon <strong>data_bits</strong>.</p>
<p><br />
</p>
<p><br />
For <strong>data_bits</strong> 1-8 there will be one byte per character.<br />
For <strong>data_bits</strong> 9-16 there will be two bytes per character.<br />
For <strong>data_bits</strong> 17-32 there will be four bytes per character.</p>
<ul>
<li></li>
<li><p>This function creates a waveform from the data provided by the prior calls to the <strong>wave_add_*</strong> functions. Upon success a wave id greater than or equal to 0 is returned, otherwise PI_EMPTY_WAVEFORM, PI_TOO_MANY_CBS, PI_TOO_MANY_OOL, or PI_NO_WAVEFORM_ID.</p></li>
</ul>
<p><br />
</p>
<p><br />
The data provided by the <strong>wave_add_*</strong> functions is consumed by this function.</p>
<p><br />
</p>
<p><br />
As many waveforms may be created as there is space available. The wave id is passed to <strong>wave_send_*</strong> to specify the waveform to transmit.</p>
<p><br />
</p>
<p><br />
Normal usage would be</p>
<p><br />
</p>
<p><br />
Step 1. <strong>wave_clear</strong> to clear all waveforms and added data.</p>
<p><br />
</p>
<p><br />
Step 2. <strong>wave_add_*</strong> calls to supply the waveform data.</p>
<p><br />
</p>
<p><br />
Step 3. <strong>wave_create</strong> to create the waveform and get a unique id</p>
<p><br />
</p>
<p><br />
Repeat steps 2 and 3 as needed.</p>
<p><br />
</p>
<p><br />
Step 4. <strong>wave_send_*</strong> with the id of the waveform to transmit.</p>
<p><br />
</p>
<p><br />
A waveform comprises one or more pulses. Each pulse consists of a <strong>gpioPulse_t</strong> structure.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>typedef struct


{


   uint32_t gpioOn;


   uint32_t gpioOff;


   uint32_t usDelay;


} gpioPulse_t;


</code></pre>
<p><br />
</p>
<p><br />
The fields specify</p>
<p><br />
</p>
<p><br />
1) the GPIO to be switched on at the start of the pulse.<br />
2) the GPIO to be switched off at the start of the pulse.<br />
3) the delay in microseconds before the next pulse.<br />
</p>
<p><br />
</p>
<p><br />
Any or all the fields can be zero. It doesn't make any sense to set all the fields to zero (the pulse will be ignored).</p>
<p><br />
</p>
<p><br />
When a waveform is started each pulse is executed in order with the specified delay between the pulse and the next.</p>
<p><br />
</p>
<p><br />
Returns the new waveform id if OK, otherwise PI_EMPTY_WAVEFORM, PI_NO_WAVEFORM_ID, PI_TOO_MANY_CBS, or PI_TOO_MANY_OOL.</p>
<ul>
<li></li>
<li><p>This function deletes the waveform with id wave_id.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>wave_id: &gt;=0, as returned by wave_create.


</code></pre>
<p><br />
</p>
<p><br />
Wave ids are allocated in order, 0, 1, 2, etc.</p>
<p><br />
</p>
<p><br />
The wave is flagged for deletion. The resources used by the wave will only be reused when either of the following apply.</p>
<p><br />
</p>
<p><br />
- all waves with higher numbered wave ids have been deleted or have been flagged for deletion.</p>
<p><br />
</p>
<p><br />
- a new wave is created which uses exactly the same resources as the current wave (see the C source for gpioWaveCreate for details).</p>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_WAVE_ID.</p>
<ul>
<li></li>
<li><p>This function transmits the waveform with id wave_id. The waveform is sent once.</p></li>
</ul>
<p><br />
</p>
<p><br />
NOTE: Any hardware PWM started by <strong>hardware_PWM</strong> will be cancelled.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>wave_id: &gt;=0, as returned by wave_create.


</code></pre>
<p><br />
</p>
<p><br />
Returns the number of DMA control blocks in the waveform if OK, otherwise PI_BAD_WAVE_ID, or PI_BAD_WAVE_MODE.</p>
<ul>
<li></li>
<li><p>This function transmits the waveform with id wave_id. The waveform cycles until cancelled (either by the sending of a new waveform or by <strong>wave_tx_stop</strong>).</p></li>
</ul>
<p><br />
</p>
<p><br />
NOTE: Any hardware PWM started by <strong>hardware_PWM</strong> will be cancelled.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>wave_id: &gt;=0, as returned by wave_create.


</code></pre>
<p><br />
</p>
<p><br />
Returns the number of DMA control blocks in the waveform if OK, otherwise PI_BAD_WAVE_ID, or PI_BAD_WAVE_MODE.</p>
<ul>
<li></li>
<li><p>This function transmits a chain of waveforms.</p></li>
</ul>
<p><br />
</p>
<p><br />
NOTE: Any hardware PWM started by <strong>hardware_PWM</strong> will be cancelled.</p>
<p><br />
</p>
<p><br />
The waves to be transmitted are specified by the contents of buf which contains an ordered list of <strong>wave_id</strong>s and optional command codes and related data.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>    buf: pointer to the wave_ids and optional command codes


bufSize: the number of bytes in buf


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_CHAIN_NESTING, PI_CHAIN_LOOP_CNT, PI_BAD_CHAIN_LOOP, PI_BAD_CHAIN_CMD, PI_CHAIN_COUNTER, PI_BAD_CHAIN_DELAY, PI_CHAIN_TOO_BIG, or PI_BAD_WAVE_ID.</p>
<p><br />
</p>
<p><br />
Each wave is transmitted in the order specified. A wave may occur multiple times per chain.</p>
<p><br />
</p>
<p><br />
A blocks of waves may be transmitted multiple times by using the loop commands. The block is bracketed by loop start and end commands. Loops may be nested.</p>
<p><br />
</p>
<p><br />
Delays between waves may be added with the delay command.</p>
<p><br />
</p>
<p><br />
The following command codes are supported:</p>
<p><br />
</p>
<p><br />
Name Cmd &amp; Data Meaning<br />
Loop Start 255 0 Identify start of a wave block<br />
Loop Repeat 255 1 x y loop x + y*256 times<br />
Delay 255 2 x y delay x + y*256 microseconds<br />
Loop Forever 255 3 loop forever<br />
</p>
<p><br />
</p>
<p><br />
If present Loop Forever must be the last entry in the chain.</p>
<p><br />
</p>
<p><br />
The code is currently dimensioned to support a chain with roughly 600 entries and 20 loop counters.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>#include &lt;stdio.h&gt;


#include &lt;pigpiod_if.h&gt;





#define WAVES 5


#define GPIO 4





int main(int argc, char *argv[])


{


   int i, wid[WAVES];





   if (pigpio_start(0, 0)&lt;0) return -1;





   set_mode(GPIO, PI_OUTPUT);





   for (i=0; i&lt;WAVES; i++)


   {


      wave_add_generic(2, (gpioPulse_t[])


         {{1&lt;&lt;GPIO, 0,        20},


          {0, 1&lt;&lt;GPIO, (i+1)*200}});





      wid[i] = wave_create();


   }





   wave_chain((char []) {


      wid[4], wid[3], wid[2],       // transmit waves 4+3+2


      255, 0,                       // loop start


         wid[0], wid[0], wid[0],    // transmit waves 0+0+0


         255, 0,                    // loop start


            wid[0], wid[1],         // transmit waves 0+1


            255, 2, 0x88, 0x13,     // delay 5000us


         255, 1, 30, 0,             // loop end (repeat 30 times)


         255, 0,                    // loop start


            wid[2], wid[3], wid[0], // transmit waves 2+3+0


            wid[3], wid[1], wid[2], // transmit waves 3+1+2


         255, 1, 10, 0,             // loop end (repeat 10 times)


      255, 1, 5, 0,                 // loop end (repeat 5 times)


      wid[4], wid[4], wid[4],       // transmit waves 4+4+4


      255, 2, 0x20, 0x4E,           // delay 20000us


      wid[0], wid[0], wid[0],       // transmit waves 0+0+0





      }, 46);





   while (wave_tx_busy()) time_sleep(0.1);





   for (i=0; i&lt;WAVES; i++) wave_delete(wid[i]);





   pigpio_stop();


}


</code></pre>
<ul>
<li></li>
<li><p>This function checks to see if a waveform is currently being transmitted.</p></li>
</ul>
<p><br />
</p>
<p><br />
Returns 1 if a waveform is currently being transmitted, otherwise 0.</p>
<ul>
<li></li>
<li><p>This function stops the transmission of the current waveform.</p></li>
</ul>
<p><br />
</p>
<p><br />
Returns 0 if OK.</p>
<p><br />
</p>
<p><br />
This function is intended to stop a waveform started with the repeat mode.</p>
<ul>
<li></li>
<li><p>This function returns the length in microseconds of the current waveform.</p></li>
</ul>
<ul>
<li></li>
<li><p>This function returns the length in microseconds of the longest waveform created since the pigpio daemon was started.</p></li>
</ul>
<ul>
<li></li>
<li><p>This function returns the maximum possible size of a waveform in<br />
microseconds.</p></li>
</ul>
<ul>
<li></li>
<li><p>This function returns the length in pulses of the current waveform.</p></li>
</ul>
<ul>
<li></li>
<li><p>This function returns the length in pulses of the longest waveform created since the pigpio daemon was started.</p></li>
</ul>
<ul>
<li></li>
<li><p>This function returns the maximum possible size of a waveform in pulses.</p></li>
</ul>
<ul>
<li></li>
<li><p>This function returns the length in DMA control blocks of the current waveform.</p></li>
</ul>
<ul>
<li></li>
<li><p>This function returns the length in DMA control blocks of the longest waveform created since the pigpio daemon was started.</p></li>
</ul>
<ul>
<li></li>
<li><p>This function returns the maximum possible size of a waveform in DMA control blocks.</p></li>
</ul>
<ul>
<li></li>
<li><p>This function sends a trigger pulse to a GPIO. The GPIO is set to level for pulseLen microseconds and then reset to not level.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_gpio: 0-31.


 pulseLen: 1-100.


    level: 0,1.


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_USER_GPIO, PI_BAD_LEVEL, PI_BAD_PULSELEN, or PI_NOT_PERMITTED.</p>
<ul>
<li></li>
<li><p>This function stores a script for later execution.</p></li>
</ul>
<p><br />
</p>
<p><br />
See <strong>http://abyz.me.uk/rpi/pigpio/pigs.html#Scripts</strong> for details.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>script: the text of the script.


</code></pre>
<p><br />
</p>
<p><br />
The function returns a script id if the script is valid, otherwise PI_BAD_SCRIPT.</p>
<ul>
<li></li>
<li><p>This function runs a stored script.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>script_id: &gt;=0, as returned by store_script.


   numPar: 0-10, the number of parameters.


    param: an array of parameters.


</code></pre>
<p><br />
</p>
<p><br />
The function returns 0 if OK, otherwise PI_BAD_SCRIPT_ID, or PI_TOO_MANY_PARAM</p>
<p><br />
</p>
<p><br />
param is an array of up to 10 parameters which may be referenced in the script as p0 to p9.</p>
<ul>
<li></li>
<li><p>This function returns the run status of a stored script as well as the current values of parameters 0 to 9.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>script_id: &gt;=0, as returned by store_script.


    param: an array to hold the returned 10 parameters.


</code></pre>
<p><br />
</p>
<p><br />
The function returns greater than or equal to 0 if OK, otherwise PI_BAD_SCRIPT_ID.</p>
<p><br />
</p>
<p><br />
The run status may be</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>PI_SCRIPT_INITING


PI_SCRIPT_HALTED


PI_SCRIPT_RUNNING


PI_SCRIPT_WAITING


PI_SCRIPT_FAILED


</code></pre>
<p><br />
</p>
<p><br />
The current value of script parameters 0 to 9 are returned in param.</p>
<ul>
<li></li>
<li><p>This function stops a running script.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>script_id: &gt;=0, as returned by store_script.


</code></pre>
<p><br />
</p>
<p><br />
The function returns 0 if OK, otherwise PI_BAD_SCRIPT_ID.</p>
<ul>
<li></li>
<li><p>This function deletes a stored script.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>script_id: &gt;=0, as returned by store_script.


</code></pre>
<p><br />
</p>
<p><br />
The function returns 0 if OK, otherwise PI_BAD_SCRIPT_ID.</p>
<ul>
<li></li>
<li><p>This function opens a GPIO for bit bang reading of serial data.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_gpio: 0-31.


     baud: 50-250000


data_bits: 1-32


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_USER_GPIO, PI_BAD_WAVE_BAUD, or PI_GPIO_IN_USE.</p>
<p><br />
</p>
<p><br />
The serial data is returned in a cyclic buffer and is read using bb_serial_read.</p>
<p><br />
</p>
<p><br />
It is the caller's responsibility to read data from the cyclic buffer in a timely fashion.</p>
<ul>
<li></li>
<li><p>This function copies up to bufSize bytes of data read from the bit bang serial cyclic buffer to the buffer starting at buf.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_gpio: 0-31, previously opened with bb_serial_read_open.


      buf: an array to receive the read bytes.


  bufSize: &gt;=0


</code></pre>
<p><br />
</p>
<p><br />
Returns the number of bytes copied if OK, otherwise PI_BAD_USER_GPIO or PI_NOT_SERIAL_GPIO.</p>
<p><br />
</p>
<p><br />
The bytes returned for each character depend upon the number of data bits <strong>data_bits</strong> specified in the <strong>bb_serial_read_open</strong> command.</p>
<p><br />
</p>
<p><br />
For <strong>data_bits</strong> 1-8 there will be one byte per character.<br />
For <strong>data_bits</strong> 9-16 there will be two bytes per character.<br />
For <strong>data_bits</strong> 17-32 there will be four bytes per character.</p>
<ul>
<li></li>
<li><p>This function closes a GPIO for bit bang reading of serial data.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_gpio: 0-31, previously opened with bb_serial_read_open.


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_USER_GPIO, or PI_NOT_SERIAL_GPIO.</p>
<ul>
<li></li>
<li><p>This function inverts serial logic for big bang serial reads.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_gpio: 0-31, previously opened with bb_serial_read_open.


   invert: 0-1, 1 invert, 0 normal.


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_NOT_SERIAL_GPIO or PI_BAD_SER_INVERT.</p>
<ul>
<li></li>
<li><p>This returns a handle for the device at address i2c_addr on bus i2c_bus.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>  i2c_bus: &gt;=0.


 i2c_addr: 0-0x7F.


i2c_flags: 0.


</code></pre>
<p><br />
</p>
<p><br />
No flags are currently defined. This parameter should be set to zero.</p>
<p><br />
</p>
<p><br />
Physically buses 0 and 1 are available on the Pi. Higher numbered buses will be available if a kernel supported bus multiplexor is being used.</p>
<p><br />
</p>
<p><br />
The GPIO used are given in the following table.</p>
<p><br />
</p>
<p><br />
SDA SCL<br />
I2C 0 0 1<br />
I2C 1 2 3<br />
</p>
<p><br />
</p>
<p><br />
Returns a handle (&gt;=0) if OK, otherwise PI_BAD_I2C_BUS, PI_BAD_I2C_ADDR, PI_BAD_FLAGS, PI_NO_HANDLE, or PI_I2C_OPEN_FAILED.</p>
<p><br />
</p>
<p><br />
For the SMBus commands the low level transactions are shown at the end of the function description. The following abbreviations are used.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>S     (1 bit) : Start bit


P     (1 bit) : Stop bit


Rd/Wr (1 bit) : Read/Write bit. Rd equals 1, Wr equals 0.


A, NA (1 bit) : Accept and not accept bit.






Addr  (7 bits): I2C 7 bit address.


Comm  (8 bits): Command byte, a data byte which often selects a register.


Data  (8 bits): A data byte.


Count (8 bits): A data byte containing the length of a block operation.





[..]: Data sent by the device.


</code></pre>
<ul>
<li></li>
<li><p>This closes the I2C device associated with the handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to i2c_open.


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_HANDLE.</p>
<ul>
<li></li>
<li><p>This sends a single bit (in the Rd/Wr bit) to the device associated with handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to i2c_open.


   bit: 0-1, the value to write.


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or PI_I2C_WRITE_FAILED.</p>
<p><br />
</p>
<p><br />
Quick command. SMBus 2.0 5.5.1</p>
<pre><code>S Addr Rd/Wr [A] P


</code></pre>
<ul>
<li></li>
<li><p>This sends a single byte to the device associated with handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to i2c_open.


  bVal: 0-0xFF, the value to write.


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or PI_I2C_WRITE_FAILED.</p>
<p><br />
</p>
<p><br />
Send byte. SMBus 2.0 5.5.2</p>
<pre><code>S Addr Wr [A] Data [A] P


</code></pre>
<ul>
<li></li>
<li><p>This reads a single byte from the device associated with handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to i2c_open.


</code></pre>
<p><br />
</p>
<p><br />
Returns the byte read (&gt;=0) if OK, otherwise PI_BAD_HANDLE, or PI_I2C_READ_FAILED.</p>
<p><br />
</p>
<p><br />
Receive byte. SMBus 2.0 5.5.3</p>
<pre><code>S Addr Rd [A] [Data] NA P


</code></pre>
<ul>
<li></li>
<li><p>This writes a single byte to the specified register of the device associated with handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code> handle: &gt;=0, as returned by a call to i2c_open.


i2c_reg: 0-255, the register to write.


   bVal: 0-0xFF, the value to write.


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or PI_I2C_WRITE_FAILED.</p>
<p><br />
</p>
<p><br />
Write byte. SMBus 2.0 5.5.4</p>
<pre><code>S Addr Wr [A] Comm [A] Data [A] P


</code></pre>
<ul>
<li></li>
<li><p>This writes a single 16 bit word to the specified register of the device associated with handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code> handle: &gt;=0, as returned by a call to i2c_open.


i2c_reg: 0-255, the register to write.


   wVal: 0-0xFFFF, the value to write.


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or PI_I2C_WRITE_FAILED.</p>
<p><br />
</p>
<p><br />
Write word. SMBus 2.0 5.5.4</p>
<pre><code>S Addr Wr [A] Comm [A] DataLow [A] DataHigh [A] P


</code></pre>
<ul>
<li></li>
<li><p>This reads a single byte from the specified register of the device associated with handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code> handle: &gt;=0, as returned by a call to i2c_open.


i2c_reg: 0-255, the register to read.


</code></pre>
<p><br />
</p>
<p><br />
Returns the byte read (&gt;=0) if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or PI_I2C_READ_FAILED.</p>
<p><br />
</p>
<p><br />
Read byte. SMBus 2.0 5.5.5</p>
<pre><code>S Addr Wr [A] Comm [A] S Addr Rd [A] [Data] NA P


</code></pre>
<ul>
<li></li>
<li><p>This reads a single 16 bit word from the specified register of the device associated with handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code> handle: &gt;=0, as returned by a call to i2c_open.


i2c_reg: 0-255, the register to read.


</code></pre>
<p><br />
</p>
<p><br />
Returns the word read (&gt;=0) if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or PI_I2C_READ_FAILED.</p>
<p><br />
</p>
<p><br />
Read word. SMBus 2.0 5.5.5</p>
<pre><code>S Addr Wr [A] Comm [A] S Addr Rd [A] [DataLow] A [DataHigh] NA P


</code></pre>
<ul>
<li></li>
<li><p>This writes 16 bits of data to the specified register of the device associated with handle and and reads 16 bits of data in return.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code> handle: &gt;=0, as returned by a call to i2c_open.


i2c_reg: 0-255, the register to write/read.


   wVal: 0-0xFFFF, the value to write.


</code></pre>
<p><br />
</p>
<p><br />
Returns the word read (&gt;=0) if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or PI_I2C_READ_FAILED.</p>
<p><br />
</p>
<p><br />
Process call. SMBus 2.0 5.5.6</p>
<pre><code>S Addr Wr [A] Comm [A] DataLow [A] DataHigh [A]


   S Addr Rd [A] [DataLow] A [DataHigh] NA P


</code></pre>
<ul>
<li></li>
<li><p>This writes up to 32 bytes to the specified register of the device associated with handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code> handle: &gt;=0, as returned by a call to i2c_open.


i2c_reg: 0-255, the register to write.


    buf: an array with the data to send.


  count: 1-32, the number of bytes to write.


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or PI_I2C_WRITE_FAILED.</p>
<p><br />
</p>
<p><br />
Block write. SMBus 2.0 5.5.7</p>
<pre><code>S Addr Wr [A] Comm [A] Count [A] Data [A] Data [A] ... [A] Data [A] P


</code></pre>
<ul>
<li></li>
<li><p>This reads a block of up to 32 bytes from the specified register of the device associated with handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code> handle: &gt;=0, as returned by a call to i2c_open.


i2c_reg: 0-255, the register to read.


    buf: an array to receive the read data.


</code></pre>
<p><br />
</p>
<p><br />
The amount of returned data is set by the device.</p>
<p><br />
</p>
<p><br />
Returns the number of bytes read (&gt;=0) if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or PI_I2C_READ_FAILED.</p>
<p><br />
</p>
<p><br />
Block read. SMBus 2.0 5.5.7</p>
<pre><code>S Addr Wr [A] Comm [A]


   S Addr Rd [A] [Count] A [Data] A [Data] A ... A [Data] NA P


</code></pre>
<ul>
<li></li>
<li><p>This writes data bytes to the specified register of the device associated with handle and reads a device specified number of bytes of data in return.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code> handle: &gt;=0, as returned by a call to i2c_open.


i2c_reg: 0-255, the register to write/read.


    buf: an array with the data to send and to receive the read data.


  count: 1-32, the number of bytes to write.


</code></pre>
<p><br />
</p>
<p><br />
</p>
<p><br />
</p>
<p><br />
Returns the number of bytes read (&gt;=0) if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or PI_I2C_READ_FAILED.</p>
<p><br />
</p>
<p><br />
The smbus 2.0 documentation states that a minimum of 1 byte may be sent and a minimum of 1 byte may be received. The total number of bytes sent/received must be 32 or less.</p>
<p><br />
</p>
<p><br />
Block write-block read. SMBus 2.0 5.5.8</p>
<pre><code>S Addr Wr [A] Comm [A] Count [A] Data [A] ...


   S Addr Rd [A] [Count] A [Data] ... A P


</code></pre>
<ul>
<li></li>
<li><p>This reads count bytes from the specified register of the device associated with handle . The count may be 1-32.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code> handle: &gt;=0, as returned by a call to i2c_open.


i2c_reg: 0-255, the register to read.


    buf: an array to receive the read data.


  count: 1-32, the number of bytes to read.


</code></pre>
<p><br />
</p>
<p><br />
Returns the number of bytes read (&gt;0) if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or PI_I2C_READ_FAILED.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>S Addr Wr [A] Comm [A]


   S Addr Rd [A] [Data] A [Data] A ... A [Data] NA P


</code></pre>
<ul>
<li></li>
<li><p>This writes 1 to 32 bytes to the specified register of the device associated with handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code> handle: &gt;=0, as returned by a call to i2c_open.


i2c_reg: 0-255, the register to write.


    buf: the data to write.


  count: 1-32, the number of bytes to write.


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or PI_I2C_WRITE_FAILED.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>S Addr Wr [A] Comm [A] Data [A] Data [A] ... [A] Data [A] P


</code></pre>
<ul>
<li></li>
<li><p>This reads count bytes from the raw device into buf.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to i2c_open.


   buf: an array to receive the read data bytes.


 count: &gt;0, the number of bytes to read.


</code></pre>
<p><br />
</p>
<p><br />
Returns count (&gt;0) if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or PI_I2C_READ_FAILED.</p>
<ul>
<li></li>
<li><p>This writes count bytes from buf to the raw device.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to i2c_open.


   buf: an array containing the data bytes to write.


 count: &gt;0, the number of bytes to write.


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or PI_I2C_WRITE_FAILED.</p>
<ul>
<li></li>
<li><p>This function executes a sequence of I2C operations. The operations to be performed are specified by the contents of inBuf which contains the concatenated command codes and associated data.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to i2cOpen


 inBuf: pointer to the concatenated I2C commands, see below


 inLen: size of command buffer


outBuf: pointer to buffer to hold returned data


outLen: size of output buffer


</code></pre>
<p><br />
</p>
<p><br />
Returns &gt;= 0 if OK (the number of bytes read), otherwise PI_BAD_HANDLE, PI_BAD_POINTER, PI_BAD_I2C_CMD, PI_BAD_I2C_RLEN. PI_BAD_I2C_WLEN, or PI_BAD_I2C_SEG.</p>
<p><br />
</p>
<p><br />
The following command codes are supported:</p>
<p><br />
</p>
<p><br />
Name Cmd &amp; Data Meaning<br />
End 0 No more commands<br />
Escape 1 Next P is two bytes<br />
On 2 Switch combined flag on<br />
Off 3 Switch combined flag off<br />
Address 4 P Set I2C address to P<br />
Flags 5 lsb msb Set I2C flags to lsb + (msb &lt;&lt; 8)<br />
Read 6 P Read P bytes of data<br />
Write 7 P ... Write P bytes of data<br />
</p>
<p><br />
</p>
<p><br />
The address, read, and write commands take a parameter P. Normally P is one byte (0-255). If the command is preceded by the Escape command then P is two bytes (0-65535, least significant byte first).</p>
<p><br />
</p>
<p><br />
The address defaults to that associated with the handle. The flags default to 0. The address and flags maintain their previous value until updated.</p>
<p><br />
</p>
<p><br />
The returned I2C data is stored in consecutive locations of outBuf.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>Set address 0x53, write 0x32, read 6 bytes


Set address 0x1E, write 0x03, read 6 bytes


Set address 0x68, write 0x1B, read 8 bytes


End





0x04 0x53   0x07 0x01 0x32   0x06 0x06


0x04 0x1E   0x07 0x01 0x03   0x06 0x06


0x04 0x68   0x07 0x01 0x1B   0x06 0x08


0x00


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
<li><p>This function selects a pair of GPIO for bit banging I2C at a specified baud rate.</p></li>
</ul>
<p><br />
</p>
<p><br />
Bit banging I2C allows for certain operations which are not possible with the standard I2C driver.</p>
<p><br />
</p>
<p><br />
o baud rates as low as 50<br />
o repeated starts<br />
o clock stretching<br />
o I2C on any pair of spare GPIO</p>
<p><br />
</p>
<p><br />
</p>
<pre><code> SDA: 0-31


 SCL: 0-31


baud: 50-500000


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_USER_GPIO, PI_BAD_I2C_BAUD, or PI_GPIO_IN_USE.</p>
<p><br />
</p>
<p><br />
NOTE:</p>
<p><br />
</p>
<p><br />
The GPIO used for SDA and SCL must have pull-ups to 3V3 connected. As a guide the hardware pull-ups on pins 3 and 5 are 1k8 in value.</p>
<ul>
<li></li>
<li><p>This function stops bit banging I2C on a pair of GPIO previously opened with <strong>bb_i2c_open</strong>.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>SDA: 0-31, the SDA GPIO used in a prior call to bb_i2c_open


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_USER_GPIO, or PI_NOT_I2C_GPIO.</p>
<ul>
<li></li>
<li><p>This function executes a sequence of bit banged I2C operations. The operations to be performed are specified by the contents of inBuf which contains the concatenated command codes and associated data.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>   SDA: 0-31 (as used in a prior call to bb_i2c_open)


 inBuf: pointer to the concatenated I2C commands, see below


 inLen: size of command buffer


outBuf: pointer to buffer to hold returned data


outLen: size of output buffer


</code></pre>
<p><br />
</p>
<p><br />
Returns &gt;= 0 if OK (the number of bytes read), otherwise PI_BAD_USER_GPIO, PI_NOT_I2C_GPIO, PI_BAD_POINTER, PI_BAD_I2C_CMD, PI_BAD_I2C_RLEN, PI_BAD_I2C_WLEN, PI_I2C_READ_FAILED, or PI_I2C_WRITE_FAILED.</p>
<p><br />
</p>
<p><br />
The following command codes are supported:</p>
<p><br />
</p>
<p><br />
Name Cmd &amp; Data Meaning<br />
End 0 No more commands<br />
Escape 1 Next P is two bytes<br />
Start 2 Start condition<br />
Stop 3 Stop condition<br />
Address 4 P Set I2C address to P<br />
Flags 5 lsb msb Set I2C flags to lsb + (msb &lt;&lt; 8)<br />
Read 6 P Read P bytes of data<br />
Write 7 P ... Write P bytes of data<br />
</p>
<p><br />
</p>
<p><br />
The address, read, and write commands take a parameter P. Normally P is one byte (0-255). If the command is preceded by the Escape command then P is two bytes (0-65535, least significant byte first).</p>
<p><br />
</p>
<p><br />
The address and flags default to 0. The address and flags maintain their previous value until updated.</p>
<p><br />
</p>
<p><br />
No flags are currently defined.</p>
<p><br />
</p>
<p><br />
The returned I2C data is stored in consecutive locations of outBuf.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>Set address 0x53


start, write 0x32, (re)start, read 6 bytes, stop


Set address 0x1E


start, write 0x03, (re)start, read 6 bytes, stop


Set address 0x68


start, write 0x1B, (re)start, read 8 bytes, stop


End





0x04 0x53


0x02 0x07 0x01 0x32   0x02 0x06 0x06 0x03





0x04 0x1E


0x02 0x07 0x01 0x03   0x02 0x06 0x06 0x03





0x04 0x68


0x02 0x07 0x01 0x1B   0x02 0x06 0x08 0x03





0x00


</code></pre>
<ul>
<li></li>
<li><p>This function returns a handle for the SPI device on the channel. Data will be transferred at baud bits per second. The flags may be used to modify the default behaviour of 4-wire operation, mode 0, active low chip select.</p></li>
</ul>
<p><br />
</p>
<p><br />
The Pi has two SPI peripherals: main and auxiliary.</p>
<p><br />
</p>
<p><br />
The main SPI has two chip selects (channels), the auxiliary has three.</p>
<p><br />
</p>
<p><br />
The auxiliary SPI is available on all models but the A and B.</p>
<p><br />
</p>
<p><br />
The GPIO used are given in the following table.</p>
<p><br />
</p>
<p><br />
MISO MOSI SCLK CE0 CE1 CE2<br />
Main SPI 9 10 11 8 7 -<br />
Aux SPI 19 20 21 18 17 16<br />
</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>spi_channel: 0-1 (0-2 for the auxiliary SPI).


       baud: 32K-125M (values above 30M are unlikely to work).


  spi_flags: see below.


</code></pre>
<p><br />
</p>
<p><br />
Returns a handle (&gt;=0) if OK, otherwise PI_BAD_SPI_CHANNEL, PI_BAD_SPI_SPEED, PI_BAD_FLAGS, PI_NO_AUX_SPI, or PI_SPI_OPEN_FAILED.</p>
<p><br />
</p>
<p><br />
spi_flags consists of the least significant 22 bits.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0


 b  b  b  b  b  b  R  T  n  n  n  n  W  A u2 u1 u0 p2 p1 p0  m  m


</code></pre>
<p><br />
</p>
<p><br />
mm defines the SPI mode.</p>
<p><br />
</p>
<p><br />
Warning: modes 1 and 3 do not appear to work on the auxiliary SPI.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>Mode POL PHA


 0    0   0


 1    0   1


 2    1   0


 3    1   1


</code></pre>
<p><br />
</p>
<p><br />
px is 0 if CEx is active low (default) and 1 for active high.</p>
<p><br />
</p>
<p><br />
ux is 0 if the CEx GPIO is reserved for SPI (default) and 1 otherwise.</p>
<p><br />
</p>
<p><br />
A is 0 for the main SPI, 1 for the auxiliary SPI.</p>
<p><br />
</p>
<p><br />
W is 0 if the device is not 3-wire, 1 if the device is 3-wire. Main SPI only.</p>
<p><br />
</p>
<p><br />
nnnn defines the number of bytes (0-15) to write before switching the MOSI line to MISO to read data. This field is ignored if W is not set. Main SPI only.</p>
<p><br />
</p>
<p><br />
T is 1 if the least significant bit is transmitted on MOSI first, the default (0) shifts the most significant bit out first. Auxiliary SPI only.</p>
<p><br />
</p>
<p><br />
R is 1 if the least significant bit is received on MISO first, the default (0) receives the most significant bit first. Auxiliary SPI only.</p>
<p><br />
</p>
<p><br />
bbbbbb defines the word size in bits (0-32). The default (0) sets 8 bits per word. Auxiliary SPI only.</p>
<p><br />
</p>
<p><br />
The <strong>spi_read</strong>, <strong>spi_write</strong>, and <strong>spi_xfer</strong> functions transfer data packed into 1, 2, or 4 bytes according to the word size in bits.</p>
<p><br />
</p>
<p><br />
For bits 1-8 there will be one byte per word.<br />
For bits 9-16 there will be two bytes per word.<br />
For bits 17-32 there will be four bytes per word.</p>
<p><br />
</p>
<p><br />
Multi-byte transfers are made in least significant byte first order.</p>
<p><br />
</p>
<p><br />
E.g. to transfer 32 11-bit words buf should contain 64 bytes and count should be 64.</p>
<p><br />
</p>
<p><br />
E.g. to transfer the 14 bit value 0x1ABC send the bytes 0xBC followed by 0x1A.</p>
<p><br />
</p>
<p><br />
The other bits in flags should be set to zero.</p>
<ul>
<li></li>
<li><p>This functions closes the SPI device identified by the handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to spi_open.


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_HANDLE.</p>
<ul>
<li></li>
<li><p>This function reads count bytes of data from the SPI device associated with the handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to spi_open.


   buf: an array to receive the read data bytes.


 count: the number of bytes to read.


</code></pre>
<p><br />
</p>
<p><br />
Returns the number of bytes transferred if OK, otherwise PI_BAD_HANDLE, PI_BAD_SPI_COUNT, or PI_SPI_XFER_FAILED.</p>
<ul>
<li></li>
<li><p>This function writes count bytes of data from buf to the SPI device associated with the handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to spi_open.


   buf: the data bytes to write.


 count: the number of bytes to write.


</code></pre>
<p><br />
</p>
<p><br />
Returns the number of bytes transferred if OK, otherwise PI_BAD_HANDLE, PI_BAD_SPI_COUNT, or PI_SPI_XFER_FAILED.</p>
<ul>
<li></li>
<li><p>This function transfers count bytes of data from txBuf to the SPI device associated with the handle. Simultaneously count bytes of data are read from the device and placed in rxBuf.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to spi_open.


 txBuf: the data bytes to write.


 rxBuf: the received data bytes.


 count: the number of bytes to transfer.


</code></pre>
<p><br />
</p>
<p><br />
Returns the number of bytes transferred if OK, otherwise PI_BAD_HANDLE, PI_BAD_SPI_COUNT, or PI_SPI_XFER_FAILED.</p>
<ul>
<li></li>
<li><p>This function opens a serial device at a specified baud rate with specified flags. The device name must start with /dev/tty or /dev/serial.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>  ser_tty: the serial device to open.


     baud: the baud rate in bits per second, see below.


ser_flags: 0.


</code></pre>
<p><br />
</p>
<p><br />
Returns a handle (&gt;=0) if OK, otherwise PI_NO_HANDLE, or PI_SER_OPEN_FAILED.</p>
<p><br />
</p>
<p><br />
The baud rate must be one of 50, 75, 110, 134, 150, 200, 300, 600, 1200, 1800, 2400, 4800, 9600, 19200, 38400, 57600, 115200, or 230400.</p>
<p><br />
</p>
<p><br />
No flags are currently defined. This parameter should be set to zero.</p>
<ul>
<li></li>
<li><p>This function closes the serial device associated with handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to serial_open.


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_HANDLE.</p>
<ul>
<li></li>
<li><p>This function writes bVal to the serial port associated with handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to serial_open.


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or PI_SER_WRITE_FAILED.</p>
<ul>
<li></li>
<li><p>This function reads a byte from the serial port associated with handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to serial_open.


</code></pre>
<p><br />
</p>
<p><br />
Returns the read byte (&gt;=0) if OK, otherwise PI_BAD_HANDLE, PI_SER_READ_NO_DATA, or PI_SER_READ_FAILED.</p>
<p><br />
</p>
<p><br />
If no data is ready PI_SER_READ_NO_DATA is returned.</p>
<ul>
<li></li>
<li><p>This function writes count bytes from buf to the the serial port associated with handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to serial_open.


   buf: the array of bytes to write.


 count: the number of bytes to write.


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or PI_SER_WRITE_FAILED.</p>
<ul>
<li></li>
<li><p>This function reads up to count bytes from the the serial port associated with handle and writes them to buf.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to serial_open.


   buf: an array to receive the read data.


 count: the maximum number of bytes to read.


</code></pre>
<p><br />
</p>
<p><br />
Returns the number of bytes read (&gt;0) if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, PI_SER_READ_NO_DATA, or PI_SER_WRITE_FAILED.</p>
<p><br />
</p>
<p><br />
If no data is ready zero is returned.</p>
<ul>
<li></li>
<li><p>Returns the number of bytes available to be read from the device associated with handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to serial_open.


</code></pre>
<p><br />
</p>
<p><br />
Returns the number of bytes of data available (&gt;=0) if OK, otherwise PI_BAD_HANDLE.</p>
<ul>
<li></li>
<li><p>This function is available for user customisation.</p></li>
</ul>
<p><br />
</p>
<p><br />
It returns a single integer value.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>arg1: &gt;=0


arg2: &gt;=0


argx: extra (byte) arguments


argc: number of extra arguments


</code></pre>
<p><br />
</p>
<p><br />
Returns &gt;= 0 if OK, less than 0 indicates a user defined error.</p>
<ul>
<li></li>
<li><p>This function is available for user customisation.</p></li>
</ul>
<p><br />
</p>
<p><br />
It differs from custom_1 in that it returns an array of bytes rather than just an integer.</p>
<p><br />
</p>
<p><br />
The return value is an integer indicating the number of returned bytes.</p>
<pre><code>  arg1: &gt;=0


  argc: extra (byte) arguments


 count: number of extra arguments


retBuf: buffer for returned data


retMax: maximum number of bytes to return


</code></pre>
<p><br />
</p>
<p><br />
Returns &gt;= 0 if OK, less than 0 indicates a user defined error.</p>
<p><br />
</p>
<p><br />
Note, the number of returned bytes will be retMax or less.</p>
<ul>
<li></li>
<li><p>This function initialises a new callback.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_gpio: 0-31.


     edge: RISING_EDGE, FALLING_EDGE, or EITHER_EDGE.


        f: the callback function.


</code></pre>
<p><br />
</p>
<p><br />
The function returns a callback id if OK, otherwise pigif_bad_malloc, pigif_duplicate_callback, or pigif_bad_callback.</p>
<p><br />
</p>
<p><br />
The callback is called with the GPIO, edge, and tick, whenever the GPIO has the identified edge.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>Parameter   Value    Meaning





GPIO        0-31     The GPIO which has changed state





edge        0-2      0 = change to low (a falling edge)


                     1 = change to high (a rising edge)


                     2 = no level change (a watchdog timeout)





tick        32 bit   The number of microseconds since boot


                     WARNING: this wraps around from


                     4294967295 to 0 roughly every 72 minutes


</code></pre>
<ul>
<li></li>
<li><p>This function initialises a new callback.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_gpio: 0-31.


     edge: RISING_EDGE, FALLING_EDGE, or EITHER_EDGE.


        f: the callback function.


 userdata: a pointer to arbitrary user data.


</code></pre>
<p><br />
</p>
<p><br />
The function returns a callback id if OK, otherwise pigif_bad_malloc, pigif_duplicate_callback, or pigif_bad_callback.</p>
<p><br />
</p>
<p><br />
The callback is called with the GPIO, edge, tick, and user, whenever the GPIO has the identified edge.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>Parameter   Value    Meaning





GPIO        0-31     The GPIO which has changed state





edge        0-2      0 = change to low (a falling edge)


                     1 = change to high (a rising edge)


                     2 = no level change (a watchdog timeout)





tick        32 bit   The number of microseconds since boot


                     WARNING: this wraps around from


                     4294967295 to 0 roughly every 72 minutes





userdata    pointer  Pointer to an arbitrary object


</code></pre>
<ul>
<li></li>
<li><p>This function cancels a callback identified by its id.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>callback_id: &gt;=0, as returned by a call to callback or callback_ex.


</code></pre>
<p><br />
</p>
<p><br />
The function returns 0 if OK, otherwise pigif_callback_not_found.</p>
<ul>
<li></li>
<li><p>This function waits for edge on the GPIO for up to timeout seconds.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_gpio: 0-31.


     edge: RISING_EDGE, FALLING_EDGE, or EITHER_EDGE.


  timeout: &gt;=0.


</code></pre>
<p><br />
</p>
<p><br />
The function returns 1 if the edge occurred, otherwise 0.</p>
<p><br />
</p>
<p><br />
The function returns when the edge occurs or after the timeout.</p>
<h1>PARAMETERS</h1>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
The number of microseconds level changes are reported for once a noise filter has been triggered (by <strong>steady</strong> microseconds of a stable level).</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A string specifying the host or IP address of the Pi running the pigpio daemon. It may be NULL in which case localhost is used unless overridden by the PIGPIO_ADDR environment variable.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>An unsigned argument passed to a user customised function. Its meaning is defined by the customiser.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>An unsigned argument passed to a user customised function. Its meaning is defined by the customiser.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The count of bytes passed to a user customised function.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A pointer to an array of bytes passed to a user customised function. Its meaning and content is defined by the customiser.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The speed of serial communication (I2C, SPI, serial link, waves) in bits per second.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A value of 0 or 1.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A value used to select GPIO. If bit n of bits is set then GPIO n is selected.</p></li>
</ul>
<p><br />
</p>
<p><br />
A convenient way to set bit n is to or in (1&lt;&lt;n).</p>
<p><br />
</p>
<p><br />
e.g. to select bits 5, 9, 23 you could use (1&lt;&lt;5) | (1&lt;&lt;9) | (1&lt;&lt;23).</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A buffer to hold data being sent or being received.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The size in bytes of a buffer.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>An 8-bit byte value.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A &gt;=0, as returned by a call to <strong>callback</strong> or <strong>callback_ex</strong>. This is passed to <strong>callback_cancel</strong> to cancel the callback.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<pre><code>typedef void (*CBFunc_t)


   (unsigned user_gpio, unsigned level, uint32_t tick);


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<pre><code>typedef void (*CBFuncEx_t)


   (unsigned user_gpio, unsigned level, uint32_t tick, void * user);


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A single character, an 8 bit quantity able to store 0-255.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The hardware clock frequency.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The number of bytes to be transferred in an I2C, SPI, or Serial command.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The number of data bits in each character of serial data.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>#define PI_MIN_WAVE_DATABITS 1


#define PI_MAX_WAVE_DATABITS 32


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A floating point number.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A number representing the ratio of on time to off time for PWM.</p></li>
</ul>
<p><br />
</p>
<p><br />
The number may vary between 0 and range (default 255) where 0 is off and range is fully on.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>Used to identify a GPIO level transition of interest. A rising edge is a level change from 0 to 1. A falling edge is a level change from 1 to 0.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>RISING_EDGE  0


FALLING_EDGE 1


EITHER_EDGE. 2


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A negative number indicating a function call failed and the nature of the error.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ol start="6" type="a">
<li><p>A function.</p></li>
</ol>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The number of times a GPIO is swiched on and off per second. This can be set per GPIO and may be as little as 5Hz or as much as 40KHz. The GPIO will be on for a proportion of the time as defined by its dutycycle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A Broadcom numbered GPIO, in the range 0-53.</p></li>
</ul>
<p><br />
</p>
<p><br />
There are 54 General Purpose Input Outputs (GPIO) named gpio0 through gpio53.</p>
<p><br />
</p>
<p><br />
They are split into two banks. Bank 1 consists of gpio0 through gpio31. Bank 2 consists of gpio32 through gpio53.</p>
<p><br />
</p>
<p><br />
All the GPIO which are safe for the user to read and write are in bank 1. Not all GPIO in bank 1 are safe though. Type 1 boards have 17 safe GPIO. Type 2 boards have 21. Type 3 boards have 26.</p>
<p><br />
</p>
<p><br />
See <strong>get_hardware_revision</strong>.</p>
<p><br />
</p>
<p><br />
The user GPIO are marked with an X in the following table.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>          0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15


Type 1    X  X  -  -  X  -  -  X  X  X  X  X  -  -  X  X


Type 2    -  -  X  X  X  -  -  X  X  X  X  X  -  -  X  X


Type 3          X  X  X  X  X  X  X  X  X  X  X  X  X  X





         16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31


Type 1    -  X  X  -  -  X  X  X  X  X  -  -  -  -  -  -


Type 2    -  X  X  -  -  -  X  X  X  X  -  X  X  X  X  X


Type 3    X  X  X  X  X  X  X  X  X  X  X  X  -  -  -  -


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<pre><code>typedef struct


{


uint32_t gpioOn;


uint32_t gpioOff;


uint32_t usDelay;


} gpioPulse_t;


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<pre><code>typedef void *(gpioThreadFunc_t) (void *);


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A number referencing an object opened by one of <strong>i2c_open</strong>, <strong>notify_open</strong>, <strong>serial_open</strong>, and <strong>spi_open</strong>.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The address of a device on the I2C bus.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>An I2C bus number.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>Flags which modify an I2C open command. None are currently defined.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A register of an I2C device.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A buffer used to pass data to a function.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The number of bytes of data in a buffer.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A whole number, negative or positive.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A flag used to set normal or inverted bit bang serial data level logic.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The level of a GPIO. Low or High.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>PI_OFF 0


PI_ON 1





PI_CLEAR 0


PI_SET 1





PI_LOW 0


PI_HIGH 1


</code></pre>
<p><br />
</p>
<p><br />
There is one exception. If a watchdog expires on a GPIO the level will be reported as PI_TIMEOUT. See <strong>set_watchdog</strong>.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>PI_TIMEOUT 2


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The operational mode of a GPIO, normally INPUT or OUTPUT.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>PI_INPUT 0


PI_OUTPUT 1


PI_ALT0 4


PI_ALT1 5


PI_ALT2 6


PI_ALT3 7


PI_ALT4 3


PI_ALT5 2


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The number of bytes used to store characters in a string. Depending on the number of bits per character there may be 1, 2, or 4 bytes per character.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The number of parameters passed to a script.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The number of pulses to be added to a waveform.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The associated data starts this number of microseconds from the start of the waveform.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A buffer used to return data from a function.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The size in bytes of an output buffer.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>An array of script parameters.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A string specifying the port address used by the Pi running the pigpio daemon. It may be NULL in which case "8888" is used unless overridden by the PIGPIO_PORT environment variable.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A thread identifier, returned by <strong>start_thread</strong>.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A thread identifier.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The setting of the pull up/down resistor for a GPIO, which may be off, pull-up, or pull-down.</p></li>
</ul>
<pre><code>PI_PUD_OFF 0


PI_PUD_DOWN 1


PI_PUD_UP 2


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>1-100, the length of a trigger pulse in microseconds.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>An array of pulses to be added to a waveform.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<pre><code>PI_SERVO_OFF 0


PI_MIN_SERVO_PULSEWIDTH 500


PI_MAX_SERVO_PULSEWIDTH 2500


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The hardware PWM dutycycle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>#define PI_HW_PWM_RANGE 1000000


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The hardware PWM frequency.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>#define PI_HW_PWM_MIN_FREQ 1


#define PI_HW_PWM_MAX_FREQ 125000000


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The permissible dutycycle values are 0-range.</p></li>
</ul>
<pre><code>PI_MIN_DUTYCYCLE_RANGE 25


PI_MAX_DUTYCYCLE_RANGE 40000


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A buffer to hold a number of bytes returned to a used customised function,</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The maximum number of bytes a user customised function should return.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A pointer to a buffer to receive data.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The user GPIO to use for the clock when bit banging I2C.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A pointer to the text of a script.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>An id of a stored script as returned by <strong>store_script</strong>.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The user GPIO to use for data when bit banging I2C.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The number of seconds.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>Flags which modify a serial open command. None are currently defined.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The name of a serial tty device, e.g. /dev/ttyAMA0, /dev/ttyUSB0, /dev/tty1.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A standard type used to indicate the size of an object in bytes.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A SPI channel, 0-2.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>See <strong>spi_open</strong>.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
The number of microseconds level changes must be stable for before reporting the level changed (<strong>set_glitch_filter</strong>) or triggering the active part of a noise filter (<strong>set_noise_filter</strong>).</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The number of (half) stop bits to be used when adding serial data to a waveform.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>#define PI_MIN_WAVE_HALFSTOPBITS 2


#define PI_MAX_WAVE_HALFSTOPBITS 8


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p> An array of characters.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A function of type gpioThreadFunc_t used as the main function of a thread.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A GPIO watchdog timeout in milliseconds.</p></li>
</ul>
<pre><code>PI_MIN_WDOG_TIMEOUT 0


PI_MAX_WDOG_TIMEOUT 60000


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>An array of bytes to transmit.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A 32-bit unsigned value.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A whole number &gt;= 0.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>0-31, a Broadcom numbered GPIO.</p></li>
</ul>
<p><br />
</p>
<p><br />
See <strong>gpio</strong>.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A pointer to arbitrary user data. This may be used to identify the instance.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>Denoting no parameter is required</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>One of <strong>wave_add_new</strong>, <strong>wave_add_generic</strong>, <strong>wave_add_serial</strong>.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A number representing a waveform created by <strong>wave_create</strong>.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>One of <strong>wave_send_once</strong>, <strong>wave_send_repeat</strong>.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A 16-bit word value.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<h1>pigpiod_if Error Codes</h1>
<pre><code>


typedef enum


{


   pigif_bad_send           = -2000,


   pigif_bad_recv           = -2001,


   pigif_bad_getaddrinfo    = -2002,


   pigif_bad_connect        = -2003,


   pigif_bad_socket         = -2004,


   pigif_bad_noib           = -2005,


   pigif_duplicate_callback = -2006,


   pigif_bad_malloc         = -2007,


   pigif_bad_callback       = -2008,


   pigif_notify_failed      = -2009,


   pigif_callback_not_found = -2010,


} pigifError_t;





</code></pre>
<h1>SEE ALSO</h1>
<p>pigpiod(1), pig2vcd(1), pigs(1), pigpio(3), pigpiod_if2(3)</p>
<h1>AUTHOR</h1>
<p>joan@abyz.me.uk</p>
<footer style="text-align: center;"><a href="https://blog.tamer.pw" target="_blank">Blog</a> | <a href="https://github.com/linuxtamer" target="_blank">Contact</a></footer>
</div>
</body>
</html>

