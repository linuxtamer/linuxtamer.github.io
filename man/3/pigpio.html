<!DOCTYPE html>
<html lang=en-US>
<head>
<meta charset=utf-8>
<title>Linux command pigpio</title><meta name="description" content="Linux command pigpio A C library to manipulate the Pi's GPIO."><meta name="keywords" content="linux, command, pigpio, bsd, A C library to manipulate the Pi's GPIO."><meta name="robots" content="index,follow">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="container">

<h1>NAME</h1>
<p>pigpio - A C library to manipulate the Pi's GPIO.</p>
<h1>SYNOPSIS</h1>
<p>#include &lt;pigpio.h&gt;</p>
<p>gcc -Wall -pthread -o prog prog.c -lpigpio -lrt</p>
<p>sudo ./prog</p>
<h1>DESCRIPTION</h1>
<p><br />
</p>
<p><br />
pigpio is a C library for the Raspberry which allows control of the GPIO.</p>
<p><br />
</p>
<p><br />
</p>
<h2>Features</h2>
<p><br />
</p>
<p><br />
o hardware timed PWM on any of GPIO 0-31</p>
<p><br />
</p>
<p><br />
o hardware timed servo pulses on any of GPIO 0-31</p>
<p><br />
</p>
<p><br />
o callbacks when any of GPIO 0-31 change state</p>
<p><br />
</p>
<p><br />
o callbacks at timed intervals</p>
<p><br />
</p>
<p><br />
o reading/writing all of the GPIO in a bank as one operation</p>
<p><br />
</p>
<p><br />
o individually setting GPIO modes, reading and writing</p>
<p><br />
</p>
<p><br />
o notifications when any of GPIO 0-31 change state</p>
<p><br />
</p>
<p><br />
o the construction of output waveforms with microsecond timing</p>
<p><br />
</p>
<p><br />
o rudimentary permission control over GPIO</p>
<p><br />
</p>
<p><br />
o a simple interface to start and stop new threads</p>
<p><br />
</p>
<p><br />
o I2C, SPI, and serial link wrappers</p>
<p><br />
</p>
<p><br />
o creating and running scripts</p>
<p><br />
</p>
<p><br />
</p>
<h2>GPIO</h2>
<p><br />
</p>
<p><br />
ALL GPIO are identified by their Broadcom number.</p>
<p><br />
</p>
<p><br />
</p>
<h2>Credits</h2>
<p><br />
</p>
<p><br />
The PWM and servo pulses are timed using the DMA and PWM peripherals.</p>
<p><br />
</p>
<p><br />
This use was inspired by Richard Hirst's servoblaster kernel module.</p>
<p><br />
</p>
<p><br />
</p>
<h2>Usage</h2>
<p><br />
</p>
<p><br />
Include &lt;pigpio.h&gt; in your source files.</p>
<p><br />
</p>
<p><br />
Assuming your source is in prog.c use the following command to build and run the executable.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>gcc -Wall -pthread -o prog prog.c -lpigpio -lrt


sudo ./prog


</code></pre>
<p><br />
</p>
<p><br />
For examples of usage see the C programs within the pigpio archive file.</p>
<p><br />
</p>
<p><br />
</p>
<h2>Notes</h2>
<p><br />
</p>
<p><br />
All the functions which return an int return &lt; 0 on error.</p>
<p><br />
</p>
<p><br />
<strong>gpioInitialise</strong> must be called before all other library functions with the following exceptions:</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>gpioCfg*


gpioVersion


gpioHardwareRevision


</code></pre>
<p><br />
</p>
<p><br />
If the library is not initialised all but the <strong>gpioCfg*</strong>, <strong>gpioVersion</strong>, and <strong>gpioHardwareRevision</strong> functions will return error PI_NOT_INITIALISED.</p>
<p><br />
</p>
<p><br />
If the library is initialised the <strong>gpioCfg*</strong> functions will return error PI_INITIALISED.</p>
<p><br />
</p>
<p><br />
If you intend to rely on signals sent to your application, you should turn off the internal signal handling as shown in this example:</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>int cfg = gpioCfgGetInternals();


cfg |= PI_CFG_NOSIGHANDLER;  // (1&lt;&lt;10)


gpioCfgSetInternals(cfg);


int status = gpioInitialise();


</code></pre>
<p><br />
</p>
<p><br />
</p>
<h1>OVERVIEW</h1>
<p><br />
</p>
<h2>ESSENTIAL</h2>
<p><br />
</p>
<p><br />
gpioInitialise Initialise library<br />
gpioTerminate Stop library<br />
</p>
<h2>BASIC</h2>
<p><br />
</p>
<p><br />
gpioSetMode Set a GPIO mode<br />
gpioGetMode Get a GPIO mode<br />
</p>
<p><br />
gpioSetPullUpDown Set/clear GPIO pull up/down resistor<br />
</p>
<p><br />
gpioRead Read a GPIO<br />
gpioWrite Write a GPIO<br />
</p>
<h2>PWM (overrides servo commands on same GPIO)</h2>
<p><br />
</p>
<p><br />
gpioPWM Start/stop PWM pulses on a GPIO<br />
gpioSetPWMfrequency Configure PWM frequency for a GPIO<br />
gpioSetPWMrange Configure PWM range for a GPIO<br />
</p>
<p><br />
gpioGetPWMdutycycle Get dutycycle setting on a GPIO<br />
gpioGetPWMfrequency Get configured PWM frequency for a GPIO<br />
gpioGetPWMrange Get configured PWM range for a GPIO<br />
</p>
<p><br />
gpioGetPWMrealRange Get underlying PWM range for a GPIO<br />
</p>
<h2>Servo (overrides PWM commands on same GPIO)</h2>
<p><br />
</p>
<p><br />
gpioServo Start/stop servo pulses on a GPIO<br />
</p>
<p><br />
gpioGetServoPulsewidth Get pulsewidth setting on a GPIO<br />
</p>
<h2>INTERMEDIATE</h2>
<p><br />
</p>
<p><br />
gpioTrigger Send a trigger pulse to a GPIO<br />
</p>
<p><br />
gpioSetWatchdog Set a watchdog on a GPIO<br />
</p>
<p><br />
gpioRead_Bits_0_31 Read all GPIO in bank 1<br />
gpioRead_Bits_32_53 Read all GPIO in bank 2<br />
</p>
<p><br />
gpioWrite_Bits_0_31_Clear Clear selected GPIO in bank 1<br />
gpioWrite_Bits_32_53_Clear Clear selected GPIO in bank 2<br />
</p>
<p><br />
gpioWrite_Bits_0_31_Set Set selected GPIO in bank 1<br />
gpioWrite_Bits_32_53_Set Set selected GPIO in bank 2<br />
</p>
<p><br />
gpioSetAlertFunc Request a GPIO level change callback<br />
gpioSetAlertFuncEx Request a GPIO change callback, extended<br />
</p>
<p><br />
gpioSetTimerFunc Request a regular timed callback<br />
gpioSetTimerFuncEx Request a regular timed callback, extended<br />
</p>
<p><br />
gpioStartThread Start a new thread<br />
gpioStopThread Stop a previously started thread<br />
</p>
<h2>ADVANCED</h2>
<p><br />
</p>
<p><br />
gpioNotifyOpen Request a notification handle<br />
gpioNotifyClose Close a notification<br />
gpioNotifyOpenWithSize Request a notification with sized pipe<br />
gpioNotifyBegin Start notifications for selected GPIO<br />
gpioNotifyPause Pause notifications<br />
</p>
<p><br />
gpioHardwareClock Start hardware clock on supported GPIO<br />
</p>
<p><br />
gpioHardwarePWM Start hardware PWM on supported GPIO<br />
</p>
<p><br />
gpioGlitchFilter Set a glitch filter on a GPIO<br />
gpioNoiseFilter Set a noise filter on a GPIO<br />
</p>
<p><br />
gpioSetPad Sets a pads drive strength<br />
gpioGetPad Gets a pads drive strength<br />
</p>
<p><br />
shell Executes a shell command<br />
</p>
<p><br />
gpioSetISRFunc Request a GPIO interrupt callback<br />
gpioSetISRFuncEx Request a GPIO interrupt callback, extended<br />
</p>
<p><br />
gpioSetSignalFunc Request a signal callback<br />
gpioSetSignalFuncEx Request a signal callback, extended<br />
</p>
<p><br />
gpioSetGetSamplesFunc Requests a GPIO samples callback<br />
gpioSetGetSamplesFuncEx Requests a GPIO samples callback, extended<br />
</p>
<h2>Custom</h2>
<p><br />
</p>
<p><br />
gpioCustom1 User custom function 1<br />
gpioCustom2 User custom function 2<br />
</p>
<h2>Events</h2>
<p><br />
</p>
<p><br />
eventMonitor Sets the events to monitor<br />
eventSetFunc Request an event callback<br />
eventSetFuncEx Request an event callback, extended<br />
</p>
<p><br />
eventTrigger Trigger an event<br />
</p>
<h2>Scripts</h2>
<p><br />
</p>
<p><br />
gpioStoreScript Store a script<br />
gpioRunScript Run a stored script<br />
gpioUpdateScript Set a scripts parameters<br />
gpioScriptStatus Get script status and parameters<br />
gpioStopScript Stop a running script<br />
gpioDeleteScript Delete a stored script<br />
</p>
<h2>I2C</h2>
<p><br />
</p>
<p><br />
i2cOpen Opens an I2C device<br />
i2cClose Closes an I2C device<br />
</p>
<p><br />
i2cWriteQuick SMBus write quick<br />
</p>
<p><br />
i2cReadByte SMBus read byte<br />
i2cWriteByte SMBus write byte<br />
</p>
<p><br />
i2cReadByteData SMBus read byte data<br />
i2cWriteByteData SMBus write byte data<br />
</p>
<p><br />
i2cReadWordData SMBus read word data<br />
i2cWriteWordData SMBus write word data<br />
</p>
<p><br />
i2cReadBlockData SMBus read block data<br />
i2cWriteBlockData SMBus write block data<br />
</p>
<p><br />
i2cReadI2CBlockData SMBus read I2C block data<br />
i2cWriteI2CBlockData SMBus write I2C block data<br />
</p>
<p><br />
i2cReadDevice Reads the raw I2C device<br />
i2cWriteDevice Writes the raw I2C device<br />
</p>
<p><br />
i2cProcessCall SMBus process call<br />
i2cBlockProcessCall SMBus block process call<br />
</p>
<p><br />
i2cSwitchCombined Sets or clears the combined flag<br />
</p>
<p><br />
i2cSegments Performs multiple I2C transactions<br />
</p>
<p><br />
i2cZip Performs multiple I2C transactions<br />
</p>
<h2>I2C BIT BANG</h2>
<p><br />
</p>
<p><br />
bbI2COpen Opens GPIO for bit banging I2C<br />
bbI2CClose Closes GPIO for bit banging I2C<br />
</p>
<p><br />
bbI2CZip Performs bit banged I2C transactions<br />
</p>
<h2>I2C/SPI SLAVE</h2>
<p><br />
</p>
<p><br />
bscXfer I2C/SPI as slave transfer<br />
</p>
<h2>SERIAL</h2>
<p><br />
</p>
<p><br />
serOpen Opens a serial device<br />
serClose Closes a serial device<br />
</p>
<p><br />
serReadByte Reads a byte from a serial device<br />
serWriteByte Writes a byte to a serial device<br />
</p>
<p><br />
serRead Reads bytes from a serial device<br />
serWrite Writes bytes to a serial device<br />
</p>
<p><br />
serDataAvailable Returns number of bytes ready to be read<br />
</p>
<h2>SERIAL BIT BANG (read only)</h2>
<p><br />
</p>
<p><br />
gpioSerialReadOpen Opens a GPIO for bit bang serial reads<br />
gpioSerialReadClose Closes a GPIO for bit bang serial reads<br />
</p>
<p><br />
gpioSerialReadInvert Configures normal/inverted for serial reads<br />
</p>
<p><br />
gpioSerialRead Reads bit bang serial data from a GPIO<br />
</p>
<h2>SPI</h2>
<p><br />
</p>
<p><br />
spiOpen Opens a SPI device<br />
spiClose Closes a SPI device<br />
</p>
<p><br />
spiRead Reads bytes from a SPI device<br />
spiWrite Writes bytes to a SPI device<br />
spiXfer Transfers bytes with a SPI device<br />
</p>
<h2>SPI BIT BANG</h2>
<p><br />
</p>
<p><br />
bbSPIOpen Opens GPIO for bit banging SPI<br />
bbSPIClose Closes GPIO for bit banging SPI<br />
</p>
<p><br />
bbSPIXfer Performs bit banged SPI transactions<br />
</p>
<h2>FILES</h2>
<p><br />
</p>
<p><br />
fileOpen Opens a file<br />
fileClose Closes a file<br />
</p>
<p><br />
fileRead Reads bytes from a file<br />
fileWrite Writes bytes to a file<br />
</p>
<p><br />
fileSeek Seeks to a position within a file<br />
</p>
<p><br />
fileList List files which match a pattern<br />
</p>
<h2>WAVES</h2>
<p><br />
</p>
<p><br />
gpioWaveClear Deletes all waveforms<br />
</p>
<p><br />
gpioWaveAddNew Starts a new waveform<br />
gpioWaveAddGeneric Adds a series of pulses to the waveform<br />
gpioWaveAddSerial Adds serial data to the waveform<br />
</p>
<p><br />
gpioWaveCreate Creates a waveform from added data<br />
gpioWaveCreatePad Creates a waveform of fixed size from added data<br />
gpioWaveDelete Deletes a waveform<br />
</p>
<p><br />
gpioWaveTxSend Transmits a waveform<br />
</p>
<p><br />
gpioWaveChain Transmits a chain of waveforms<br />
</p>
<p><br />
gpioWaveTxAt Returns the current transmitting waveform<br />
</p>
<p><br />
gpioWaveTxBusy Checks to see if the waveform has ended<br />
</p>
<p><br />
gpioWaveTxStop Aborts the current waveform<br />
</p>
<p><br />
gpioWaveGetCbs Length in CBs of the current waveform<br />
gpioWaveGetHighCbs Length of longest waveform so far<br />
gpioWaveGetMaxCbs Absolute maximum allowed CBs<br />
</p>
<p><br />
gpioWaveGetMicros Length in micros of the current waveform<br />
gpioWaveGetHighMicros Length of longest waveform so far<br />
gpioWaveGetMaxMicros Absolute maximum allowed micros<br />
</p>
<p><br />
gpioWaveGetPulses Length in pulses of the current waveform<br />
gpioWaveGetHighPulses Length of longest waveform so far<br />
gpioWaveGetMaxPulses Absolute maximum allowed pulses<br />
</p>
<h2>UTILITIES</h2>
<p><br />
</p>
<p><br />
gpioDelay Delay for a number of microseconds<br />
</p>
<p><br />
gpioTick Get current tick (microseconds)<br />
</p>
<p><br />
gpioHardwareRevision Get hardware revision<br />
gpioVersion Get the pigpio version<br />
</p>
<p><br />
getBitInBytes Get the value of a bit<br />
putBitInBytes Set the value of a bit<br />
</p>
<p><br />
gpioTime Get current time<br />
gpioSleep Sleep for specified time<br />
</p>
<p><br />
time_sleep Sleeps for a float number of seconds<br />
time_time Float number of seconds since the epoch<br />
</p>
<h2>CONFIGURATION</h2>
<p><br />
</p>
<p><br />
gpioCfgBufferSize Configure the GPIO sample buffer size<br />
gpioCfgClock Configure the GPIO sample rate<br />
gpioCfgDMAchannel Configure the DMA channel (DEPRECATED)<br />
gpioCfgDMAchannels Configure the DMA channels<br />
gpioCfgPermissions Configure the GPIO access permissions<br />
gpioCfgInterfaces Configure user interfaces<br />
gpioCfgSocketPort Configure socket port<br />
gpioCfgMemAlloc Configure DMA memory allocation mode<br />
gpioCfgNetAddr Configure allowed network addresses<br />
</p>
<p><br />
gpioCfgGetInternals Get internal configuration settings<br />
gpioCfgSetInternals Set internal configuration settings<br />
</p>
<h2>EXPERT</h2>
<p><br />
</p>
<p><br />
rawWaveAddSPI Not intended for general use<br />
rawWaveAddGeneric Not intended for general use<br />
rawWaveCB Not intended for general use<br />
rawWaveCBAdr Not intended for general use<br />
rawWaveGetOOL Not intended for general use<br />
rawWaveSetOOL Not intended for general use<br />
rawWaveGetOut Not intended for general use<br />
rawWaveSetOut Not intended for general use<br />
rawWaveGetIn Not intended for general use<br />
rawWaveSetIn Not intended for general use<br />
rawWaveInfo Not intended for general use<br />
rawDumpWave Not intended for general use<br />
rawDumpScript Not intended for general use<br />
</p>
<h1>FUNCTIONS</h1>
<ul>
<li></li>
<li><p>Initialises the library.</p></li>
</ul>
<p><br />
</p>
<p><br />
Returns the pigpio version number if OK, otherwise PI_INIT_FAILED.</p>
<p><br />
</p>
<p><br />
gpioInitialise must be called before using the other library functions with the following exceptions:</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>gpioCfg*


gpioVersion


gpioHardwareRevision


</code></pre>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>if (gpioInitialise() &lt; 0)


{


   // pigpio initialisation failed.


}


else


{


   // pigpio initialised okay.


}


</code></pre>
<ul>
<li></li>
<li><p>Terminates the library.</p></li>
</ul>
<p><br />
</p>
<p><br />
Returns nothing.</p>
<p><br />
</p>
<p><br />
Call before program exit.</p>
<p><br />
</p>
<p><br />
This function resets the used DMA channels, releases memory, and terminates any running threads.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>gpioTerminate();


</code></pre>
<ul>
<li></li>
<li><p>Sets the GPIO mode, typically input or output.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>gpio: 0-53


mode: 0-7


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_GPIO or PI_BAD_MODE.</p>
<p><br />
</p>
<p><br />
Arduino style: pinMode.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>gpioSetMode(17, PI_INPUT);  // Set GPIO17 as input.





gpioSetMode(18, PI_OUTPUT); // Set GPIO18 as output.





gpioSetMode(22,PI_ALT0);    // Set GPIO22 to alternative mode 0.


</code></pre>
<p><br />
</p>
<p><br />
See <strong>http://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2835/BCM2835-ARM-Peripherals.pdf</strong> page 102 for an overview of the modes.</p>
<ul>
<li></li>
<li><p>Gets the GPIO mode.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>gpio: 0-53


</code></pre>
<p><br />
</p>
<p><br />
Returns the GPIO mode if OK, otherwise PI_BAD_GPIO.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>if (gpioGetMode(17) != PI_ALT0)


{


   gpioSetMode(17, PI_ALT0);  // set GPIO17 to ALT0


}


</code></pre>
<ul>
<li></li>
<li><p>Sets or clears resistor pull ups or downs on the GPIO.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>gpio: 0-53


 pud: 0-2


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_GPIO or PI_BAD_PUD.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>gpioSetPullUpDown(17, PI_PUD_UP);   // Sets a pull-up.





gpioSetPullUpDown(18, PI_PUD_DOWN); // Sets a pull-down.





gpioSetPullUpDown(23, PI_PUD_OFF);  // Clear any pull-ups/downs.


</code></pre>
<ul>
<li></li>
<li><p>Reads the GPIO level, on or off.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>gpio: 0-53


</code></pre>
<p><br />
</p>
<p><br />
Returns the GPIO level if OK, otherwise PI_BAD_GPIO.</p>
<p><br />
</p>
<p><br />
Arduino style: digitalRead.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>printf(&quot;GPIO24 is level %d&quot;, gpioRead(24));


</code></pre>
<ul>
<li></li>
<li><p>Sets the GPIO level, on or off.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code> gpio: 0-53


level: 0-1


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_GPIO or PI_BAD_LEVEL.</p>
<p><br />
</p>
<p><br />
If PWM or servo pulses are active on the GPIO they are switched off.</p>
<p><br />
</p>
<p><br />
Arduino style: digitalWrite</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>gpioWrite(24, 1); // Set GPIO24 high.


</code></pre>
<ul>
<li></li>
<li><p>Starts PWM on the GPIO, dutycycle between 0 (off) and range (fully on). Range defaults to 255.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_gpio: 0-31


dutycycle: 0-range


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_USER_GPIO or PI_BAD_DUTYCYCLE.</p>
<p><br />
</p>
<p><br />
Arduino style: analogWrite</p>
<p><br />
</p>
<p><br />
This and the servo functionality use the DMA and PWM or PCM peripherals to control and schedule the pulse lengths and dutycycles.</p>
<p><br />
</p>
<p><br />
The <strong>gpioSetPWMrange</strong> function may be used to change the default range of 255.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>gpioPWM(17, 255); // Sets GPIO17 full on.





gpioPWM(18, 128); // Sets GPIO18 half on.





gpioPWM(23, 0);   // Sets GPIO23 full off.


</code></pre>
<ul>
<li></li>
<li><p>Returns the PWM dutycycle setting for the GPIO.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_gpio: 0-31


</code></pre>
<p><br />
</p>
<p><br />
Returns between 0 (off) and range (fully on) if OK, otherwise PI_BAD_USER_GPIO or PI_NOT_PWM_GPIO.</p>
<p><br />
</p>
<p><br />
For normal PWM the dutycycle will be out of the defined range for the GPIO (see <strong>gpioGetPWMrange</strong>).</p>
<p><br />
</p>
<p><br />
If a hardware clock is active on the GPIO the reported dutycycle will be 500000 (500k) out of 1000000 (1M).</p>
<p><br />
</p>
<p><br />
If hardware PWM is active on the GPIO the reported dutycycle will be out of a 1000000 (1M).</p>
<p><br />
</p>
<p><br />
Normal PWM range defaults to 255.</p>
<ul>
<li></li>
<li><p>Selects the dutycycle range to be used for the GPIO. Subsequent calls to gpioPWM will use a dutycycle between 0 (off) and range (fully on).</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_gpio: 0-31


    range: 25-40000


</code></pre>
<p><br />
</p>
<p><br />
Returns the real range for the given GPIO's frequency if OK, otherwise PI_BAD_USER_GPIO or PI_BAD_DUTYRANGE.</p>
<p><br />
</p>
<p><br />
If PWM is currently active on the GPIO its dutycycle will be scaled to reflect the new range.</p>
<p><br />
</p>
<p><br />
The real range, the number of steps between fully off and fully on for each frequency, is given in the following table.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>  25,   50,  100,  125,  200,  250,  400,   500,   625,


 800, 1000, 1250, 2000, 2500, 4000, 5000, 10000, 20000


</code></pre>
<p><br />
</p>
<p><br />
The real value set by <strong>gpioPWM</strong> is (dutycycle * real range) / range.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>gpioSetPWMrange(24, 2000); // Now 2000 is fully on


                           //     1000 is half on


                           //      500 is quarter on, etc.


</code></pre>
<ul>
<li></li>
<li><p>Returns the dutycycle range used for the GPIO if OK, otherwise PI_BAD_USER_GPIO.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_gpio: 0-31


</code></pre>
<p><br />
</p>
<p><br />
If a hardware clock or hardware PWM is active on the GPIO the reported range will be 1000000 (1M).</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>r = gpioGetPWMrange(23);


</code></pre>
<ul>
<li></li>
<li><p>Returns the real range used for the GPIO if OK, otherwise PI_BAD_USER_GPIO.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_gpio: 0-31


</code></pre>
<p><br />
</p>
<p><br />
If a hardware clock is active on the GPIO the reported real range will be 1000000 (1M).</p>
<p><br />
</p>
<p><br />
If hardware PWM is active on the GPIO the reported real range will be approximately 250M divided by the set PWM frequency.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>rr = gpioGetPWMrealRange(17);


</code></pre>
<ul>
<li></li>
<li><p>Sets the frequency in hertz to be used for the GPIO.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_gpio: 0-31


frequency: &gt;=0


</code></pre>
<p><br />
</p>
<p><br />
Returns the numerically closest frequency if OK, otherwise PI_BAD_USER_GPIO.</p>
<p><br />
</p>
<p><br />
If PWM is currently active on the GPIO it will be switched off and then back on at the new frequency.</p>
<p><br />
</p>
<p><br />
Each GPIO can be independently set to one of 18 different PWM frequencies.</p>
<p><br />
</p>
<p><br />
The selectable frequencies depend upon the sample rate which may be 1, 2, 4, 5, 8, or 10 microseconds (default 5).</p>
<p><br />
</p>
<p><br />
The frequencies for each sample rate are:</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>                       Hertz





       1: 40000 20000 10000 8000 5000 4000 2500 2000 1600


           1250  1000   800  500  400  250  200  100   50





       2: 20000 10000  5000 4000 2500 2000 1250 1000  800


            625   500   400  250  200  125  100   50   25





       4: 10000  5000  2500 2000 1250 1000  625  500  400


            313   250   200  125  100   63   50   25   13


sample


 rate


 (us)  5:  8000  4000  2000 1600 1000  800  500  400  320


            250   200   160  100   80   50   40   20   10





       8:  5000  2500  1250 1000  625  500  313  250  200


            156   125   100   63   50   31   25   13    6





      10:  4000  2000  1000  800  500  400  250  200  160


            125   100    80   50   40   25   20   10    5


</code></pre>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>gpioSetPWMfrequency(23, 0); // Set GPIO23 to lowest frequency.





gpioSetPWMfrequency(24, 500); // Set GPIO24 to 500Hz.





gpioSetPWMfrequency(25, 100000); // Set GPIO25 to highest frequency.


</code></pre>
<ul>
<li></li>
<li><p>Returns the frequency (in hertz) used for the GPIO if OK, otherwise PI_BAD_USER_GPIO.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_gpio: 0-31


</code></pre>
<p><br />
</p>
<p><br />
For normal PWM the frequency will be that defined for the GPIO by <strong>gpioSetPWMfrequency</strong>.</p>
<p><br />
</p>
<p><br />
If a hardware clock is active on the GPIO the reported frequency will be that set by <strong>gpioHardwareClock</strong>.</p>
<p><br />
</p>
<p><br />
If hardware PWM is active on the GPIO the reported frequency will be that set by <strong>gpioHardwarePWM</strong>.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>f = gpioGetPWMfrequency(23); // Get frequency used for GPIO23.


</code></pre>
<ul>
<li></li>
<li><p>Starts servo pulses on the GPIO, 0 (off), 500 (most anti-clockwise) to 2500 (most clockwise).</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code> user_gpio: 0-31


pulsewidth: 0, 500-2500


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_USER_GPIO or PI_BAD_PULSEWIDTH.</p>
<p><br />
</p>
<p><br />
The range supported by servos varies and should probably be determined by experiment. A value of 1500 should always be safe and represents the mid-point of rotation. You can DAMAGE a servo if you command it to move beyond its limits.</p>
<p><br />
</p>
<p><br />
The following causes an on pulse of 1500 microseconds duration to be transmitted on GPIO 17 at a rate of 50 times per second. This will command a servo connected to GPIO 17 to rotate to its mid-point.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>gpioServo(17, 1000); // Move servo to safe position anti-clockwise.





gpioServo(23, 1500); // Move servo to centre position.





gpioServo(25, 2000); // Move servo to safe position clockwise.


</code></pre>
<p><br />
</p>
<p><br />
OTHER UPDATE RATES:</p>
<p><br />
</p>
<p><br />
This function updates servos at 50Hz. If you wish to use a different update frequency you will have to use the PWM functions.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>PWM Hz    50   100  200  400  500


1E6/Hz 20000 10000 5000 2500 2000


</code></pre>
<p><br />
</p>
<p><br />
Firstly set the desired PWM frequency using <strong>gpioSetPWMfrequency</strong>.</p>
<p><br />
</p>
<p><br />
Then set the PWM range using <strong>gpioSetPWMrange</strong> to 1E6/frequency. Doing this allows you to use units of microseconds when setting the servo pulsewidth.</p>
<p><br />
</p>
<p><br />
E.g. If you want to update a servo connected to GPIO25 at 400Hz</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>gpioSetPWMfrequency(25, 400);





gpioSetPWMrange(25, 2500);


</code></pre>
<p><br />
</p>
<p><br />
Thereafter use the PWM command to move the servo, e.g. gpioPWM(25, 1500) will set a 1500 us pulse.</p>
<ul>
<li></li>
<li><p>Returns the servo pulsewidth setting for the GPIO.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_gpio: 0-31


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 (off), 500 (most anti-clockwise) to 2500 (most clockwise) if OK, otherwise PI_BAD_USER_GPIO or PI_NOT_SERVO_GPIO.</p>
<ul>
<li></li>
<li><p>Registers a function to be called (a callback) when the specified GPIO changes state.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_gpio: 0-31


        f: the callback function


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_USER_GPIO.</p>
<p><br />
</p>
<p><br />
One callback may be registered per GPIO.</p>
<p><br />
</p>
<p><br />
The callback is passed the GPIO, the new level, and the tick.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>Parameter   Value    Meaning





GPIO        0-31     The GPIO which has changed state





level       0-2      0 = change to low (a falling edge)


                     1 = change to high (a rising edge)


                     2 = no level change (a watchdog timeout)





tick        32 bit   The number of microseconds since boot


                     WARNING: this wraps around from


                     4294967295 to 0 roughly every 72 minutes


</code></pre>
<p><br />
</p>
<p><br />
The alert may be cancelled by passing NULL as the function.</p>
<p><br />
</p>
<p><br />
The GPIO are sampled at a rate set when the library is started.</p>
<p><br />
</p>
<p><br />
If a value isn't specifically set the default of 5 us is used.</p>
<p><br />
</p>
<p><br />
The number of samples per second is given in the following table.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>              samples


              per sec





         1  1,000,000


         2    500,000


sample   4    250,000


rate     5    200,000


(us)     8    125,000


        10    100,000


</code></pre>
<p><br />
</p>
<p><br />
Level changes shorter than the sample rate may be missed.</p>
<p><br />
</p>
<p><br />
The thread which calls the alert functions is triggered nominally 1000 times per second. The active alert functions will be called once per level change since the last time the thread was activated. i.e. The active alert functions will get all level changes but there will be a latency.</p>
<p><br />
</p>
<p><br />
If you want to track the level of more than one GPIO do so by maintaining the state in the callback. Do not use <strong>gpioRead</strong>. Remember the event that triggered the callback may have happened several milliseconds before and the GPIO may have changed level many times since then.</p>
<p><br />
</p>
<p><br />
The tick value is the time stamp of the sample in microseconds, see <strong>gpioTick</strong> for more details.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>void aFunction(int gpio, int level, uint32_t tick)


{


   printf(&quot;GPIO %d became %d at %d&quot;, gpio, level, tick);


}





// call aFunction whenever GPIO 4 changes state





gpioSetAlertFunc(4, aFunction);


</code></pre>
<ul>
<li></li>
<li><p>Registers a function to be called (a callback) when the specified GPIO changes state.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_gpio: 0-31


        f: the callback function


 userdata: pointer to arbitrary user data


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_USER_GPIO.</p>
<p><br />
</p>
<p><br />
One callback may be registered per GPIO.</p>
<p><br />
</p>
<p><br />
The callback is passed the GPIO, the new level, the tick, and the userdata pointer.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>Parameter   Value    Meaning





GPIO        0-31     The GPIO which has changed state





level       0-2      0 = change to low (a falling edge)


                     1 = change to high (a rising edge)


                     2 = no level change (a watchdog timeout)





tick        32 bit   The number of microseconds since boot


                     WARNING: this wraps around from


                     4294967295 to 0 roughly every 72 minutes





userdata    pointer  Pointer to an arbitrary object


</code></pre>
<p><br />
</p>
<p><br />
See <strong>gpioSetAlertFunc</strong> for further details.</p>
<p><br />
</p>
<p><br />
Only one of <strong>gpioSetAlertFunc</strong> or <strong>gpioSetAlertFuncEx</strong> can be registered per GPIO.</p>
<ul>
<li></li>
<li><p>Registers a function to be called (a callback) whenever the specified GPIO interrupt occurs.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>   gpio: 0-53


   edge: RISING_EDGE, FALLING_EDGE, or EITHER_EDGE


timeout: interrupt timeout in milliseconds (&lt;=0 to cancel)


      f: the callback function


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_GPIO, PI_BAD_EDGE, or PI_BAD_ISR_INIT.</p>
<p><br />
</p>
<p><br />
One function may be registered per GPIO.</p>
<p><br />
</p>
<p><br />
The function is passed the GPIO, the current level, and the current tick. The level will be PI_TIMEOUT if the optional interrupt timeout expires.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>Parameter   Value    Meaning





GPIO        0-53     The GPIO which has changed state





level       0-2      0 = change to low (a falling edge)


                     1 = change to high (a rising edge)


                     2 = no level change (interrupt timeout)





tick        32 bit   The number of microseconds since boot


                     WARNING: this wraps around from


                     4294967295 to 0 roughly every 72 minutes


</code></pre>
<p><br />
</p>
<p><br />
The underlying Linux sysfs GPIO interface is used to provide the interrupt services.</p>
<p><br />
</p>
<p><br />
The first time the function is called, with a non-NULL f, the GPIO is exported, set to be an input, and set to interrupt on the given edge and timeout.</p>
<p><br />
</p>
<p><br />
Subsequent calls, with a non-NULL f, can vary one or more of the edge, timeout, or function.</p>
<p><br />
</p>
<p><br />
The ISR may be cancelled by passing a NULL f, in which case the GPIO is unexported.</p>
<p><br />
</p>
<p><br />
The tick is that read at the time the process was informed of the interrupt. This will be a variable number of microseconds after the interrupt occurred. Typically the latency will be of the order of 50 microseconds. The latency is not guaranteed and will vary with system load.</p>
<p><br />
</p>
<p><br />
The level is that read at the time the process was informed of the interrupt, or PI_TIMEOUT if the optional interrupt timeout expired. It may not be the same as the expected edge as interrupts happening in rapid succession may be missed by the kernel (i.e. this mechanism can not be used to capture several interrupts only a few microseconds apart).</p>
<ul>
<li></li>
<li><p>Registers a function to be called (a callback) whenever the specified GPIO interrupt occurs.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>    gpio: 0-53


    edge: RISING_EDGE, FALLING_EDGE, or EITHER_EDGE


 timeout: interrupt timeout in milliseconds (&lt;=0 to cancel)


       f: the callback function


userdata: pointer to arbitrary user data


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_GPIO, PI_BAD_EDGE, or PI_BAD_ISR_INIT.</p>
<p><br />
</p>
<p><br />
The function is passed the GPIO, the current level, the current tick, and the userdata pointer.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>Parameter   Value    Meaning





GPIO        0-53     The GPIO which has changed state





level       0-2      0 = change to low (a falling edge)


                     1 = change to high (a rising edge)


                     2 = no level change (interrupt timeout)





tick        32 bit   The number of microseconds since boot


                     WARNING: this wraps around from


                     4294967295 to 0 roughly every 72 minutes





userdata    pointer  Pointer to an arbitrary object


</code></pre>
<p><br />
</p>
<p><br />
Only one of <strong>gpioSetISRFunc</strong> or <strong>gpioSetISRFuncEx</strong> can be registered per GPIO.</p>
<p><br />
</p>
<p><br />
See <strong>gpioSetISRFunc</strong> for further details.</p>
<ul>
<li></li>
<li><p>This function requests a free notification handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
Returns a handle greater than or equal to zero if OK, otherwise PI_NO_HANDLE.</p>
<p><br />
</p>
<p><br />
A notification is a method for being notified of GPIO state changes via a pipe or socket.</p>
<p><br />
</p>
<p><br />
Pipe notifications for handle x will be available at the pipe named /dev/pigpiox (where x is the handle number). E.g. if the function returns 15 then the notifications must be read from /dev/pigpio15.</p>
<p><br />
</p>
<p><br />
Socket notifications are returned to the socket which requested the handle.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>h = gpioNotifyOpen();





if (h &gt;= 0)


{


   sprintf(str, &quot;/dev/pigpio%d&quot;, h);





   fd = open(str, O_RDONLY);





   if (fd &gt;= 0)


   {


      // Okay.


   }


   else


   {


      // Error.


   }


}


else


{


   // Error.


}


</code></pre>
<ul>
<li></li>
<li><p>This function requests a free notification handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
It differs from <strong>gpioNotifyOpen</strong> in that the pipe size may be specified, whereas <strong>gpioNotifyOpen</strong> uses the default pipe size.</p>
<p><br />
</p>
<p><br />
See <strong>gpioNotifyOpen</strong> for further details.</p>
<ul>
<li></li>
<li><p>This function starts notifications on a previously opened handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by gpioNotifyOpen


  bits: a bit mask indicating the GPIO of interest


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_HANDLE.</p>
<p><br />
</p>
<p><br />
The notification sends state changes for each GPIO whose corresponding bit in bits is set.</p>
<p><br />
</p>
<p><br />
Each notification occupies 12 bytes in the fifo and has the following structure.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>typedef struct


{


   uint16_t seqno;


   uint16_t flags;


   uint32_t tick;


   uint32_t level;


} gpioReport_t;


</code></pre>
<p><br />
</p>
<p><br />
seqno: starts at 0 each time the handle is opened and then increments by one for each report.</p>
<p><br />
</p>
<p><br />
flags: three flags are defined, PI_NTFY_FLAGS_WDOG, PI_NTFY_FLAGS_ALIVE, and PI_NTFY_FLAGS_EVENT.</p>
<p><br />
</p>
<p><br />
If bit 5 is set (PI_NTFY_FLAGS_WDOG) then bits 0-4 of the flags indicate a GPIO which has had a watchdog timeout.</p>
<p><br />
</p>
<p><br />
If bit 6 is set (PI_NTFY_FLAGS_ALIVE) this indicates a keep alive signal on the pipe/socket and is sent once a minute in the absence of other notification activity.</p>
<p><br />
</p>
<p><br />
If bit 7 is set (PI_NTFY_FLAGS_EVENT) then bits 0-4 of the flags indicate an event which has been triggered.</p>
<p><br />
</p>
<p><br />
tick: the number of microseconds since system boot. It wraps around after 1h12m.</p>
<p><br />
</p>
<p><br />
level: indicates the level of each GPIO. If bit 1&lt;&lt;x is set then GPIO x is high.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>// Start notifications for GPIO 1, 4, 6, 7, 10.





//                         1


//                         0  76 4  1


// (1234 = 0x04D2 = 0b0000010011010010)





gpioNotifyBegin(h, 1234);


</code></pre>
<ul>
<li></li>
<li><p>This function pauses notifications on a previously opened handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by gpioNotifyOpen


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_HANDLE.</p>
<p><br />
</p>
<p><br />
Notifications for the handle are suspended until <strong>gpioNotifyBegin</strong> is called again.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>gpioNotifyPause(h);


</code></pre>
<ul>
<li></li>
<li><p>This function stops notifications on a previously opened handle and releases the handle for reuse.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by gpioNotifyOpen


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_HANDLE.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>gpioNotifyClose(h);


</code></pre>
<ul>
<li></li>
<li><p>This function clears all waveforms and any data added by calls to the <strong>gpioWaveAdd*</strong> functions.</p></li>
</ul>
<p><br />
</p>
<p><br />
Returns 0 if OK.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>gpioWaveClear();


</code></pre>
<ul>
<li></li>
<li><p>This function starts a new empty waveform.</p></li>
</ul>
<p><br />
</p>
<p><br />
You wouldn't normally need to call this function as it is automatically called after a waveform is created with the <strong>gpioWaveCreate</strong> function.</p>
<p><br />
</p>
<p><br />
Returns 0 if OK.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>gpioWaveAddNew();


</code></pre>
<ul>
<li></li>
<li><p>This function adds a number of pulses to the current waveform.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>numPulses: the number of pulses


   pulses: an array of pulses


</code></pre>
<p><br />
</p>
<p><br />
Returns the new total number of pulses in the current waveform if OK, otherwise PI_TOO_MANY_PULSES.</p>
<p><br />
</p>
<p><br />
The pulses are interleaved in time order within the existing waveform (if any).</p>
<p><br />
</p>
<p><br />
Merging allows the waveform to be built in parts, that is the settings for GPIO#1 can be added, and then GPIO#2 etc.</p>
<p><br />
</p>
<p><br />
If the added waveform is intended to start after or within the existing waveform then the first pulse should consist of a delay.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>// Construct and send a 30 microsecond square wave.





gpioSetMode(gpio, PI_OUTPUT);





pulse[0].gpioOn = (1&lt;&lt;gpio);


pulse[0].gpioOff = 0;


pulse[0].usDelay = 15;





pulse[1].gpioOn = 0;


pulse[1].gpioOff = (1&lt;&lt;gpio);


pulse[1].usDelay = 15;





gpioWaveAddNew();





gpioWaveAddGeneric(2, pulse);





wave_id = gpioWaveCreate();





if (wave_id &gt;= 0)


{


   gpioWaveTxSend(wave_id, PI_WAVE_MODE_REPEAT);





   // Transmit for 30 seconds.





   sleep(30);





   gpioWaveTxStop();


}


else


{


   // Wave create failed.


}


</code></pre>
<ul>
<li></li>
<li><p>This function adds a waveform representing serial data to the existing waveform (if any). The serial data starts offset microseconds from the start of the waveform.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_gpio: 0-31


     baud: 50-1000000


data_bits: 1-32


stop_bits: 2-8


   offset: &gt;=0


 numBytes: &gt;=1


      str: an array of chars (which may contain nulls)


</code></pre>
<p><br />
</p>
<p><br />
Returns the new total number of pulses in the current waveform if OK, otherwise PI_BAD_USER_GPIO, PI_BAD_WAVE_BAUD, PI_BAD_DATABITS, PI_BAD_STOPBITS, PI_TOO_MANY_CHARS, PI_BAD_SER_OFFSET, or PI_TOO_MANY_PULSES.</p>
<p><br />
</p>
<p><br />
NOTES:</p>
<p><br />
</p>
<p><br />
The serial data is formatted as one start bit, data_bits data bits, and stop_bits/2 stop bits.</p>
<p><br />
</p>
<p><br />
It is legal to add serial data streams with different baud rates to the same waveform.</p>
<p><br />
</p>
<p><br />
numBytes is the number of bytes of data in str.</p>
<p><br />
</p>
<p><br />
The bytes required for each character depend upon data_bits.</p>
<p><br />
</p>
<p><br />
For data_bits 1-8 there will be one byte per character.<br />
For data_bits 9-16 there will be two bytes per character.<br />
For data_bits 17-32 there will be four bytes per character.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>#define MSG_LEN 8





int i;


char *str;


char data[MSG_LEN];





str = &quot;Hello world!&quot;;





gpioWaveAddSerial(4, 9600, 8, 2, 0, strlen(str), str);





for (i=0; i&lt;MSG_LEN; i++) data[i] = i;





// Data added is offset 1 second from the waveform start.


gpioWaveAddSerial(4, 9600, 8, 2, 1000000, MSG_LEN, data);


</code></pre>
<ul>
<li></li>
<li><p>This function creates a waveform from the data provided by the prior calls to the <strong>gpioWaveAdd*</strong> functions. Upon success a wave id greater than or equal to 0 is returned, otherwise PI_EMPTY_WAVEFORM, PI_TOO_MANY_CBS, PI_TOO_MANY_OOL, or PI_NO_WAVEFORM_ID.</p></li>
</ul>
<p><br />
</p>
<p><br />
The data provided by the <strong>gpioWaveAdd*</strong> functions is consumed by this function.</p>
<p><br />
</p>
<p><br />
As many waveforms may be created as there is space available. The wave id is passed to <strong>gpioWaveTxSend</strong> to specify the waveform to transmit.</p>
<p><br />
</p>
<p><br />
Normal usage would be</p>
<p><br />
</p>
<p><br />
Step 1. <strong>gpioWaveClear</strong> to clear all waveforms and added data.</p>
<p><br />
</p>
<p><br />
Step 2. <strong>gpioWaveAdd*</strong> calls to supply the waveform data.</p>
<p><br />
</p>
<p><br />
Step 3. <strong>gpioWaveCreate</strong> to create the waveform and get a unique id</p>
<p><br />
</p>
<p><br />
Repeat steps 2 and 3 as needed.</p>
<p><br />
</p>
<p><br />
Step 4. <strong>gpioWaveTxSend</strong> with the id of the waveform to transmit.</p>
<p><br />
</p>
<p><br />
A waveform comprises one of more pulses. Each pulse consists of a <strong>gpioPulse_t</strong> structure.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>typedef struct


{


   uint32_t gpioOn;


   uint32_t gpioOff;


   uint32_t usDelay;


} gpioPulse_t;


</code></pre>
<p><br />
</p>
<p><br />
The fields specify</p>
<p><br />
</p>
<p><br />
1) the GPIO to be switched on at the start of the pulse.<br />
2) the GPIO to be switched off at the start of the pulse.<br />
3) the delay in microseconds before the next pulse.</p>
<p><br />
</p>
<p><br />
Any or all the fields can be zero. It doesn't make any sense to set all the fields to zero (the pulse will be ignored).</p>
<p><br />
</p>
<p><br />
When a waveform is started each pulse is executed in order with the specified delay between the pulse and the next.</p>
<p><br />
</p>
<p><br />
Returns the new waveform id if OK, otherwise PI_EMPTY_WAVEFORM, PI_NO_WAVEFORM_ID, PI_TOO_MANY_CBS, or PI_TOO_MANY_OOL.</p>
<ul>
<li></li>
<li><p>Similar to <strong>gpioWaveCreate</strong>, this function creates a waveform but pads the consumed resources. Padded waves of equal dimension can be re-cycled efficiently allowing newly created waves to re-use the resources of deleted waves of the same dimension.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>pctCB: 0-100, the percent of all DMA control blocks to consume.


pctBOOL: 0-100, percent On-Off-Level (OOL) buffer to consume for wave output.


pctTOOL: 0-100, the percent of OOL buffer to consume for wave input (flags).


</code></pre>
<p><br />
</p>
<p><br />
Upon success a wave id greater than or equal to 0 is returned, otherwise PI_EMPTY_WAVEFORM, PI_TOO_MANY_CBS, PI_TOO_MANY_OOL, or PI_NO_WAVEFORM_ID.</p>
<p><br />
</p>
<p><br />
Waveform data provided by <strong>gpioWaveAdd*</strong> and <strong>rawWaveAdd*</strong> functions are consumed by this function.</p>
<p><br />
</p>
<p><br />
A usage would be the creation of two waves where one is filled while the other is being transmitted. Each wave is assigned 50% of the resources. This buffer structure allows the transmission of infinite wave sequences.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>  // get firstWaveChunk, somehow


  gpioWaveAddGeneric(firstWaveChunk);


  wid = gpioWaveCreatePad(50, 50, 0);


  gpioWaveTxSend(wid, PI_WAVE_MODE_ONE_SHOT);


  // get nextWaveChunk





  while (nextWaveChunk) {


     gpioWaveAddGeneric(nextWaveChunk);


     nextWid = gpioWaveCreatePad(50, 50, 0);


     gpioWaveTxSend(nextWid, PI_WAVE_MODE_ONE_SHOT_SYNC);


     while(gpioWaveTxAt() == wid) time_sleep(0.1);


     gpioWaveDelete(wid);


     wid = nextWid;


     // get nextWaveChunk


  }


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
<li><p>This function deletes the waveform with id wave_id.</p></li>
</ul>
<p><br />
</p>
<p><br />
The wave is flagged for deletion. The resources used by the wave will only be reused when either of the following apply.</p>
<p><br />
</p>
<p><br />
- all waves with higher numbered wave ids have been deleted or have been flagged for deletion.</p>
<p><br />
</p>
<p><br />
- a new wave is created which uses exactly the same resources as the current wave (see the C source for gpioWaveCreate for details).</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>wave_id: &gt;=0, as returned by gpioWaveCreate


</code></pre>
<p><br />
</p>
<p><br />
Wave ids are allocated in order, 0, 1, 2, etc.</p>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_WAVE_ID.</p>
<ul>
<li></li>
<li><p>This function transmits the waveform with id wave_id. The mode determines whether the waveform is sent once or cycles endlessly. The SYNC variants wait for the current waveform to reach the end of a cycle or finish before starting the new waveform.</p></li>
</ul>
<p><br />
</p>
<p><br />
WARNING: bad things may happen if you delete the previous waveform before it has been synced to the new waveform.</p>
<p><br />
</p>
<p><br />
NOTE: Any hardware PWM started by <strong>gpioHardwarePWM</strong> will be cancelled.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>  wave_id: &gt;=0, as returned by gpioWaveCreate


wave_mode: PI_WAVE_MODE_ONE_SHOT, PI_WAVE_MODE_REPEAT,


           PI_WAVE_MODE_ONE_SHOT_SYNC, PI_WAVE_MODE_REPEAT_SYNC


</code></pre>
<p><br />
</p>
<p><br />
Returns the number of DMA control blocks in the waveform if OK, otherwise PI_BAD_WAVE_ID, or PI_BAD_WAVE_MODE.</p>
<ul>
<li></li>
<li><p>This function transmits a chain of waveforms.</p></li>
</ul>
<p><br />
</p>
<p><br />
NOTE: Any hardware PWM started by <strong>gpioHardwarePWM</strong> will be cancelled.</p>
<p><br />
</p>
<p><br />
The waves to be transmitted are specified by the contents of buf which contains an ordered list of <strong>wave_id</strong>s and optional command codes and related data.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>    buf: pointer to the wave_ids and optional command codes


bufSize: the number of bytes in buf


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_CHAIN_NESTING, PI_CHAIN_LOOP_CNT, PI_BAD_CHAIN_LOOP, PI_BAD_CHAIN_CMD, PI_CHAIN_COUNTER, PI_BAD_CHAIN_DELAY, PI_CHAIN_TOO_BIG, or PI_BAD_WAVE_ID.</p>
<p><br />
</p>
<p><br />
Each wave is transmitted in the order specified. A wave may occur multiple times per chain.</p>
<p><br />
</p>
<p><br />
A blocks of waves may be transmitted multiple times by using the loop commands. The block is bracketed by loop start and end commands. Loops may be nested.</p>
<p><br />
</p>
<p><br />
Delays between waves may be added with the delay command.</p>
<p><br />
</p>
<p><br />
The following command codes are supported:</p>
<p><br />
</p>
<p><br />
Name Cmd &amp; Data Meaning<br />
Loop Start 255 0 Identify start of a wave block<br />
Loop Repeat 255 1 x y loop x + y*256 times<br />
Delay 255 2 x y delay x + y*256 microseconds<br />
Loop Forever 255 3 loop forever<br />
</p>
<p><br />
</p>
<p><br />
If present Loop Forever must be the last entry in the chain.</p>
<p><br />
</p>
<p><br />
The code is currently dimensioned to support a chain with roughly 600 entries and 20 loop counters.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>#include &lt;stdio.h&gt;


#include &lt;pigpio.h&gt;





#define WAVES 5


#define GPIO 4





int main(int argc, char *argv[])


{


   int i, wid[WAVES];





   if (gpioInitialise()&lt;0) return -1;





   gpioSetMode(GPIO, PI_OUTPUT);





   printf(&quot;start piscope, press return&quot;); getchar();





   for (i=0; i&lt;WAVES; i++)


   {


      gpioWaveAddGeneric(2, (gpioPulse_t[])


         {{1&lt;&lt;GPIO, 0,        20},


          {0, 1&lt;&lt;GPIO, (i+1)*200}});





      wid[i] = gpioWaveCreate();


   }





   gpioWaveChain((char []) {


      wid[4], wid[3], wid[2],       // transmit waves 4+3+2


      255, 0,                       // loop start


         wid[0], wid[0], wid[0],    // transmit waves 0+0+0


         255, 0,                    // loop start


            wid[0], wid[1],         // transmit waves 0+1


            255, 2, 0x88, 0x13,     // delay 5000us


         255, 1, 30, 0,             // loop end (repeat 30 times)


         255, 0,                    // loop start


            wid[2], wid[3], wid[0], // transmit waves 2+3+0


            wid[3], wid[1], wid[2], // transmit waves 3+1+2


         255, 1, 10, 0,             // loop end (repeat 10 times)


      255, 1, 5, 0,                 // loop end (repeat 5 times)


      wid[4], wid[4], wid[4],       // transmit waves 4+4+4


      255, 2, 0x20, 0x4E,           // delay 20000us


      wid[0], wid[0], wid[0],       // transmit waves 0+0+0





      }, 46);





   while (gpioWaveTxBusy()) time_sleep(0.1);





   for (i=0; i&lt;WAVES; i++) gpioWaveDelete(wid[i]);





   printf(&quot;stop piscope, press return&quot;); getchar();





   gpioTerminate();


}


</code></pre>
<ul>
<li></li>
<li><p>This function returns the id of the waveform currently being transmitted using <strong>gpioWaveTxSend</strong>. Chained waves are not supported.</p></li>
</ul>
<p><br />
</p>
<p><br />
Returns the waveform id or one of the following special values:</p>
<p><br />
</p>
<p><br />
PI_WAVE_NOT_FOUND (9998) - transmitted wave not found.<br />
PI_NO_TX_WAVE (9999) - no wave being transmitted.</p>
<ul>
<li></li>
<li><p>This function checks to see if a waveform is currently being transmitted.</p></li>
</ul>
<p><br />
</p>
<p><br />
Returns 1 if a waveform is currently being transmitted, otherwise 0.</p>
<ul>
<li></li>
<li><p>This function aborts the transmission of the current waveform.</p></li>
</ul>
<p><br />
</p>
<p><br />
Returns 0 if OK.</p>
<p><br />
</p>
<p><br />
This function is intended to stop a waveform started in repeat mode.</p>
<ul>
<li></li>
<li><p>This function returns the length in microseconds of the current waveform.</p></li>
</ul>
<ul>
<li></li>
<li><p>This function returns the length in microseconds of the longest waveform created since <strong>gpioInitialise</strong> was called.</p></li>
</ul>
<ul>
<li></li>
<li><p>This function returns the maximum possible size of a waveform in microseconds.</p></li>
</ul>
<ul>
<li></li>
<li><p>This function returns the length in pulses of the current waveform.</p></li>
</ul>
<ul>
<li></li>
<li><p>This function returns the length in pulses of the longest waveform created since <strong>gpioInitialise</strong> was called.</p></li>
</ul>
<ul>
<li></li>
<li><p>This function returns the maximum possible size of a waveform in pulses.</p></li>
</ul>
<ul>
<li></li>
<li><p>This function returns the length in DMA control blocks of the current waveform.</p></li>
</ul>
<ul>
<li></li>
<li><p>This function returns the length in DMA control blocks of the longest waveform created since <strong>gpioInitialise</strong> was called.</p></li>
</ul>
<ul>
<li></li>
<li><p>This function returns the maximum possible size of a waveform in DMA control blocks.</p></li>
</ul>
<ul>
<li></li>
<li><p>This function opens a GPIO for bit bang reading of serial data.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_gpio: 0-31


     baud: 50-250000


data_bits: 1-32


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_USER_GPIO, PI_BAD_WAVE_BAUD, PI_BAD_DATABITS, or PI_GPIO_IN_USE.</p>
<p><br />
</p>
<p><br />
The serial data is returned in a cyclic buffer and is read using <strong>gpioSerialRead</strong>.</p>
<p><br />
</p>
<p><br />
It is the caller's responsibility to read data from the cyclic buffer in a timely fashion.</p>
<ul>
<li></li>
<li><p>This function configures the level logic for bit bang serial reads.</p></li>
</ul>
<p><br />
</p>
<p><br />
Use PI_BB_SER_INVERT to invert the serial logic and PI_BB_SER_NORMAL for normal logic. Default is PI_BB_SER_NORMAL.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_gpio: 0-31


   invert: 0-1


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_USER_GPIO, PI_GPIO_IN_USE, PI_NOT_SERIAL_GPIO, or PI_BAD_SER_INVERT.</p>
<p><br />
</p>
<p><br />
The GPIO must be opened for bit bang reading of serial data using <strong>gpioSerialReadOpen</strong> prior to calling this function.</p>
<ul>
<li></li>
<li><p>This function copies up to bufSize bytes of data read from the bit bang serial cyclic buffer to the buffer starting at buf.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_gpio: 0-31, previously opened with gpioSerialReadOpen


      buf: an array to receive the read bytes


  bufSize: &gt;=0


</code></pre>
<p><br />
</p>
<p><br />
Returns the number of bytes copied if OK, otherwise PI_BAD_USER_GPIO or PI_NOT_SERIAL_GPIO.</p>
<p><br />
</p>
<p><br />
The bytes returned for each character depend upon the number of data bits <strong>data_bits</strong> specified in the <strong>gpioSerialReadOpen</strong> command.</p>
<p><br />
</p>
<p><br />
For <strong>data_bits</strong> 1-8 there will be one byte per character.<br />
For <strong>data_bits</strong> 9-16 there will be two bytes per character.<br />
For <strong>data_bits</strong> 17-32 there will be four bytes per character.</p>
<ul>
<li></li>
<li><p>This function closes a GPIO for bit bang reading of serial data.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_gpio: 0-31, previously opened with gpioSerialReadOpen


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_USER_GPIO, or PI_NOT_SERIAL_GPIO.</p>
<ul>
<li></li>
<li><p>This returns a handle for the device at the address on the I2C bus.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>  i2cBus: &gt;=0


 i2cAddr: 0-0x7F


i2cFlags: 0


</code></pre>
<p><br />
</p>
<p><br />
No flags are currently defined. This parameter should be set to zero.</p>
<p><br />
</p>
<p><br />
Physically buses 0 and 1 are available on the Pi. Higher numbered buses will be available if a kernel supported bus multiplexor is being used.</p>
<p><br />
</p>
<p><br />
The GPIO used are given in the following table.</p>
<p><br />
</p>
<p><br />
SDA SCL<br />
I2C 0 0 1<br />
I2C 1 2 3<br />
</p>
<p><br />
</p>
<p><br />
Returns a handle (&gt;=0) if OK, otherwise PI_BAD_I2C_BUS, PI_BAD_I2C_ADDR, PI_BAD_FLAGS, PI_NO_HANDLE, or PI_I2C_OPEN_FAILED.</p>
<p><br />
</p>
<p><br />
For the SMBus commands the low level transactions are shown at the end of the function description. The following abbreviations are used.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>S      (1 bit) : Start bit


P      (1 bit) : Stop bit


Rd/Wr  (1 bit) : Read/Write bit. Rd equals 1, Wr equals 0.


A, NA  (1 bit) : Accept and not accept bit.






Addr   (7 bits): I2C 7 bit address.


i2cReg (8 bits): Command byte, a byte which often selects a register.


Data   (8 bits): A data byte.


Count  (8 bits): A byte defining the length of a block operation.





[..]: Data sent by the device.


</code></pre>
<ul>
<li></li>
<li><p>This closes the I2C device associated with the handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to i2cOpen


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_HANDLE.</p>
<ul>
<li></li>
<li><p>This sends a single bit (in the Rd/Wr bit) to the device associated with handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to i2cOpen


   bit: 0-1, the value to write


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or PI_I2C_WRITE_FAILED.</p>
<p><br />
</p>
<p><br />
Quick command. SMBus 2.0 5.5.1</p>
<pre><code>S Addr bit [A] P


</code></pre>
<ul>
<li></li>
<li><p>This sends a single byte to the device associated with handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to i2cOpen


  bVal: 0-0xFF, the value to write


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or PI_I2C_WRITE_FAILED.</p>
<p><br />
</p>
<p><br />
Send byte. SMBus 2.0 5.5.2</p>
<pre><code>S Addr Wr [A] bVal [A] P


</code></pre>
<ul>
<li></li>
<li><p>This reads a single byte from the device associated with handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to i2cOpen


</code></pre>
<p><br />
</p>
<p><br />
Returns the byte read (&gt;=0) if OK, otherwise PI_BAD_HANDLE, or PI_I2C_READ_FAILED.</p>
<p><br />
</p>
<p><br />
Receive byte. SMBus 2.0 5.5.3</p>
<pre><code>S Addr Rd [A] [Data] NA P


</code></pre>
<ul>
<li></li>
<li><p>This writes a single byte to the specified register of the device associated with handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to i2cOpen


i2cReg: 0-255, the register to write


  bVal: 0-0xFF, the value to write


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or PI_I2C_WRITE_FAILED.</p>
<p><br />
</p>
<p><br />
Write byte. SMBus 2.0 5.5.4</p>
<pre><code>S Addr Wr [A] i2cReg [A] bVal [A] P


</code></pre>
<ul>
<li></li>
<li><p>This writes a single 16 bit word to the specified register of the device associated with handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to i2cOpen


i2cReg: 0-255, the register to write


  wVal: 0-0xFFFF, the value to write


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or PI_I2C_WRITE_FAILED.</p>
<p><br />
</p>
<p><br />
Write word. SMBus 2.0 5.5.4</p>
<pre><code>S Addr Wr [A] i2cReg [A] wValLow [A] wValHigh [A] P


</code></pre>
<ul>
<li></li>
<li><p>This reads a single byte from the specified register of the device associated with handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to i2cOpen


i2cReg: 0-255, the register to read


</code></pre>
<p><br />
</p>
<p><br />
Returns the byte read (&gt;=0) if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or PI_I2C_READ_FAILED.</p>
<p><br />
</p>
<p><br />
Read byte. SMBus 2.0 5.5.5</p>
<pre><code>S Addr Wr [A] i2cReg [A] S Addr Rd [A] [Data] NA P


</code></pre>
<ul>
<li></li>
<li><p>This reads a single 16 bit word from the specified register of the device associated with handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to i2cOpen


i2cReg: 0-255, the register to read


</code></pre>
<p><br />
</p>
<p><br />
Returns the word read (&gt;=0) if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or PI_I2C_READ_FAILED.</p>
<p><br />
</p>
<p><br />
Read word. SMBus 2.0 5.5.5</p>
<pre><code>S Addr Wr [A] i2cReg [A] S Addr Rd [A] [DataLow] A [DataHigh] NA P


</code></pre>
<ul>
<li></li>
<li><p>This writes 16 bits of data to the specified register of the device associated with handle and reads 16 bits of data in return.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to i2cOpen


i2cReg: 0-255, the register to write/read


  wVal: 0-0xFFFF, the value to write


</code></pre>
<p><br />
</p>
<p><br />
Returns the word read (&gt;=0) if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or PI_I2C_READ_FAILED.</p>
<p><br />
</p>
<p><br />
Process call. SMBus 2.0 5.5.6</p>
<pre><code>S Addr Wr [A] i2cReg [A] wValLow [A] wValHigh [A]


   S Addr Rd [A] [DataLow] A [DataHigh] NA P


</code></pre>
<ul>
<li></li>
<li><p>This writes up to 32 bytes to the specified register of the device associated with handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to i2cOpen


i2cReg: 0-255, the register to write


   buf: an array with the data to send


 count: 1-32, the number of bytes to write


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or PI_I2C_WRITE_FAILED.</p>
<p><br />
</p>
<p><br />
Block write. SMBus 2.0 5.5.7</p>
<pre><code>S Addr Wr [A] i2cReg [A] count [A]


   buf0 [A] buf1 [A] ... [A] bufn [A] P


</code></pre>
<ul>
<li></li>
<li><p>This reads a block of up to 32 bytes from the specified register of the device associated with handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to i2cOpen


i2cReg: 0-255, the register to read


   buf: an array to receive the read data


</code></pre>
<p><br />
</p>
<p><br />
The amount of returned data is set by the device.</p>
<p><br />
</p>
<p><br />
Returns the number of bytes read (&gt;=0) if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or PI_I2C_READ_FAILED.</p>
<p><br />
</p>
<p><br />
Block read. SMBus 2.0 5.5.7</p>
<pre><code>S Addr Wr [A] i2cReg [A]


   S Addr Rd [A] [Count] A [buf0] A [buf1] A ... A [bufn] NA P


</code></pre>
<ul>
<li></li>
<li><p>This writes data bytes to the specified register of the device associated with handle and reads a device specified number of bytes of data in return.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to i2cOpen


i2cReg: 0-255, the register to write/read


   buf: an array with the data to send and to receive the read data


 count: 1-32, the number of bytes to write


</code></pre>
<p><br />
</p>
<p><br />
Returns the number of bytes read (&gt;=0) if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or PI_I2C_READ_FAILED.</p>
<p><br />
</p>
<p><br />
The SMBus 2.0 documentation states that a minimum of 1 byte may be sent and a minimum of 1 byte may be received. The total number of bytes sent/received must be 32 or less.</p>
<p><br />
</p>
<p><br />
Block write-block read. SMBus 2.0 5.5.8</p>
<pre><code>S Addr Wr [A] i2cReg [A] count [A] buf0 [A] ... bufn [A]


   S Addr Rd [A] [Count] A [buf0] A ... [bufn] A P


</code></pre>
<ul>
<li></li>
<li><p>This reads count bytes from the specified register of the device associated with handle . The count may be 1-32.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to i2cOpen


i2cReg: 0-255, the register to read


   buf: an array to receive the read data


 count: 1-32, the number of bytes to read


</code></pre>
<p><br />
</p>
<p><br />
Returns the number of bytes read (&gt;0) if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or PI_I2C_READ_FAILED.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>S Addr Wr [A] i2cReg [A]


   S Addr Rd [A] [buf0] A [buf1] A ... A [bufn] NA P


</code></pre>
<ul>
<li></li>
<li><p>This writes 1 to 32 bytes to the specified register of the device associated with handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to i2cOpen


i2cReg: 0-255, the register to write


   buf: the data to write


 count: 1-32, the number of bytes to write


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or PI_I2C_WRITE_FAILED.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>S Addr Wr [A] i2cReg [A] buf0 [A] buf1 [A] ... [A] bufn [A] P


</code></pre>
<ul>
<li></li>
<li><p>This reads count bytes from the raw device into buf.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to i2cOpen


   buf: an array to receive the read data bytes


 count: &gt;0, the number of bytes to read


</code></pre>
<p><br />
</p>
<p><br />
Returns count (&gt;0) if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or PI_I2C_READ_FAILED.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>S Addr Rd [A] [buf0] A [buf1] A ... A [bufn] NA P


</code></pre>
<ul>
<li></li>
<li><p>This writes count bytes from buf to the raw device.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to i2cOpen


   buf: an array containing the data bytes to write


 count: &gt;0, the number of bytes to write


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or PI_I2C_WRITE_FAILED.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>S Addr Wr [A] buf0 [A] buf1 [A] ... [A] bufn [A] P


</code></pre>
<ul>
<li></li>
<li><p>This sets the I2C (i2c-bcm2708) module "use combined transactions" parameter on or off.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>setting: 0 to set the parameter off, non-zero to set it on


</code></pre>
<p><br />
</p>
<p><br />
</p>
<p><br />
</p>
<p><br />
NOTE: when the flag is on a write followed by a read to the same slave address will use a repeated start (rather than a stop/start).</p>
<ul>
<li></li>
<li><p>This function executes multiple I2C segments in one transaction by calling the I2C_RDWR ioctl.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code> handle: &gt;=0, as returned by a call to i2cOpen


   segs: an array of I2C segments


numSegs: &gt;0, the number of I2C segments


</code></pre>
<p><br />
</p>
<p><br />
Returns the number of segments if OK, otherwise PI_BAD_I2C_SEG.</p>
<ul>
<li></li>
<li><p>This function executes a sequence of I2C operations. The operations to be performed are specified by the contents of inBuf which contains the concatenated command codes and associated data.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to i2cOpen


 inBuf: pointer to the concatenated I2C commands, see below


 inLen: size of command buffer


outBuf: pointer to buffer to hold returned data


outLen: size of output buffer


</code></pre>
<p><br />
</p>
<p><br />
Returns &gt;= 0 if OK (the number of bytes read), otherwise PI_BAD_HANDLE, PI_BAD_POINTER, PI_BAD_I2C_CMD, PI_BAD_I2C_RLEN. PI_BAD_I2C_WLEN, or PI_BAD_I2C_SEG.</p>
<p><br />
</p>
<p><br />
The following command codes are supported:</p>
<p><br />
</p>
<p><br />
Name Cmd &amp; Data Meaning<br />
End 0 No more commands<br />
Escape 1 Next P is two bytes<br />
On 2 Switch combined flag on<br />
Off 3 Switch combined flag off<br />
Address 4 P Set I2C address to P<br />
Flags 5 lsb msb Set I2C flags to lsb + (msb &lt;&lt; 8)<br />
Read 6 P Read P bytes of data<br />
Write 7 P ... Write P bytes of data<br />
</p>
<p><br />
</p>
<p><br />
The address, read, and write commands take a parameter P. Normally P is one byte (0-255). If the command is preceded by the Escape command then P is two bytes (0-65535, least significant byte first).</p>
<p><br />
</p>
<p><br />
The address defaults to that associated with the handle. The flags default to 0. The address and flags maintain their previous value until updated.</p>
<p><br />
</p>
<p><br />
The returned I2C data is stored in consecutive locations of outBuf.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>Set address 0x53, write 0x32, read 6 bytes


Set address 0x1E, write 0x03, read 6 bytes


Set address 0x68, write 0x1B, read 8 bytes


End





0x04 0x53   0x07 0x01 0x32   0x06 0x06


0x04 0x1E   0x07 0x01 0x03   0x06 0x06


0x04 0x68   0x07 0x01 0x1B   0x06 0x08


0x00


</code></pre>
<ul>
<li></li>
<li><p>This function selects a pair of GPIO for bit banging I2C at a specified baud rate.</p></li>
</ul>
<p><br />
</p>
<p><br />
Bit banging I2C allows for certain operations which are not possible with the standard I2C driver.</p>
<p><br />
</p>
<p><br />
o baud rates as low as 50<br />
o repeated starts<br />
o clock stretching<br />
o I2C on any pair of spare GPIO</p>
<p><br />
</p>
<p><br />
</p>
<pre><code> SDA: 0-31


 SCL: 0-31


baud: 50-500000


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_USER_GPIO, PI_BAD_I2C_BAUD, or PI_GPIO_IN_USE.</p>
<p><br />
</p>
<p><br />
NOTE:</p>
<p><br />
</p>
<p><br />
The GPIO used for SDA and SCL must have pull-ups to 3V3 connected. As a guide the hardware pull-ups on pins 3 and 5 are 1k8 in value.</p>
<ul>
<li></li>
<li><p>This function stops bit banging I2C on a pair of GPIO previously opened with <strong>bbI2COpen</strong>.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>SDA: 0-31, the SDA GPIO used in a prior call to bbI2COpen


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_USER_GPIO, or PI_NOT_I2C_GPIO.</p>
<ul>
<li></li>
<li><p>This function executes a sequence of bit banged I2C operations. The operations to be performed are specified by the contents of inBuf which contains the concatenated command codes and associated data.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>   SDA: 0-31 (as used in a prior call to bbI2COpen)


 inBuf: pointer to the concatenated I2C commands, see below


 inLen: size of command buffer


outBuf: pointer to buffer to hold returned data


outLen: size of output buffer


</code></pre>
<p><br />
</p>
<p><br />
Returns &gt;= 0 if OK (the number of bytes read), otherwise PI_BAD_USER_GPIO, PI_NOT_I2C_GPIO, PI_BAD_POINTER, PI_BAD_I2C_CMD, PI_BAD_I2C_RLEN, PI_BAD_I2C_WLEN, PI_I2C_READ_FAILED, or PI_I2C_WRITE_FAILED.</p>
<p><br />
</p>
<p><br />
The following command codes are supported:</p>
<p><br />
</p>
<p><br />
Name Cmd &amp; Data Meaning<br />
End 0 No more commands<br />
Escape 1 Next P is two bytes<br />
Start 2 Start condition<br />
Stop 3 Stop condition<br />
Address 4 P Set I2C address to P<br />
Flags 5 lsb msb Set I2C flags to lsb + (msb &lt;&lt; 8)<br />
Read 6 P Read P bytes of data<br />
Write 7 P ... Write P bytes of data<br />
</p>
<p><br />
</p>
<p><br />
The address, read, and write commands take a parameter P. Normally P is one byte (0-255). If the command is preceded by the Escape command then P is two bytes (0-65535, least significant byte first).</p>
<p><br />
</p>
<p><br />
The address and flags default to 0. The address and flags maintain their previous value until updated.</p>
<p><br />
</p>
<p><br />
No flags are currently defined.</p>
<p><br />
</p>
<p><br />
The returned I2C data is stored in consecutive locations of outBuf.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>Set address 0x53


start, write 0x32, (re)start, read 6 bytes, stop


Set address 0x1E


start, write 0x03, (re)start, read 6 bytes, stop


Set address 0x68


start, write 0x1B, (re)start, read 8 bytes, stop


End





0x04 0x53


0x02 0x07 0x01 0x32   0x02 0x06 0x06 0x03





0x04 0x1E


0x02 0x07 0x01 0x03   0x02 0x06 0x06 0x03





0x04 0x68


0x02 0x07 0x01 0x1B   0x02 0x06 0x08 0x03





0x00


</code></pre>
<ul>
<li></li>
<li><p>This function provides a low-level interface to the SPI/I2C Slave peripheral on the BCM chip.</p></li>
</ul>
<p><br />
</p>
<p><br />
This peripheral allows the Pi to act as a hardware slave device on an I2C or SPI bus.</p>
<p><br />
</p>
<p><br />
This is not a bit bang version and as such is OS timing independent. The bus timing is handled directly by the chip.</p>
<p><br />
</p>
<p><br />
The output process is simple. You simply append data to the FIFO buffer on the chip. This works like a queue, you add data to the queue and the master removes it.</p>
<p><br />
</p>
<p><br />
The function sets the BSC mode, writes any data in the transmit buffer to the BSC transmit FIFO, and copies any data in the BSC receive FIFO to the receive buffer.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>bsc_xfer:= a structure defining the transfer





typedef struct


{


   uint32_t control;          // Write


   int rxCnt;                 // Read only


   char rxBuf[BSC_FIFO_SIZE]; // Read only


   int txCnt;                 // Write


   char txBuf[BSC_FIFO_SIZE]; // Write


} bsc_xfer_t;


</code></pre>
<p><br />
</p>
<p><br />
To start a transfer set control (see below), copy the bytes to be added to the transmit FIFO (if any) to txBuf and set txCnt to the number of copied bytes.</p>
<p><br />
</p>
<p><br />
Upon return rxCnt will be set to the number of received bytes placed in rxBuf.</p>
<p><br />
</p>
<p><br />
Note that the control word sets the BSC mode. The BSC will stay in that mode until a different control word is sent.</p>
<p><br />
</p>
<p><br />
GPIO used for models other than those based on the BCM2711.</p>
<p><br />
</p>
<p><br />
SDA SCL MOSI SCLK MISO CE<br />
I2C 18 19 - - - -<br />
SPI - - 20 19 18 21<br />
</p>
<p><br />
</p>
<p><br />
GPIO used for models based on the BCM2711 (e.g. the Pi4B).</p>
<p><br />
</p>
<p><br />
SDA SCL MOSI SCLK MISO CE<br />
I2C 10 11 - - - -<br />
SPI - - 9 11 10 8<br />
</p>
<p><br />
</p>
<p><br />
When a zero control word is received the used GPIO will be reset to INPUT mode.</p>
<p><br />
</p>
<p><br />
The returned function value is the status of the transfer (see below).</p>
<p><br />
</p>
<p><br />
If there was an error the status will be less than zero (and will contain the error code).</p>
<p><br />
</p>
<p><br />
The most significant word of the returned status contains the number of bytes actually copied from txBuf to the BSC transmit FIFO (may be less than requested if the FIFO already contained untransmitted data).</p>
<p><br />
</p>
<p><br />
control consists of the following bits.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0


 a  a  a  a  a  a  a  -  - IT HC TF IR RE TE BK EC ES PL PH I2 SP EN


</code></pre>
<p><br />
</p>
<p><br />
Bits 0-13 are copied unchanged to the BSC CR register. See pages 163-165 of the Broadcom peripherals document for full details.</p>
<p><br />
</p>
<p><br />
aaaaaaa defines the I2C slave address (only relevant in I2C mode)<br />
IT invert transmit status flags<br />
HC enable host control<br />
TF enable test FIFO<br />
IR invert receive status flags<br />
RE enable receive<br />
TE enable transmit<br />
BK abort operation and clear FIFOs<br />
EC send control register as first I2C byte<br />
ES send status register as first I2C byte<br />
PL set SPI polarity high<br />
PH set SPI phase high<br />
I2 enable I2C mode<br />
SP enable SPI mode<br />
EN enable BSC peripheral<br />
</p>
<p><br />
</p>
<p><br />
The returned status has the following format</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0


 S  S  S  S  S  R  R  R  R  R  T  T  T  T  T RB TE RF TF RE TB


</code></pre>
<p><br />
</p>
<p><br />
Bits 0-15 are copied unchanged from the BSC FR register. See pages 165-166 of the Broadcom peripherals document for full details.</p>
<p><br />
</p>
<p><br />
SSSSS number of bytes successfully copied to transmit FIFO<br />
RRRRR number of bytes in receive FIFO<br />
TTTTT number of bytes in transmit FIFO<br />
RB receive busy<br />
TE transmit FIFO empty<br />
RF receive FIFO full<br />
TF transmit FIFO full<br />
RE receive FIFO empty<br />
TB transmit busy<br />
</p>
<p><br />
</p>
<p><br />
The following example shows how to configure the BSC peripheral as an I2C slave with address 0x13 and send four bytes.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>bsc_xfer_t xfer;





xfer.control = (0x13&lt;&lt;16) | 0x305;





memcpy(xfer.txBuf, &quot;ABCD&quot;, 4);


xfer.txCnt = 4;





status = bscXfer(&amp;xfer);





if (status &gt;= 0)


{


   // process transfer


}


</code></pre>
<p><br />
</p>
<p><br />
The BSC slave in SPI mode deserializes data from the MOSI pin into its receiver/FIFO when the LSB of the first byte is a 0. No data is output on the MISO pin. When the LSB of the first byte on MOSI is a 1, the transmitter/FIFO data is serialized onto the MISO pin while all other data on the MOSI pin is ignored.</p>
<p><br />
</p>
<p><br />
The BK bit of the BSC control register is non-functional when in the SPI mode. The transmitter along with its FIFO can be dequeued by successively disabling and re-enabling the TE bit on the BSC control register while in SPI mode.</p>
<ul>
<li></li>
<li><p>This function selects a set of GPIO for bit banging SPI with a specified baud rate and mode.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>      CS: 0-31


    MISO: 0-31


    MOSI: 0-31


    SCLK: 0-31


    baud: 50-250000


spiFlags: see below


</code></pre>
<p><br />
</p>
<p><br />
spiFlags consists of the least significant 22 bits.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0


 0  0  0  0  0  0  R  T  0  0  0  0  0  0  0  0  0  0  0  p  m  m


</code></pre>
<p><br />
</p>
<p><br />
mm defines the SPI mode, defaults to 0</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>Mode CPOL CPHA


 0    0    0


 1    0    1


 2    1    0


 3    1    1


</code></pre>
<p><br />
</p>
<p><br />
p is 0 if CS is active low (default) and 1 for active high.</p>
<p><br />
</p>
<p><br />
T is 1 if the least significant bit is transmitted on MOSI first, the default (0) shifts the most significant bit out first.</p>
<p><br />
</p>
<p><br />
R is 1 if the least significant bit is received on MISO first, the default (0) receives the most significant bit first.</p>
<p><br />
</p>
<p><br />
The other bits in flags should be set to zero.</p>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_USER_GPIO, PI_BAD_SPI_BAUD, or PI_GPIO_IN_USE.</p>
<p><br />
</p>
<p><br />
If more than one device is connected to the SPI bus (defined by SCLK, MOSI, and MISO) each must have its own CS.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>bbSPIOpen(10, MISO, MOSI, SCLK, 10000, 0); // device 1


bbSPIOpen(11, MISO, MOSI, SCLK, 20000, 3); // device 2


</code></pre>
<ul>
<li></li>
<li><p>This function stops bit banging SPI on a set of GPIO opened with <strong>bbSPIOpen</strong>.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>CS: 0-31, the CS GPIO used in a prior call to bbSPIOpen


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_USER_GPIO, or PI_NOT_SPI_GPIO.</p>
<ul>
<li></li>
<li><p>This function executes a bit banged SPI transfer.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>    CS: 0-31 (as used in a prior call to bbSPIOpen)


 inBuf: pointer to buffer to hold data to be sent


outBuf: pointer to buffer to hold returned data


 count: size of data transfer


</code></pre>
<p><br />
</p>
<p><br />
Returns &gt;= 0 if OK (the number of bytes read), otherwise PI_BAD_USER_GPIO, PI_NOT_SPI_GPIO or PI_BAD_POINTER.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>// gcc -Wall -pthread -o bbSPIx_test bbSPIx_test.c -lpigpio


// sudo ./bbSPIx_test








#include &lt;stdio.h&gt;





#include &quot;pigpio.h&quot;





#define CE0 5


#define CE1 6


#define MISO 13


#define MOSI 19


#define SCLK 12





int main(int argc, char *argv[])


{


   int i, count, set_val, read_val;


   unsigned char inBuf[3];


   char cmd1[] = {0, 0};


   char cmd2[] = {12, 0};


   char cmd3[] = {1, 128, 0};





   if (gpioInitialise() &lt; 0)


   {


      fprintf(stderr, &quot;pigpio initialisation failed.);


      return 1;


   }





   bbSPIOpen(CE0, MISO, MOSI, SCLK, 10000, 0); // MCP4251 DAC


   bbSPIOpen(CE1, MISO, MOSI, SCLK, 20000, 3); // MCP3008 ADC





   for (i=0; i&lt;256; i++)


   {


      cmd1[1] = i;





      count = bbSPIXfer(CE0, cmd1, (char *)inBuf, 2); // &gt; DAC





      if (count == 2)


      {


         count = bbSPIXfer(CE0, cmd2, (char *)inBuf, 2); // &lt; DAC





         if (count == 2)


         {


            set_val = inBuf[1];





            count = bbSPIXfer(CE1, cmd3, (char *)inBuf, 3); // &lt; ADC





            if (count == 3)


            {


               read_val = ((inBuf[1]&amp;3)&lt;&lt;8) | inBuf[2];


               printf(&quot;%d %d, set_val, read_val);


            }


         }


      }


   }





   bbSPIClose(CE0);


   bbSPIClose(CE1);





   gpioTerminate();





   return 0;


}


</code></pre>
<ul>
<li></li>
<li><p>This function returns a handle for the SPI device on the channel. Data will be transferred at baud bits per second. The flags may be used to modify the default behaviour of 4-wire operation, mode 0, active low chip select.</p></li>
</ul>
<p><br />
</p>
<p><br />
The Pi has two SPI peripherals: main and auxiliary.</p>
<p><br />
</p>
<p><br />
The main SPI has two chip selects (channels), the auxiliary has three.</p>
<p><br />
</p>
<p><br />
The auxiliary SPI is available on all models but the A and B.</p>
<p><br />
</p>
<p><br />
The GPIO used are given in the following table.</p>
<p><br />
</p>
<p><br />
MISO MOSI SCLK CE0 CE1 CE2<br />
Main SPI 9 10 11 8 7 -<br />
Aux SPI 19 20 21 18 17 16<br />
</p>
<p><br />
</p>
<p><br />
</p>
<pre><code> spiChan: 0-1 (0-2 for the auxiliary SPI)


    baud: 32K-125M (values above 30M are unlikely to work)


spiFlags: see below


</code></pre>
<p><br />
</p>
<p><br />
Returns a handle (&gt;=0) if OK, otherwise PI_BAD_SPI_CHANNEL, PI_BAD_SPI_SPEED, PI_BAD_FLAGS, PI_NO_AUX_SPI, or PI_SPI_OPEN_FAILED.</p>
<p><br />
</p>
<p><br />
spiFlags consists of the least significant 22 bits.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0


 b  b  b  b  b  b  R  T  n  n  n  n  W  A u2 u1 u0 p2 p1 p0  m  m


</code></pre>
<p><br />
</p>
<p><br />
mm defines the SPI mode.</p>
<p><br />
</p>
<p><br />
Warning: modes 1 and 3 do not appear to work on the auxiliary SPI.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>Mode POL PHA


 0    0   0


 1    0   1


 2    1   0


 3    1   1


</code></pre>
<p><br />
</p>
<p><br />
px is 0 if CEx is active low (default) and 1 for active high.</p>
<p><br />
</p>
<p><br />
ux is 0 if the CEx GPIO is reserved for SPI (default) and 1 otherwise.</p>
<p><br />
</p>
<p><br />
A is 0 for the main SPI, 1 for the auxiliary SPI.</p>
<p><br />
</p>
<p><br />
W is 0 if the device is not 3-wire, 1 if the device is 3-wire. Main SPI only.</p>
<p><br />
</p>
<p><br />
nnnn defines the number of bytes (0-15) to write before switching the MOSI line to MISO to read data. This field is ignored if W is not set. Main SPI only.</p>
<p><br />
</p>
<p><br />
T is 1 if the least significant bit is transmitted on MOSI first, the default (0) shifts the most significant bit out first. Auxiliary SPI only.</p>
<p><br />
</p>
<p><br />
R is 1 if the least significant bit is received on MISO first, the default (0) receives the most significant bit first. Auxiliary SPI only.</p>
<p><br />
</p>
<p><br />
bbbbbb defines the word size in bits (0-32). The default (0) sets 8 bits per word. Auxiliary SPI only.</p>
<p><br />
</p>
<p><br />
The <strong>spiRead</strong>, <strong>spiWrite</strong>, and <strong>spiXfer</strong> functions transfer data packed into 1, 2, or 4 bytes according to the word size in bits.</p>
<p><br />
</p>
<p><br />
For bits 1-8 there will be one byte per word.<br />
For bits 9-16 there will be two bytes per word.<br />
For bits 17-32 there will be four bytes per word.</p>
<p><br />
</p>
<p><br />
Multi-byte transfers are made in least significant byte first order.</p>
<p><br />
</p>
<p><br />
E.g. to transfer 32 11-bit words buf should contain 64 bytes and count should be 64.</p>
<p><br />
</p>
<p><br />
E.g. to transfer the 14 bit value 0x1ABC send the bytes 0xBC followed by 0x1A.</p>
<p><br />
</p>
<p><br />
The other bits in flags should be set to zero.</p>
<ul>
<li></li>
<li><p>This functions closes the SPI device identified by the handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to spiOpen


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_HANDLE.</p>
<ul>
<li></li>
<li><p>This function reads count bytes of data from the SPI device associated with the handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to spiOpen


   buf: an array to receive the read data bytes


 count: the number of bytes to read


</code></pre>
<p><br />
</p>
<p><br />
Returns the number of bytes transferred if OK, otherwise PI_BAD_HANDLE, PI_BAD_SPI_COUNT, or PI_SPI_XFER_FAILED.</p>
<ul>
<li></li>
<li><p>This function writes count bytes of data from buf to the SPI device associated with the handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to spiOpen


   buf: the data bytes to write


 count: the number of bytes to write


</code></pre>
<p><br />
</p>
<p><br />
Returns the number of bytes transferred if OK, otherwise PI_BAD_HANDLE, PI_BAD_SPI_COUNT, or PI_SPI_XFER_FAILED.</p>
<ul>
<li></li>
<li><p>This function transfers count bytes of data from txBuf to the SPI device associated with the handle. Simultaneously count bytes of data are read from the device and placed in rxBuf.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to spiOpen


 txBuf: the data bytes to write


 rxBuf: the received data bytes


 count: the number of bytes to transfer


</code></pre>
<p><br />
</p>
<p><br />
Returns the number of bytes transferred if OK, otherwise PI_BAD_HANDLE, PI_BAD_SPI_COUNT, or PI_SPI_XFER_FAILED.</p>
<ul>
<li></li>
<li><p>This function opens a serial device at a specified baud rate and with specified flags. The device name must start with /dev/tty or /dev/serial.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>  sertty: the serial device to open


    baud: the baud rate in bits per second, see below


serFlags: 0


</code></pre>
<p><br />
</p>
<p><br />
Returns a handle (&gt;=0) if OK, otherwise PI_NO_HANDLE, or PI_SER_OPEN_FAILED.</p>
<p><br />
</p>
<p><br />
The baud rate must be one of 50, 75, 110, 134, 150, 200, 300, 600, 1200, 1800, 2400, 4800, 9600, 19200, 38400, 57600, 115200, or 230400.</p>
<p><br />
</p>
<p><br />
No flags are currently defined. This parameter should be set to zero.</p>
<ul>
<li></li>
<li><p>This function closes the serial device associated with handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to serOpen


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_HANDLE.</p>
<ul>
<li></li>
<li><p>This function writes bVal to the serial port associated with handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to serOpen


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or PI_SER_WRITE_FAILED.</p>
<ul>
<li></li>
<li><p>This function reads a byte from the serial port associated with handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to serOpen


</code></pre>
<p><br />
</p>
<p><br />
Returns the read byte (&gt;=0) if OK, otherwise PI_BAD_HANDLE, PI_SER_READ_NO_DATA, or PI_SER_READ_FAILED.</p>
<p><br />
</p>
<p><br />
If no data is ready PI_SER_READ_NO_DATA is returned.</p>
<ul>
<li></li>
<li><p>This function writes count bytes from buf to the the serial port associated with handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to serOpen


   buf: the array of bytes to write


 count: the number of bytes to write


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or PI_SER_WRITE_FAILED.</p>
<ul>
<li></li>
<li><p>This function reads up count bytes from the the serial port associated with handle and writes them to buf.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to serOpen


   buf: an array to receive the read data


 count: the maximum number of bytes to read


</code></pre>
<p><br />
</p>
<p><br />
Returns the number of bytes read (&gt;0=) if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or PI_SER_READ_NO_DATA.</p>
<p><br />
</p>
<p><br />
If no data is ready zero is returned.</p>
<ul>
<li></li>
<li><p>This function returns the number of bytes available to be read from the device associated with handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to serOpen


</code></pre>
<p><br />
</p>
<p><br />
Returns the number of bytes of data available (&gt;=0) if OK, otherwise PI_BAD_HANDLE.</p>
<ul>
<li></li>
<li><p>This function sends a trigger pulse to a GPIO. The GPIO is set to level for pulseLen microseconds and then reset to not level.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_gpio: 0-31


 pulseLen: 1-100


    level: 0,1


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_USER_GPIO, PI_BAD_LEVEL, or PI_BAD_PULSELEN.</p>
<ul>
<li></li>
<li><p>Sets a watchdog for a GPIO.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_gpio: 0-31


  timeout: 0-60000


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_USER_GPIO or PI_BAD_WDOG_TIMEOUT.</p>
<p><br />
</p>
<p><br />
The watchdog is nominally in milliseconds.</p>
<p><br />
</p>
<p><br />
One watchdog may be registered per GPIO.</p>
<p><br />
</p>
<p><br />
The watchdog may be cancelled by setting timeout to 0.</p>
<p><br />
</p>
<p><br />
Until cancelled a timeout will be reported every timeout milliseconds after the last GPIO activity.</p>
<p><br />
</p>
<p><br />
In particular:</p>
<p><br />
</p>
<p><br />
1) any registered alert function for the GPIO will be called with the level set to PI_TIMEOUT.</p>
<p><br />
</p>
<p><br />
2) any notification for the GPIO will have a report written to the fifo with the flags set to indicate a watchdog timeout.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>void aFunction(int gpio, int level, uint32_t tick)


{


   printf(&quot;GPIO %d became %d at %d&quot;, gpio, level, tick);


}





// call aFunction whenever GPIO 4 changes state


gpioSetAlertFunc(4, aFunction);





//  or approximately every 5 millis


gpioSetWatchdog(4, 5);


</code></pre>
<ul>
<li></li>
<li><p>Sets a noise filter on a GPIO.</p></li>
</ul>
<p><br />
</p>
<p><br />
Level changes on the GPIO are ignored until a level which has been stable for <strong>steady</strong> microseconds is detected. Level changes on the GPIO are then reported for <strong>active</strong> microseconds after which the process repeats.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_gpio: 0-31


   steady: 0-300000


   active: 0-1000000


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_USER_GPIO, or PI_BAD_FILTER.</p>
<p><br />
</p>
<p><br />
This filter affects the GPIO samples returned to callbacks set up with <strong>gpioSetAlertFunc</strong>, <strong>gpioSetAlertFuncEx</strong>, <strong>gpioSetGetSamplesFunc</strong>, and <strong>gpioSetGetSamplesFuncEx</strong>.</p>
<p><br />
</p>
<p><br />
It does not affect interrupts set up with <strong>gpioSetISRFunc</strong>, <strong>gpioSetISRFuncEx</strong>, or levels read by <strong>gpioRead</strong>, <strong>gpioRead_Bits_0_31</strong>, or <strong>gpioRead_Bits_32_53</strong>.</p>
<p><br />
</p>
<p><br />
Level changes before and after the active period may be reported. Your software must be designed to cope with such reports.</p>
<ul>
<li></li>
<li><p>Sets a glitch filter on a GPIO.</p></li>
</ul>
<p><br />
</p>
<p><br />
Level changes on the GPIO are not reported unless the level has been stable for at least <strong>steady</strong> microseconds. The level is then reported. Level changes of less than <strong>steady</strong> microseconds are ignored.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_gpio: 0-31


   steady: 0-300000


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_USER_GPIO, or PI_BAD_FILTER.</p>
<p><br />
</p>
<p><br />
This filter affects the GPIO samples returned to callbacks set up with <strong>gpioSetAlertFunc</strong>, <strong>gpioSetAlertFuncEx</strong>, <strong>gpioSetGetSamplesFunc</strong>, and <strong>gpioSetGetSamplesFuncEx</strong>.</p>
<p><br />
</p>
<p><br />
It does not affect interrupts set up with <strong>gpioSetISRFunc</strong>, <strong>gpioSetISRFuncEx</strong>, or levels read by <strong>gpioRead</strong>, <strong>gpioRead_Bits_0_31</strong>, or <strong>gpioRead_Bits_32_53</strong>.</p>
<p><br />
</p>
<p><br />
Each (stable) edge will be timestamped <strong>steady</strong> microseconds after it was first detected.</p>
<ul>
<li></li>
<li><p>Registers a function to be called (a callback) every millisecond with the latest GPIO samples.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>   f: the function to call


bits: the GPIO of interest


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK.</p>
<p><br />
</p>
<p><br />
The function is passed a pointer to the samples (an array of <strong>gpioSample_t</strong>), and the number of samples.</p>
<p><br />
</p>
<p><br />
Only one function can be registered.</p>
<p><br />
</p>
<p><br />
The callback may be cancelled by passing NULL as the function.</p>
<p><br />
</p>
<p><br />
The samples returned will be the union of bits, plus any active alerts, plus any active notifications.</p>
<p><br />
</p>
<p><br />
e.g. if there are alerts for GPIO 7, 8, and 9, notifications for GPIO 8, 10, 23, 24, and bits is (1&lt;&lt;23)|(1&lt;&lt;17) then samples for GPIO 7, 8, 9, 10, 17, 23, and 24 will be reported.</p>
<ul>
<li></li>
<li><p>Registers a function to be called (a callback) every millisecond with the latest GPIO samples.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>       f: the function to call


    bits: the GPIO of interest


userdata: a pointer to arbitrary user data


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK.</p>
<p><br />
</p>
<p><br />
The function is passed a pointer to the samples (an array of <strong>gpioSample_t</strong>), the number of samples, and the userdata pointer.</p>
<p><br />
</p>
<p><br />
Only one of <strong>gpioGetSamplesFunc</strong> or <strong>gpioGetSamplesFuncEx</strong> can be registered.</p>
<p><br />
</p>
<p><br />
See <strong>gpioSetGetSamplesFunc</strong> for further details.</p>
<ul>
<li></li>
<li><p>Registers a function to be called (a callback) every millis milliseconds.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code> timer: 0-9


millis: 10-60000


     f: the function to call


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_TIMER, PI_BAD_MS, or PI_TIMER_FAILED.</p>
<p><br />
</p>
<p><br />
10 timers are supported numbered 0 to 9.</p>
<p><br />
</p>
<p><br />
One function may be registered per timer.</p>
<p><br />
</p>
<p><br />
The timer may be cancelled by passing NULL as the function.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>void bFunction(void)


{


   printf(&quot;two seconds have elapsed&quot;);


}





// call bFunction every 2000 milliseconds


gpioSetTimerFunc(0, 2000, bFunction);


</code></pre>
<ul>
<li></li>
<li><p>Registers a function to be called (a callback) every millis milliseconds.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>   timer: 0-9.


  millis: 10-60000


       f: the function to call


userdata: a pointer to arbitrary user data


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_TIMER, PI_BAD_MS, or PI_TIMER_FAILED.</p>
<p><br />
</p>
<p><br />
The function is passed the userdata pointer.</p>
<p><br />
</p>
<p><br />
Only one of <strong>gpioSetTimerFunc</strong> or <strong>gpioSetTimerFuncEx</strong> can be registered per timer.</p>
<p><br />
</p>
<p><br />
See <strong>gpioSetTimerFunc</strong> for further details.</p>
<ul>
<li></li>
<li><p>Starts a new thread of execution with f as the main routine.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>       f: the main function for the new thread


userdata: a pointer to arbitrary user data


</code></pre>
<p><br />
</p>
<p><br />
Returns a pointer to pthread_t if OK, otherwise NULL.</p>
<p><br />
</p>
<p><br />
The function is passed the single argument arg.</p>
<p><br />
</p>
<p><br />
The thread can be cancelled by passing the pointer to pthread_t to <strong>gpioStopThread</strong>.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>#include &lt;stdio.h&gt;


#include &lt;pigpio.h&gt;





void *myfunc(void *arg)


{


   while (1)


   {


      printf(&quot;%s&quot;, arg);


      sleep(1);


   }


}





int main(int argc, char *argv[])


{


   pthread_t *p1, *p2, *p3;





   if (gpioInitialise() &lt; 0) return 1;





   p1 = gpioStartThread(myfunc, &quot;thread 1&quot;); sleep(3);





   p2 = gpioStartThread(myfunc, &quot;thread 2&quot;); sleep(3);





   p3 = gpioStartThread(myfunc, &quot;thread 3&quot;); sleep(3);





   gpioStopThread(p3); sleep(3);





   gpioStopThread(p2); sleep(3);





   gpioStopThread(p1); sleep(3);





   gpioTerminate();


}


</code></pre>
<ul>
<li></li>
<li><p>Cancels the thread pointed at by pth.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>pth: a thread pointer returned by gpioStartThread


</code></pre>
<p><br />
</p>
<p><br />
No value is returned.</p>
<p><br />
</p>
<p><br />
The thread to be stopped should have been started with <strong>gpioStartThread</strong>.</p>
<ul>
<li></li>
<li><p>This function stores a null terminated script for later execution.</p></li>
</ul>
<p><br />
</p>
<p><br />
See <strong>http://abyz.me.uk/rpi/pigpio/pigs.html#Scripts</strong> for details.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>script: the text of the script


</code></pre>
<p><br />
</p>
<p><br />
The function returns a script id if the script is valid, otherwise PI_BAD_SCRIPT.</p>
<ul>
<li></li>
<li><p>This function runs a stored script.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>script_id: &gt;=0, as returned by gpioStoreScript


   numPar: 0-10, the number of parameters


    param: an array of parameters


</code></pre>
<p><br />
</p>
<p><br />
The function returns 0 if OK, otherwise PI_BAD_SCRIPT_ID, or PI_TOO_MANY_PARAM.</p>
<p><br />
</p>
<p><br />
param is an array of up to 10 parameters which may be referenced in the script as p0 to p9.</p>
<ul>
<li></li>
<li><p>This function sets the parameters of a script. The script may or may not be running. The first numPar parameters of the script are overwritten with the new values.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>script_id: &gt;=0, as returned by gpioStoreScript


   numPar: 0-10, the number of parameters


    param: an array of parameters


</code></pre>
<p><br />
</p>
<p><br />
The function returns 0 if OK, otherwise PI_BAD_SCRIPT_ID, or PI_TOO_MANY_PARAM.</p>
<p><br />
</p>
<p><br />
param is an array of up to 10 parameters which may be referenced in the script as p0 to p9.</p>
<ul>
<li></li>
<li><p>This function returns the run status of a stored script as well as the current values of parameters 0 to 9.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>script_id: &gt;=0, as returned by gpioStoreScript


    param: an array to hold the returned 10 parameters


</code></pre>
<p><br />
</p>
<p><br />
The function returns greater than or equal to 0 if OK, otherwise PI_BAD_SCRIPT_ID.</p>
<p><br />
</p>
<p><br />
The run status may be</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>PI_SCRIPT_INITING


PI_SCRIPT_HALTED


PI_SCRIPT_RUNNING


PI_SCRIPT_WAITING


PI_SCRIPT_FAILED


</code></pre>
<p><br />
</p>
<p><br />
The current value of script parameters 0 to 9 are returned in param.</p>
<ul>
<li></li>
<li><p>This function stops a running script.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>script_id: &gt;=0, as returned by gpioStoreScript


</code></pre>
<p><br />
</p>
<p><br />
The function returns 0 if OK, otherwise PI_BAD_SCRIPT_ID.</p>
<ul>
<li></li>
<li><p>This function deletes a stored script.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>script_id: &gt;=0, as returned by gpioStoreScript


</code></pre>
<p><br />
</p>
<p><br />
The function returns 0 if OK, otherwise PI_BAD_SCRIPT_ID.</p>
<ul>
<li></li>
<li><p>Registers a function to be called (a callback) when a signal occurs.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>signum: 0-63


     f: the callback function


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_SIGNUM.</p>
<p><br />
</p>
<p><br />
The function is passed the signal number.</p>
<p><br />
</p>
<p><br />
One function may be registered per signal.</p>
<p><br />
</p>
<p><br />
The callback may be cancelled by passing NULL.</p>
<p><br />
</p>
<p><br />
By default all signals are treated as fatal and cause the library to call gpioTerminate and then exit.</p>
<ul>
<li></li>
<li><p>Registers a function to be called (a callback) when a signal occurs.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>  signum: 0-63


       f: the callback function


userdata: a pointer to arbitrary user data


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_SIGNUM.</p>
<p><br />
</p>
<p><br />
The function is passed the signal number and the userdata pointer.</p>
<p><br />
</p>
<p><br />
Only one of gpioSetSignalFunc or gpioSetSignalFuncEx can be registered per signal.</p>
<p><br />
</p>
<p><br />
See gpioSetSignalFunc for further details.</p>
<ul>
<li></li>
<li><p>Returns the current level of GPIO 0-31.</p></li>
</ul>
<ul>
<li></li>
<li><p>Returns the current level of GPIO 32-53.</p></li>
</ul>
<ul>
<li></li>
<li><p>Clears GPIO 0-31 if the corresponding bit in bits is set.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>bits: a bit mask of GPIO to clear


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>// To clear (set to 0) GPIO 4, 7, and 15


gpioWrite_Bits_0_31_Clear( (1&lt;&lt;4) | (1&lt;&lt;7) | (1&lt;&lt;15) );


</code></pre>
<ul>
<li></li>
<li><p>Clears GPIO 32-53 if the corresponding bit (0-21) in bits is set.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>bits: a bit mask of GPIO to clear


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK.</p>
<ul>
<li></li>
<li><p>Sets GPIO 0-31 if the corresponding bit in bits is set.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>bits: a bit mask of GPIO to set


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK.</p>
<ul>
<li></li>
<li><p>Sets GPIO 32-53 if the corresponding bit (0-21) in bits is set.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>bits: a bit mask of GPIO to set


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>// To set (set to 1) GPIO 32, 40, and 53


gpioWrite_Bits_32_53_Set((1&lt;&lt;(32-32)) | (1&lt;&lt;(40-32)) | (1&lt;&lt;(53-32)));


</code></pre>
<ul>
<li></li>
<li><p>Starts a hardware clock on a GPIO at the specified frequency. Frequencies above 30MHz are unlikely to work.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>   gpio: see description


clkfreq: 0 (off) or 4689-250M (13184-375M for the BCM2711)


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_GPIO, PI_NOT_HCLK_GPIO, PI_BAD_HCLK_FREQ,or PI_BAD_HCLK_PASS.</p>
<p><br />
</p>
<p><br />
The same clock is available on multiple GPIO. The latest frequency setting will be used by all GPIO which share a clock.</p>
<p><br />
</p>
<p><br />
The GPIO must be one of the following.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>4   clock 0  All models


5   clock 1  All models but A and B (reserved for system use)


6   clock 2  All models but A and B


20  clock 0  All models but A and B


21  clock 1  All models but A and Rev.2 B (reserved for system use)





32  clock 0  Compute module only


34  clock 0  Compute module only


42  clock 1  Compute module only (reserved for system use)


43  clock 2  Compute module only


44  clock 1  Compute module only (reserved for system use)


</code></pre>
<p><br />
</p>
<p><br />
Access to clock 1 is protected by a password as its use will likely crash the Pi. The password is given by or'ing 0x5A000000 with the GPIO number.</p>
<ul>
<li></li>
<li><p>Starts hardware PWM on a GPIO at the specified frequency and dutycycle. Frequencies above 30MHz are unlikely to work.</p></li>
</ul>
<p><br />
</p>
<p><br />
NOTE: Any waveform started by <strong>gpioWaveTxSend</strong>, or <strong>gpioWaveChain</strong> will be cancelled.</p>
<p><br />
</p>
<p><br />
This function is only valid if the pigpio main clock is PCM. The main clock defaults to PCM but may be overridden by a call to <strong>gpioCfgClock</strong>.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>   gpio: see description


PWMfreq: 0 (off) or 1-125M (1-187.5M for the BCM2711)


PWMduty: 0 (off) to 1000000 (1M)(fully on)


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_GPIO, PI_NOT_HPWM_GPIO, PI_BAD_HPWM_DUTY, PI_BAD_HPWM_FREQ, or PI_HPWM_ILLEGAL.</p>
<p><br />
</p>
<p><br />
The same PWM channel is available on multiple GPIO. The latest frequency and dutycycle setting will be used by all GPIO which share a PWM channel.</p>
<p><br />
</p>
<p><br />
The GPIO must be one of the following.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>12  PWM channel 0  All models but A and B


13  PWM channel 1  All models but A and B


18  PWM channel 0  All models


19  PWM channel 1  All models but A and B





40  PWM channel 0  Compute module only


41  PWM channel 1  Compute module only


45  PWM channel 1  Compute module only


52  PWM channel 0  Compute module only


53  PWM channel 1  Compute module only


</code></pre>
<p><br />
</p>
<p><br />
The actual number of steps beween off and fully on is the integral part of 250M/PWMfreq (375M/PWMfreq for the BCM2711).</p>
<p><br />
</p>
<p><br />
The actual frequency set is 250M/steps (375M/steps for the BCM2711).</p>
<p><br />
</p>
<p><br />
There will only be a million steps for a PWMfreq of 250 (375 for the BCM2711). Lower frequencies will have more steps and higher frequencies will have fewer steps. PWMduty is automatically scaled to take this into account.</p>
<ul>
<li></li>
<li><p>Updates the seconds and micros variables with the current time.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>timetype: 0 (relative), 1 (absolute)


 seconds: a pointer to an int to hold seconds


  micros: a pointer to an int to hold microseconds


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_TIMETYPE.</p>
<p><br />
</p>
<p><br />
If timetype is PI_TIME_ABSOLUTE updates seconds and micros with the number of seconds and microseconds since the epoch (1st January 1970).</p>
<p><br />
</p>
<p><br />
If timetype is PI_TIME_RELATIVE updates seconds and micros with the number of seconds and microseconds since the library was initialised.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>int secs, mics;





// print the number of seconds since the library was started


gpioTime(PI_TIME_RELATIVE, &amp;secs, &amp;mics);


printf(&quot;library started %d.%03d seconds ago&quot;, secs, mics/1000);


</code></pre>
<ul>
<li></li>
<li><p>Sleeps for the number of seconds and microseconds specified by seconds and micros.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>timetype: 0 (relative), 1 (absolute)


 seconds: seconds to sleep


  micros: microseconds to sleep


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_TIMETYPE, PI_BAD_SECONDS, or PI_BAD_MICROS.</p>
<p><br />
</p>
<p><br />
If timetype is PI_TIME_ABSOLUTE the sleep ends when the number of seconds and microseconds since the epoch (1st January 1970) has elapsed. System clock changes are taken into account.</p>
<p><br />
</p>
<p><br />
If timetype is PI_TIME_RELATIVE the sleep is for the specified number of seconds and microseconds. System clock changes do not effect the sleep length.</p>
<p><br />
</p>
<p><br />
For short delays (say, 50 microseonds or less) use <strong>gpioDelay</strong>.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>gpioSleep(PI_TIME_RELATIVE, 2, 500000); // sleep for 2.5 seconds





gpioSleep(PI_TIME_RELATIVE, 0, 100000); // sleep for 0.1 seconds





gpioSleep(PI_TIME_RELATIVE, 60, 0);     // sleep for one minute


</code></pre>
<ul>
<li></li>
<li><p>Delays for at least the number of microseconds specified by micros.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>micros: the number of microseconds to sleep


</code></pre>
<p><br />
</p>
<p><br />
Returns the actual length of the delay in microseconds.</p>
<p><br />
</p>
<p><br />
Delays of 100 microseconds or less use busy waits.</p>
<ul>
<li></li>
<li><p>Returns the current system tick.</p></li>
</ul>
<p><br />
</p>
<p><br />
Tick is the number of microseconds since system boot.</p>
<p><br />
</p>
<p><br />
As tick is an unsigned 32 bit quantity it wraps around after 2^32 microseconds, which is approximately 1 hour 12 minutes.</p>
<p><br />
</p>
<p><br />
You don't need to worry about the wrap around as long as you take a tick (uint32_t) from another tick, i.e. the following code will always provide the correct difference.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>uint32_t startTick, endTick;


int diffTick;





startTick = gpioTick();





// do some processing





endTick = gpioTick();





diffTick = endTick - startTick;





printf(&quot;some processing took %d microseconds&quot;, diffTick);


</code></pre>
<ul>
<li></li>
<li><p>Returns the hardware revision.</p></li>
</ul>
<p><br />
</p>
<p><br />
If the hardware revision can not be found or is not a valid hexadecimal number the function returns 0.</p>
<p><br />
</p>
<p><br />
The hardware revision is the last few characters on the Revision line of /proc/cpuinfo.</p>
<p><br />
</p>
<p><br />
The revision number can be used to determine the assignment of GPIO to pins (see <strong>gpio</strong>).</p>
<p><br />
</p>
<p><br />
There are at least three types of board.</p>
<p><br />
</p>
<p><br />
Type 1 boards have hardware revision numbers of 2 and 3.</p>
<p><br />
</p>
<p><br />
Type 2 boards have hardware revision numbers of 4, 5, 6, and 15.</p>
<p><br />
</p>
<p><br />
Type 3 boards have hardware revision numbers of 16 or greater.</p>
<p><br />
</p>
<p><br />
for "Revision : 0002" the function returns 2.<br />
for "Revision : 000f" the function returns 15.<br />
for "Revision : 000g" the function returns 0.</p>
<ul>
<li></li>
<li><p>Returns the pigpio version.</p></li>
</ul>
<ul>
<li></li>
<li><p>This function returns the pad drive strength in mA.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>pad: 0-2, the pad to get


</code></pre>
<p><br />
</p>
<p><br />
Returns the pad drive strength if OK, otherwise PI_BAD_PAD.</p>
<p><br />
</p>
<p><br />
Pad GPIO<br />
0 0-27<br />
1 28-45<br />
2 46-53<br />
</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>strength = gpioGetPad(1); // get pad 1 strength


</code></pre>
<ul>
<li></li>
<li><p>This function sets the pad drive strength in mA.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>        pad: 0-2, the pad to set


padStrength: 1-16 mA


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_PAD, or PI_BAD_STRENGTH.</p>
<p><br />
</p>
<p><br />
Pad GPIO<br />
0 0-27<br />
1 28-45<br />
2 46-53<br />
</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>gpioSetPad(0, 16); // set pad 0 strength to 16 mA


</code></pre>
<ul>
<li></li>
<li><p>This function selects the events to be reported on a previously opened handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by gpioNotifyOpen


  bits: a bit mask indicating the events of interest


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_HANDLE.</p>
<p><br />
</p>
<p><br />
A report is sent each time an event is triggered providing the corresponding bit in bits is set.</p>
<p><br />
</p>
<p><br />
See <strong>gpioNotifyBegin</strong> for the notification format.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>// Start reporting events 3, 6, and 7.





//  bit      76543210


// (0xC8 = 0b11001000)





eventMonitor(h, 0xC8);


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
<li><p>Registers a function to be called (a callback) when the specified event occurs.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>event: 0-31


    f: the callback function


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_EVENT_ID.</p>
<p><br />
</p>
<p><br />
One function may be registered per event.</p>
<p><br />
</p>
<p><br />
The function is passed the event, and the tick.</p>
<p><br />
</p>
<p><br />
The callback may be cancelled by passing NULL as the function.</p>
<ul>
<li></li>
<li><p>Registers a function to be called (a callback) when the specified event occurs.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>   event: 0-31


       f: the callback function


userdata: pointer to arbitrary user data


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_EVENT_ID.</p>
<p><br />
</p>
<p><br />
One function may be registered per event.</p>
<p><br />
</p>
<p><br />
The function is passed the event, the tick, and the ueserdata pointer.</p>
<p><br />
</p>
<p><br />
The callback may be cancelled by passing NULL as the function.</p>
<p><br />
</p>
<p><br />
Only one of <strong>eventSetFunc</strong> or <strong>eventSetFuncEx</strong> can be registered per event.</p>
<ul>
<li></li>
<li><p>This function signals the occurrence of an event.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>event: 0-31, the event


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_EVENT_ID.</p>
<p><br />
</p>
<p><br />
An event is a signal used to inform one or more consumers to start an action. Each consumer which has registered an interest in the event (e.g. by calling <strong>eventSetFunc</strong>) will be informed by a callback.</p>
<p><br />
</p>
<p><br />
One event, PI_EVENT_BSC (31) is predefined. This event is auto generated on BSC slave activity.</p>
<p><br />
</p>
<p><br />
The meaning of other events is arbitrary.</p>
<p><br />
</p>
<p><br />
Note that other than its id and its tick there is no data associated with an event.</p>
<ul>
<li></li>
<li><p>This function uses the system call to execute a shell script with the given string as its parameter.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>  scriptName: the name of the script, only alphanumeric characters,


              &#39;-&#39; and &#39;_&#39; are allowed in the name


scriptString: the string to pass to the script


</code></pre>
<p><br />
</p>
<p><br />
The exit status of the system call is returned if OK, otherwise PI_BAD_SHELL_STATUS.</p>
<p><br />
</p>
<p><br />
scriptName must exist in /opt/pigpio/cgi and must be executable.</p>
<p><br />
</p>
<p><br />
The returned exit status is normally 256 times that set by the shell script exit function. If the script can't be found 32512 will be returned.</p>
<p><br />
</p>
<p><br />
The following table gives some example returned statuses.</p>
<p><br />
</p>
<p><br />
Script exit status Returned system call status<br />
1 256<br />
5 1280<br />
10 2560<br />
200 51200<br />
script not found 32512<br />
</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>// pass two parameters, hello and world


status = shell(&quot;scr1&quot;, &quot;hello world&quot;);





// pass three parameters, hello, string with spaces, and world


status = shell(&quot;scr1&quot;, &quot;hello &#39;string with spaces&#39; world&quot;);





// pass one parameter, hello string with spaces world


status = shell(&quot;scr1&quot;, &quot;


</code></pre>
<ul>
<li></li>
<li><p>This function returns a handle to a file opened in a specified mode.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>file: the file to open


mode: the file open mode


</code></pre>
<p><br />
</p>
<p><br />
Returns a handle (&gt;=0) if OK, otherwise PI_NO_HANDLE, PI_NO_FILE_ACCESS, PI_BAD_FILE_MODE, PI_FILE_OPEN_FAILED, or PI_FILE_IS_A_DIR.</p>
<p><br />
</p>
<p><br />
File</p>
<p><br />
</p>
<p><br />
A file may only be opened if permission is granted by an entry in /opt/pigpio/access. This is intended to allow remote access to files in a more or less controlled manner.</p>
<p><br />
</p>
<p><br />
Each entry in /opt/pigpio/access takes the form of a file path which may contain wildcards followed by a single letter permission. The permission may be R for read, W for write, U for read/write, and N for no access.</p>
<p><br />
</p>
<p><br />
Where more than one entry matches a file the most specific rule applies. If no entry matches a file then access is denied.</p>
<p><br />
</p>
<p><br />
Suppose /opt/pigpio/access contains the following entries</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>/home/* n


/home/pi/shared/dir_1/* w


/home/pi/shared/dir_2/* r


/home/pi/shared/dir_3/* u


/home/pi/shared/dir_1/file.txt n


</code></pre>
<p><br />
</p>
<p><br />
Files may be written in directory dir_1 with the exception of file.txt.</p>
<p><br />
</p>
<p><br />
Files may be read in directory dir_2.</p>
<p><br />
</p>
<p><br />
Files may be read and written in directory dir_3.</p>
<p><br />
</p>
<p><br />
If a directory allows read, write, or read/write access then files may be created in that directory.</p>
<p><br />
</p>
<p><br />
In an attempt to prevent risky permissions the following paths are ignored in /opt/pigpio/access.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>a path containing ..


a path containing only wildcards (*?)


a path containing less than two non-wildcard parts


</code></pre>
<p><br />
</p>
<p><br />
Mode</p>
<p><br />
</p>
<p><br />
The mode may have the following values.</p>
<p><br />
</p>
<p><br />
Macro Value Meaning<br />
PI_FILE_READ 1 open file for reading<br />
PI_FILE_WRITE 2 open file for writing<br />
PI_FILE_RW 3 open file for reading and writing<br />
</p>
<p><br />
</p>
<p><br />
The following values may be or'd into the mode.</p>
<p><br />
</p>
<p><br />
Macro Value Meaning<br />
PI_FILE_APPEND 4 Writes append data to the end of the file<br />
PI_FILE_CREATE 8 The file is created if it doesn't exist<br />
PI_FILE_TRUNC 16 The file is truncated<br />
</p>
<p><br />
</p>
<p><br />
Newly created files are owned by root with permissions owner read and write.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>#include &lt;stdio.h&gt;


#include &lt;pigpio.h&gt;





int main(int argc, char *argv[])


{


   int handle, c;


   char buf[60000];





   if (gpioInitialise() &lt; 0) return 1;





   // assumes /opt/pigpio/access contains the following line


   // /ram/*.c r





   handle = fileOpen(&quot;/ram/pigpio.c&quot;, PI_FILE_READ);





   if (handle &gt;= 0)


   {


      while ((c=fileRead(handle, buf, sizeof(buf)-1)))


      {


         buf[c] = 0;


         printf(&quot;%s&quot;, buf);


      }





      fileClose(handle);


   }





   gpioTerminate();


}


</code></pre>
<ul>
<li></li>
<li><p>This function closes the file associated with handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to fileOpen


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_HANDLE.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>fileClose(h);


</code></pre>
<ul>
<li></li>
<li><p>This function writes count bytes from buf to the the file associated with handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to fileOpen


   buf: the array of bytes to write


 count: the number of bytes to write


</code></pre>
<p><br />
</p>
<p><br />
Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, PI_FILE_NOT_WOPEN, or PI_BAD_FILE_WRITE.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>status = fileWrite(h, buf, count);


if (status == 0)


{


   // okay


}


else


{


   // error


}


</code></pre>
<ul>
<li></li>
<li><p>This function reads up to count bytes from the the file associated with handle and writes them to buf.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>handle: &gt;=0, as returned by a call to fileOpen


   buf: an array to receive the read data


 count: the maximum number of bytes to read


</code></pre>
<p><br />
</p>
<p><br />
Returns the number of bytes read (&gt;=0) if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, PI_FILE_NOT_ROPEN, or PI_BAD_FILE_WRITE.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>if (fileRead(h, buf, sizeof(buf)) &gt; 0)


{


   // process read data


}


</code></pre>
<ul>
<li></li>
<li><p>This function seeks to a position within the file associated with handle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>    handle: &gt;=0, as returned by a call to fileOpen


seekOffset: the number of bytes to move.  Positive offsets


            move forward, negative offsets backwards.


  seekFrom: one of PI_FROM_START (0), PI_FROM_CURRENT (1),


            or PI_FROM_END (2)


</code></pre>
<p><br />
</p>
<p><br />
Returns the new byte position within the file (&gt;=0) if OK, otherwise PI_BAD_HANDLE, or PI_BAD_FILE_SEEK.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>fileSeek(0, 20, PI_FROM_START); // Seek to start plus 20





size = fileSeek(0, 0, PI_FROM_END); // Seek to end, return size





pos = fileSeek(0, 0, PI_FROM_CURRENT); // Return current position


</code></pre>
<ul>
<li></li>
<li><p>This function returns a list of files which match a pattern. The pattern may contain wildcards.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code> fpat: file pattern to match


  buf: an array to receive the matching file names


count: the maximum number of bytes to read


</code></pre>
<p><br />
</p>
<p><br />
Returns the number of returned bytes if OK, otherwise PI_NO_FILE_ACCESS, or PI_NO_FILE_MATCH.</p>
<p><br />
</p>
<p><br />
The pattern must match an entry in /opt/pigpio/access. The pattern may contain wildcards. See <strong>fileOpen</strong>.</p>
<p><br />
</p>
<p><br />
NOTE</p>
<p><br />
</p>
<p><br />
The returned value is not the number of files, it is the number of bytes in the buffer. The file names are separated by newline characters.</p>
<p><br />
</p>
<p><br />
<strong>Example</strong><br />
</p>
<pre><code>#include &lt;stdio.h&gt;


#include &lt;pigpio.h&gt;





int main(int argc, char *argv[])


{


   int c;


   char buf[1000];





   if (gpioInitialise() &lt; 0) return 1;





   // assumes /opt/pigpio/access contains the following line


   // /ram/*.c r





   c = fileList(&quot;/ram/p*.c&quot;, buf, sizeof(buf));





   if (c &gt;= 0)


   {


      // terminate string


      buf[c] = 0;


      printf(&quot;%s&quot;, buf);


   }





   gpioTerminate();


}


</code></pre>
<ul>
<li></li>
<li><p>Configures pigpio to buffer cfgMillis milliseconds of GPIO samples.</p></li>
</ul>
<p><br />
</p>
<p><br />
This function is only effective if called before <strong>gpioInitialise</strong>.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>cfgMillis: 100-10000


</code></pre>
<p><br />
</p>
<p><br />
The default setting is 120 milliseconds.</p>
<p><br />
</p>
<p><br />
The intention is to allow for bursts of data and protection against other processes hogging cpu time.</p>
<p><br />
</p>
<p><br />
I haven't seen a process locked out for more than 100 milliseconds.</p>
<p><br />
</p>
<p><br />
Making the buffer bigger uses a LOT of memory at the more frequent sampling rates as shown in the following table in MBs.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>                     buffer milliseconds


               120 250 500 1sec 2sec 4sec 8sec





         1      16  31  55  107  ---  ---  ---


         2      10  18  31   55  107  ---  ---


sample   4       8  12  18   31   55  107  ---


 rate    5       8  10  14   24   45   87  ---


 (us)    8       6   8  12   18   31   55  107


        10       6   8  10   14   24   45   87


</code></pre>
<ul>
<li></li>
<li><p>Configures pigpio to use a particular sample rate timed by a specified peripheral.</p></li>
</ul>
<p><br />
</p>
<p><br />
This function is only effective if called before <strong>gpioInitialise</strong>.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>    cfgMicros: 1, 2, 4, 5, 8, 10


cfgPeripheral: 0 (PWM), 1 (PCM)


    cfgSource: deprecated, value is ignored


</code></pre>
<p><br />
</p>
<p><br />
The timings are provided by the specified peripheral (PWM or PCM).</p>
<p><br />
</p>
<p><br />
The default setting is 5 microseconds using the PCM peripheral.</p>
<p><br />
</p>
<p><br />
The approximate CPU percentage used for each sample rate is:</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>sample  cpu


 rate    %





  1     25


  2     16


  4     11


  5     10


  8     15


 10     14


</code></pre>
<p><br />
</p>
<p><br />
A sample rate of 5 microseconds seeems to be the sweet spot.</p>
<ul>
<li></li>
<li><p>Configures pigpio to use the specified DMA channel.</p></li>
</ul>
<p><br />
</p>
<p><br />
This function is only effective if called before <strong>gpioInitialise</strong>.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>DMAchannel: 0-14


</code></pre>
<p><br />
</p>
<p><br />
The default setting is to use channel 14.</p>
<ul>
<li></li>
<li><p>Configures pigpio to use the specified DMA channels.</p></li>
</ul>
<p><br />
</p>
<p><br />
This function is only effective if called before <strong>gpioInitialise</strong>.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>  primaryChannel: 0-14


secondaryChannel: 0-14


</code></pre>
<p><br />
</p>
<p><br />
The default setting depends on whether the Pi has a BCM2711 chip or not (currently only the Pi4B has a BCM2711).</p>
<p><br />
</p>
<p><br />
The default setting for a non-BCM2711 is to use channel 14 for the primary channel and channel 6 for the secondary channel.</p>
<p><br />
</p>
<p><br />
The default setting for a BCM2711 is to use channel 7 for the primary channel and channel 6 for the secondary channel.</p>
<p><br />
</p>
<p><br />
The secondary channel is only used for the transmission of waves.</p>
<p><br />
</p>
<p><br />
If possible use one of channels 0 to 6 for the secondary channel (a full channel).</p>
<p><br />
</p>
<p><br />
A full channel only requires one DMA control block regardless of the length of a pulse delay. Channels 7 to 14 (lite channels) require one DMA control block for each 16383 microseconds of delay. I.e. a 10 second pulse delay requires one control block on a full channel and 611 control blocks on a lite channel.</p>
<ul>
<li></li>
<li><p>Configures pigpio to restrict GPIO updates via the socket or pipe interfaces to the GPIO specified by the mask. Programs directly calling the pigpio library (i.e. linked with -lpigpio are not affected). A GPIO update is a write to a GPIO or a GPIO mode change or any function which would force such an action.</p></li>
</ul>
<p><br />
</p>
<p><br />
This function is only effective if called before <strong>gpioInitialise</strong>.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>updateMask: bit (1&lt;&lt;n) is set for each GPIO n which may be updated


</code></pre>
<p><br />
</p>
<p><br />
The default setting depends upon the Pi model. The user GPIO are added to the mask.</p>
<p><br />
</p>
<p><br />
If the board revision is not recognised then GPIO 2-27 are allowed.</p>
<p><br />
</p>
<p><br />
Unknown board PI_DEFAULT_UPDATE_MASK_UNKNOWN 0x0FFFFFFC<br />
<br />
Type 1 board PI_DEFAULT_UPDATE_MASK_B1 0x03E6CF93<br />
<br />
Type 2 board PI_DEFAULT_UPDATE_MASK_A_B2 0xFBC6CF9C<br />
Type 3 board PI_DEFAULT_UPDATE_MASK_R3 0x0FFFFFFC<br />
</p>
<ul>
<li></li>
<li><p>Configures pigpio to use the specified socket port.</p></li>
</ul>
<p><br />
</p>
<p><br />
This function is only effective if called before <strong>gpioInitialise</strong>.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>port: 1024-32000


</code></pre>
<p><br />
</p>
<p><br />
The default setting is to use port 8888.</p>
<ul>
<li></li>
<li><p>Configures pigpio support of the fifo and socket interfaces.</p></li>
</ul>
<p><br />
</p>
<p><br />
This function is only effective if called before <strong>gpioInitialise</strong>.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>ifFlags: 0-7


</code></pre>
<p><br />
</p>
<p><br />
The default setting (0) is that both interfaces are enabled.</p>
<p><br />
</p>
<p><br />
Or in PI_DISABLE_FIFO_IF to disable the pipe interface.</p>
<p><br />
</p>
<p><br />
Or in PI_DISABLE_SOCK_IF to disable the socket interface.</p>
<p><br />
</p>
<p><br />
Or in PI_LOCALHOST_SOCK_IF to disable remote socket access (this means that the socket interface is only usable from the local Pi).</p>
<ul>
<li></li>
<li><p>Selects the method of DMA memory allocation.</p></li>
</ul>
<p><br />
</p>
<p><br />
This function is only effective if called before <strong>gpioInitialise</strong>.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>memAllocMode: 0-2


</code></pre>
<p><br />
</p>
<p><br />
There are two methods of DMA memory allocation. The original method uses the /proc/self/pagemap file to allocate bus memory. The new method uses the mailbox property interface to allocate bus memory.</p>
<p><br />
</p>
<p><br />
Auto will use the mailbox method unless a larger than default buffer size is requested with <strong>gpioCfgBufferSize</strong>.</p>
<ul>
<li></li>
<li><p>Sets the network addresses which are allowed to talk over the socket interface.</p></li>
</ul>
<p><br />
</p>
<p><br />
This function is only effective if called before <strong>gpioInitialise</strong>.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>numSockAddr: 0-256 (0 means all addresses allowed)


   sockAddr: an array of permitted network addresses.


</code></pre>
<ul>
<li></li>
<li><p>This function returns the current library internal configuration settings.</p></li>
</ul>
<ul>
<li></li>
<li><p>This function sets the current library internal configuration settings.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>cfgVal: see source code


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
<li><p>This function is available for user customisation.</p></li>
</ul>
<p><br />
</p>
<p><br />
It returns a single integer value.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>arg1: &gt;=0


arg2: &gt;=0


argx: extra (byte) arguments


argc: number of extra arguments


</code></pre>
<p><br />
</p>
<p><br />
Returns &gt;= 0 if OK, less than 0 indicates a user defined error.</p>
<ul>
<li></li>
<li><p>This function is available for user customisation.</p></li>
</ul>
<p><br />
</p>
<p><br />
It differs from gpioCustom1 in that it returns an array of bytes rather than just an integer.</p>
<p><br />
</p>
<p><br />
The returned value is an integer indicating the number of returned bytes.</p>
<pre><code>  arg1: &gt;=0


  argx: extra (byte) arguments


  argc: number of extra arguments


retBuf: buffer for returned bytes


retMax: maximum number of bytes to return


</code></pre>
<p><br />
</p>
<p><br />
Returns &gt;= 0 if OK, less than 0 indicates a user defined error.</p>
<p><br />
</p>
<p><br />
The number of returned bytes must be retMax or less.</p>
<ul>
<li></li>
<li><p>This function adds a waveform representing SPI data to the existing waveform (if any).</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>        spi: a pointer to a spi object


     offset: microseconds from the start of the waveform


      spiSS: the slave select GPIO


        buf: the bits to transmit, most significant bit first


  spiTxBits: the number of bits to write


spiBitFirst: the first bit to read


 spiBitLast: the last bit to read


    spiBits: the number of bits to transfer


</code></pre>
<p><br />
</p>
<p><br />
Returns the new total number of pulses in the current waveform if OK, otherwise PI_BAD_USER_GPIO, PI_BAD_SER_OFFSET, or PI_TOO_MANY_PULSES.</p>
<p><br />
</p>
<p><br />
Not intended for general use.</p>
<ul>
<li></li>
<li><p>This function adds a number of pulses to the current waveform.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>numPulses: the number of pulses


   pulses: the array containing the pulses


</code></pre>
<p><br />
</p>
<p><br />
Returns the new total number of pulses in the current waveform if OK, otherwise PI_TOO_MANY_PULSES.</p>
<p><br />
</p>
<p><br />
The advantage of this function over gpioWaveAddGeneric is that it allows the setting of the flags field.</p>
<p><br />
</p>
<p><br />
The pulses are interleaved in time order within the existing waveform (if any).</p>
<p><br />
</p>
<p><br />
Merging allows the waveform to be built in parts, that is the settings for GPIO#1 can be added, and then GPIO#2 etc.</p>
<p><br />
</p>
<p><br />
If the added waveform is intended to start after or within the existing waveform then the first pulse should consist of a delay.</p>
<p><br />
</p>
<p><br />
Not intended for general use.</p>
<ul>
<li></li>
<li><p>Returns the number of the cb being currently output.</p></li>
</ul>
<p><br />
</p>
<p><br />
Not intended for general use.</p>
<ul>
<li></li>
<li><p>Return the (Linux) address of contol block cbNum.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>cbNum: the cb of interest


</code></pre>
<p><br />
</p>
<p><br />
Not intended for general use.</p>
<ul>
<li></li>
<li><p>Gets the OOL parameter stored at pos.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>pos: the position of interest.


</code></pre>
<p><br />
</p>
<p><br />
Not intended for general use.</p>
<ul>
<li></li>
<li><p>Sets the OOL parameter stored at pos to value.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code> pos: the position of interest


lVal: the value to write


</code></pre>
<p><br />
</p>
<p><br />
Not intended for general use.</p>
<ul>
<li></li>
<li><p>Gets the wave output parameter stored at pos.</p></li>
</ul>
<p><br />
</p>
<p><br />
DEPRECATED: use rawWaveGetOOL instead.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>pos: the position of interest.


</code></pre>
<p><br />
</p>
<p><br />
Not intended for general use.</p>
<ul>
<li></li>
<li><p>Sets the wave output parameter stored at pos to value.</p></li>
</ul>
<p><br />
</p>
<p><br />
DEPRECATED: use rawWaveSetOOL instead.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code> pos: the position of interest


lVal: the value to write


</code></pre>
<p><br />
</p>
<p><br />
Not intended for general use.</p>
<ul>
<li></li>
<li><p>Gets the wave input value parameter stored at pos.</p></li>
</ul>
<p><br />
</p>
<p><br />
DEPRECATED: use rawWaveGetOOL instead.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>pos: the position of interest


</code></pre>
<p><br />
</p>
<p><br />
Not intended for general use.</p>
<ul>
<li></li>
<li><p>Sets the wave input value stored at pos to value.</p></li>
</ul>
<p><br />
</p>
<p><br />
DEPRECATED: use rawWaveSetOOL instead.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code> pos: the position of interest


lVal: the value to write


</code></pre>
<p><br />
</p>
<p><br />
Not intended for general use.</p>
<ul>
<li></li>
<li><p>Gets details about the wave with id wave_id.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>wave_id: the wave of interest


</code></pre>
<p><br />
</p>
<p><br />
Not intended for general use.</p>
<ul>
<li></li>
<li><p>Returns the value of the bit bitPos bits from the start of buf. Returns 0 if bitPos is greater than or equal to numBits.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code> bitPos: bit index from the start of buf


    buf: array of bits


numBits: number of valid bits in buf


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
<li><p>Sets the bit bitPos bits from the start of buf to bit.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>bitPos: bit index from the start of buf


   buf: array of bits


   bit: 0-1, value to set


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
<li><p>Return the current time in seconds since the Epoch.</p></li>
</ul>
<ul>
<li></li>
<li><p>Delay execution for a given number of seconds</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>seconds: the number of seconds to sleep


</code></pre>
<ul>
<li></li>
<li><p>Used to print a readable version of the current waveform to stderr.</p></li>
</ul>
<p><br />
</p>
<p><br />
Not intended for general use.</p>
<ul>
<li></li>
<li><p>Used to print a readable version of a script to stderr.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>script_id: &gt;=0, a script_id returned by gpioStoreScript


</code></pre>
<p><br />
</p>
<p><br />
Not intended for general use.</p>
<h1>PARAMETERS</h1>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
The number of microseconds level changes are reported for once a noise filter has been triggered (by <strong>steady</strong> microseconds of a stable level).</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
An unsigned argument passed to a user customised function. Its meaning is defined by the customiser.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
An unsigned argument passed to a user customised function. Its meaning is defined by the customiser.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The count of bytes passed to a user customised function.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A pointer to an array of bytes passed to a user customised function. Its meaning and content is defined by the customiser.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The speed of serial communication (I2C, SPI, serial link, waves) in bits per second.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A value of 0 or 1.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A bit position within a byte or word. The least significant bit is position 0.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A value used to select GPIO. If bit n of bits is set then GPIO n is selected.</p></li>
</ul>
<p><br />
</p>
<p><br />
A convenient way to set bit n is to or in (1&lt;&lt;n).</p>
<p><br />
</p>
<p><br />
e.g. to select bits 5, 9, 23 you could use (1&lt;&lt;5) | (1&lt;&lt;9) | (1&lt;&lt;23).</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A pointer to a <strong>bsc_xfer_t</strong> object used to control a BSC transfer.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>typedef struct


{


   uint32_t control;          // Write


   int rxCnt;                 // Read only


   char rxBuf[BSC_FIFO_SIZE]; // Read only


   int txCnt;                 // Write


   char txBuf[BSC_FIFO_SIZE]; // Write


} bsc_xfer_t;


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
A buffer to hold data being sent or being received.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
The size in bytes of a buffer.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
An 8-bit byte value.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
A number identifying a DMA contol block.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
The GPIO sample rate in microseconds. The default is 5us, or 200 thousand samples per second.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
The size of the sample buffer in milliseconds. Generally this should be left at the default of 120ms. If you expect intense bursts of signals it might be necessary to increase the buffer size.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
One of the PWM or PCM peripherals used to pace DMA transfers for timing purposes.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
Deprecated.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
A number specifying the value of a configuration item. See <strong>cfgWhat</strong>.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
A number specifying a configuration item.</p>
<p><br />
</p>
<p><br />
562484977: print enhanced statistics at termination.<br />
984762879: set the initial debug level.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
A single character, an 8 bit quantity able to store 0-255.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
The hardware clock frequency.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>PI_HW_CLK_MIN_FREQ 4689


PI_HW_CLK_MAX_FREQ 250000000


PI_HW_CLK_MAX_FREQ_2711 375000000


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The number of bytes to be transferred in an I2C, SPI, or Serial command.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The GPIO used for the slave select signal when bit banging SPI.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
The number of data bits to be used when adding serial data to a waveform.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>PI_MIN_WAVE_DATABITS 1


PI_MAX_WAVE_DATABITS 32


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<pre><code>PI_MIN_DMA_CHANNEL 0


PI_MAX_DMA_CHANNEL 15


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
A floating point number.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
A number representing the ratio of on time to off time for PWM.</p>
<p><br />
</p>
<p><br />
The number may vary between 0 and range (default 255) where 0 is off and range is fully on.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The type of GPIO edge to generate an interrupt. See <strong>gpioSetISRFunc</strong> and <strong>gpioSetISRFuncEx</strong>.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>RISING_EDGE 0


FALLING_EDGE 1


EITHER_EDGE 2


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>An event is a signal used to inform one or more consumers to start an action.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<pre><code>typedef void (*eventFunc_t) (int event, uint32_t tick);


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<pre><code>typedef void (*eventFuncEx_t)


   (int event, uint32_t tick, void *userdata);


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ol start="6" type="a">
<li></li>
</ol>
<p><br />
</p>
<p><br />
A function.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A full file path. To be accessible the path must match an entry in /opt/pigpio/access.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A file path which may contain wildcards. To be accessible the path must match an entry in /opt/pigpio/access.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
The number of times a GPIO is swiched on and off per second. This can be set per GPIO and may be as little as 5Hz or as much as 40KHz. The GPIO will be on for a proportion of the time as defined by its dutycycle.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
A Broadcom numbered GPIO, in the range 0-53.</p>
<p><br />
</p>
<p><br />
There are 54 General Purpose Input Outputs (GPIO) named GPIO0 through GPIO53.</p>
<p><br />
</p>
<p><br />
They are split into two banks. Bank 1 consists of GPIO0 through GPIO31. Bank 2 consists of GPIO32 through GPIO53.</p>
<p><br />
</p>
<p><br />
All the GPIO which are safe for the user to read and write are in bank 1. Not all GPIO in bank 1 are safe though. Type 1 boards have 17 safe GPIO. Type 2 boards have 21. Type 3 boards have 26.</p>
<p><br />
</p>
<p><br />
See <strong>gpioHardwareRevision</strong>.</p>
<p><br />
</p>
<p><br />
The user GPIO are marked with an X in the following table.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>          0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15


Type 1    X  X  -  -  X  -  -  X  X  X  X  X  -  -  X  X


Type 2    -  -  X  X  X  -  -  X  X  X  X  X  -  -  X  X


Type 3          X  X  X  X  X  X  X  X  X  X  X  X  X  X





         16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31


Type 1    -  X  X  -  -  X  X  X  X  X  -  -  -  -  -  -


Type 2    -  X  X  -  -  -  X  X  X  X  -  X  X  X  X  X


Type 3    X  X  X  X  X  X  X  X  X  X  X  X  -  -  -  -


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<pre><code>typedef void (*gpioAlertFunc_t) (int gpio, int level, uint32_t tick);


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<pre><code>typedef void (*eventFuncEx_t)


   (int event, int level, uint32_t tick, void *userdata);


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
These functions are only effective if called before <strong>gpioInitialise</strong>.</p>
<p><br />
</p>
<p><br />
<strong>gpioCfgBufferSize</strong><br />
<strong>gpioCfgClock</strong><br />
<strong>gpioCfgDMAchannel</strong><br />
<strong>gpioCfgDMAchannels</strong><br />
<strong>gpioCfgPermissions</strong><br />
<strong>gpioCfgInterfaces</strong><br />
<strong>gpioCfgSocketPort</strong><br />
<strong>gpioCfgMemAlloc</strong></p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<pre><code>typedef void (*gpioGetSamplesFunc_t)


   (const gpioSample_t *samples, int numSamples);


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<pre><code>typedef void (*gpioGetSamplesFuncEx_t)


   (const gpioSample_t *samples, int numSamples, void *userdata);


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<pre><code>typedef void (*gpioISRFunc_t)


   (int gpio, int level, uint32_t tick);


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<pre><code>typedef void (*gpioISRFuncEx_t)


   (int gpio, int level, uint32_t tick, void *userdata);


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<pre><code>typedef struct


{


   uint32_t gpioOn;


   uint32_t gpioOff;


   uint32_t usDelay;


} gpioPulse_t;


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<pre><code>typedef struct


{


   uint32_t tick;


   uint32_t level;


} gpioSample_t;


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<pre><code>typedef void (*gpioSignalFunc_t) (int signum);


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<pre><code>typedef void (*gpioSignalFuncEx_t) (int signum, void *userdata);


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<pre><code>typedef void *(gpioThreadFunc_t) (void *);


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<pre><code>typedef void (*gpioTimerFunc_t) (void);


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<pre><code>typedef void (*gpioTimerFuncEx_t) (void *userdata);


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
One of</p>
<p><br />
</p>
<p><br />
<strong>gpioWaveAddNew</strong><br />
<strong>gpioWaveAddGeneric</strong><br />
<strong>gpioWaveAddSerial</strong></p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
A number referencing an object opened by one of</p>
<p><br />
</p>
<p><br />
<strong>fileOpen</strong><br />
<strong>gpioNotifyOpen</strong><br />
<strong>i2cOpen</strong><br />
<strong>serOpen</strong><br />
<strong>spiOpen</strong></p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The address of a device on the I2C bus.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
An I2C bus number.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
Flags which modify an I2C open command. None are currently defined.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
A register of an I2C device.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<pre><code>PI_DISABLE_FIFO_IF 1


PI_DISABLE_SOCK_IF 2


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A buffer used to pass data to a function.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The number of bytes of data in a buffer.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A whole number, negative or positive.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A 32-bit signed value.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A flag used to set normal or inverted bit bang serial data level logic.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The level of a GPIO. Low or High.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>PI_OFF 0


PI_ON 1





PI_CLEAR 0


PI_SET 1





PI_LOW 0


PI_HIGH 1


</code></pre>
<p><br />
</p>
<p><br />
There is one exception. If a watchdog expires on a GPIO the level will be reported as PI_TIMEOUT. See <strong>gpioSetWatchdog</strong>.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>PI_TIMEOUT 2


</code></pre>
<p><br />
</p>
<p><br />
</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
A 32-bit word value.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
The DMA memory allocation mode.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>PI_MEM_ALLOC_AUTO    0


PI_MEM_ALLOC_PAGEMAP 1


PI_MEM_ALLOC_MAILBOX 2


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
A value representing microseconds.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
A value representing microseconds.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
A value representing milliseconds.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The GPIO used for the MISO signal when bit banging SPI.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
1. The operational mode of a GPIO, normally INPUT or OUTPUT.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>PI_INPUT 0


PI_OUTPUT 1


PI_ALT0 4


PI_ALT1 5


PI_ALT2 6


PI_ALT3 7


PI_ALT4 3


PI_ALT5 2


</code></pre>
<p><br />
</p>
<p><br />
2. A file open mode.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>PI_FILE_READ  1


PI_FILE_WRITE 2


PI_FILE_RW    3


</code></pre>
<p><br />
</p>
<p><br />
The following values can be or'd into the mode.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>PI_FILE_APPEND 4


PI_FILE_CREATE 8


PI_FILE_TRUNC  16


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The GPIO used for the MOSI signal when bit banging SPI.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
The number of bits stored in a buffer.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The number of bytes used to store characters in a string. Depending on the number of bits per character there may be 1, 2, or 4 bytes per character.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The number of parameters passed to a script.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The number of pulses to be added to a waveform.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The number of segments in a combined I2C transaction.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The number of network addresses allowed to use the socket interface.</p></li>
</ul>
<p><br />
</p>
<p><br />
0 means all addresses allowed.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The associated data starts this number of microseconds from the start of the waveform.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A buffer used to return data from a function.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The size in bytes of an output buffer.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A set of GPIO which share common drivers.</p></li>
</ul>
<p><br />
</p>
<p><br />
Pad GPIO<br />
0 0-27<br />
1 28-45<br />
2 46-53<br />
</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The mA which may be drawn from each GPIO whilst still guaranteeing the high and low levels.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>An array of script parameters.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>percent On-Off-Level (OOL) buffer to consume for wave output.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>the percent of all DMA control blocks to consume.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>the percent of OOL buffer to consume for wave input (flags).</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<pre><code>typedef struct


{


   uint16_t addr;  // slave address


   uint16_t flags;


   uint16_t len;   // msg length


   uint8_t  *buf;  // pointer to msg data


} pi_i2c_msg_t;


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The port used to bind to the pigpio socket. Defaults to 8888.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The position of an item.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The DMA channel used to time the sampling of GPIO and to time servo and PWM pulses.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
A thread identifier, returned by <strong>gpioStartThread</strong>.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
A thread identifier.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
The setting of the pull up/down resistor for a GPIO, which may be off, pull-up, or pull-down.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>PI_PUD_OFF 0


PI_PUD_DOWN 1


PI_PUD_UP 2


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
1-100, the length of a trigger pulse in microseconds.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
An array of pulses to be added to a waveform.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<pre><code>PI_SERVO_OFF 0


PI_MIN_SERVO_PULSEWIDTH 500


PI_MAX_SERVO_PULSEWIDTH 2500


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The hardware PWM dutycycle.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>PI_HW_PWM_RANGE 1000000


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The hardware PWM frequency.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>PI_HW_PWM_MIN_FREQ 1


PI_HW_PWM_MAX_FREQ 125000000


PI_HW_PWM_MAX_FREQ_2711 187500000


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<pre><code>PI_MIN_DUTYCYCLE_RANGE 25


PI_MAX_DUTYCYCLE_RANGE 40000


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<pre><code>typedef struct // linux/arch/arm/mach-bcm2708/include/mach/dma.h


{


   unsigned long info;


   unsigned long src;


   unsigned long dst;


   unsigned long length;


   unsigned long stride;


   unsigned long next;


   unsigned long pad[2];


} rawCbs_t;


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<pre><code>typedef struct


{


   int clk;     // GPIO for clock


   int mosi;    // GPIO for MOSI


   int miso;    // GPIO for MISO


   int ss_pol;  // slave select off state


   int ss_us;   // delay after slave select


   int clk_pol; // clock off state


   int clk_pha; // clock phase


   int clk_us;  // clock micros


} rawSPI_t;


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<pre><code>typedef struct


{


   uint32_t gpioOn;


   uint32_t gpioOff;


   uint32_t usDelay;


   uint32_t flags;


} rawWave_t;


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<pre><code>typedef struct


{


   uint16_t botCB;  // first CB used by wave


   uint16_t topCB;  // last CB used by wave


   uint16_t botOOL; // last OOL used by wave


   uint16_t topOOL; // first OOL used by wave


   uint16_t deleted;


   uint16_t numCB;


   uint16_t numBOOL;


   uint16_t numTOOL;


} rawWaveInfo_t;


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
A buffer to hold a number of bytes returned to a used customised function,</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
The maximum number of bytes a user customised function should return.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
A pointer to a buffer to receive data.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The user GPIO to use for the clock when bit banging I2C.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The GPIO used for the SCLK signal when bit banging SPI.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A pointer to the text of a script.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>An id of a stored script as returned by <strong>gpioStoreScript</strong>.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The name of a <strong>shell</strong> script to be executed. The script must be present in /opt/pigpio/cgi and must have execute permission.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The string to be passed to a <strong>shell</strong> script to be executed.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The user GPIO to use for data when bit banging I2C.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
The DMA channel used to time output waveforms.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
A pointer to a uint32_t to store the second component of a returned time.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The number of seconds.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>PI_FROM_START   0


PI_FROM_CURRENT 1


PI_FROM_END     2


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The number of bytes to move forward (positive) or backwards (negative) from the seek position (start, current, or end of file).</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>An array of segments which make up a combined I2C transaction.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>Flags which modify a serial open command. None are currently defined.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The name of a serial tty device, e.g. /dev/ttyAMA0, /dev/ttyUSB0, /dev/tty1.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A value used to set a flag, 0 for false, non-zero for true.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<pre><code>PI_MIN_SIGNUM 0


PI_MAX_SIGNUM 63


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
A standard type used to indicate the size of an object in bytes.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>An array of network addresses allowed to use the socket interface encoded as 32 bit numbers.</p></li>
</ul>
<p><br />
</p>
<p><br />
E.g. address 192.168.1.66 would be encoded as 0x4201a8c0.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A pointer to a <strong>rawSPI_t</strong> structure.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>GPIO reads are made from spiBitFirst to spiBitLast.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
GPIO reads are made from spiBitFirst to spiBitLast.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The number of bits to transfer in a raw SPI transaction.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A SPI channel, 0-2.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>See <strong>spiOpen</strong> and <strong>bbSPIOpen</strong>.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The SPI slave select GPIO in a raw SPI transaction.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The number of bits to transfer dring a raw SPI transaction</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
The number of microseconds level changes must be stable for before reporting the level changed (<strong>gpioGlitchFilter</strong>) or triggering the active part of a noise filter (<strong>gpioNoiseFilter</strong>).</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>The number of (half) stop bits to be used when adding serial data to a waveform.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<pre><code>PI_MIN_WAVE_HALFSTOPBITS 2


PI_MAX_WAVE_HALFSTOPBITS 8


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>An array of characters.</p></li>
</ul>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A GPIO level change timeout in milliseconds.</p></li>
</ul>
<p><br />
</p>
<p><br />
<strong>gpioSetWatchdog</strong></p>
<pre><code>PI_MIN_WDOG_TIMEOUT 0


PI_MAX_WDOG_TIMEOUT 60000


</code></pre>
<p><br />
</p>
<p><br />
<strong>gpioSetISRFunc</strong> and <strong>gpioSetISRFuncEx</strong></p>
<pre><code>&lt;=0 cancel timeout


&gt;0 timeout after specified milliseconds


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<pre><code>PI_MIN_TIMER 0


PI_MAX_TIMER 9


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<pre><code>PI_TIME_RELATIVE 0


PI_TIME_ABSOLUTE 1


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
An array of bytes to transmit.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
A 32-bit unsigned value.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
A 64-bit unsigned value.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
A whole number &gt;= 0.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
A 64 bit mask indicating which GPIO may be written to by the user.</p>
<p><br />
</p>
<p><br />
If GPIO#n may be written then bit (1&lt;&lt;n) is set.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
0-31, a Broadcom numbered GPIO.</p>
<p><br />
</p>
<p><br />
See <strong>gpio</strong>.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li><p>A pointer to arbitrary user data. This may be used to identify the instance.</p></li>
</ul>
<p><br />
</p>
<p><br />
You must ensure that the pointer is in scope at the time it is processed. If it is a pointer to a global this is automatic. Do not pass the address of a local variable. If you want to pass a transient object then use the following technique.</p>
<p><br />
</p>
<p><br />
In the calling function:</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_type *userdata;






user_type my_userdata;





userdata = malloc(sizeof(user_type));






*userdata = my_userdata;


</code></pre>
<p><br />
</p>
<p><br />
In the receiving function:</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>user_type my_userdata = *(user_type*)userdata;





free(userdata);


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
Denoting no parameter is required</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
A number identifying a waveform created by <strong>gpioWaveCreate</strong>.</p>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
The mode determines if the waveform is sent once or cycles repeatedly. The SYNC variants wait for the current waveform to reach the end of a cycle or finish before starting the new waveform.</p>
<p><br />
</p>
<p><br />
</p>
<pre><code>PI_WAVE_MODE_ONE_SHOT      0


PI_WAVE_MODE_REPEAT        1


PI_WAVE_MODE_ONE_SHOT_SYNC 2


PI_WAVE_MODE_REPEAT_SYNC   3


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
</p>
<p><br />
A 16-bit word value.</p>
<p><br />
</p>
<p><br />
</p>
<h1>Socket Command Codes</h1>
<pre><code>


#define PI_CMD_MODES  0


#define PI_CMD_MODEG  1


#define PI_CMD_PUD    2


#define PI_CMD_READ   3


#define PI_CMD_WRITE  4


#define PI_CMD_PWM    5


#define PI_CMD_PRS    6


#define PI_CMD_PFS    7


#define PI_CMD_SERVO  8


#define PI_CMD_WDOG   9


#define PI_CMD_BR1   10


#define PI_CMD_BR2   11


#define PI_CMD_BC1   12


#define PI_CMD_BC2   13


#define PI_CMD_BS1   14


#define PI_CMD_BS2   15


#define PI_CMD_TICK  16


#define PI_CMD_HWVER 17


#define PI_CMD_NO    18


#define PI_CMD_NB    19


#define PI_CMD_NP    20


#define PI_CMD_NC    21


#define PI_CMD_PRG   22


#define PI_CMD_PFG   23


#define PI_CMD_PRRG  24


#define PI_CMD_HELP  25


#define PI_CMD_PIGPV 26


#define PI_CMD_WVCLR 27


#define PI_CMD_WVAG  28


#define PI_CMD_WVAS  29


#define PI_CMD_WVGO  30


#define PI_CMD_WVGOR 31


#define PI_CMD_WVBSY 32


#define PI_CMD_WVHLT 33


#define PI_CMD_WVSM  34


#define PI_CMD_WVSP  35


#define PI_CMD_WVSC  36


#define PI_CMD_TRIG  37


#define PI_CMD_PROC  38


#define PI_CMD_PROCD 39


#define PI_CMD_PROCR 40


#define PI_CMD_PROCS 41


#define PI_CMD_SLRO  42


#define PI_CMD_SLR   43


#define PI_CMD_SLRC  44


#define PI_CMD_PROCP 45


#define PI_CMD_MICS  46


#define PI_CMD_MILS  47


#define PI_CMD_PARSE 48


#define PI_CMD_WVCRE 49


#define PI_CMD_WVDEL 50


#define PI_CMD_WVTX  51


#define PI_CMD_WVTXR 52


#define PI_CMD_WVNEW 53





#define PI_CMD_I2CO  54


#define PI_CMD_I2CC  55


#define PI_CMD_I2CRD 56


#define PI_CMD_I2CWD 57


#define PI_CMD_I2CWQ 58


#define PI_CMD_I2CRS 59


#define PI_CMD_I2CWS 60


#define PI_CMD_I2CRB 61


#define PI_CMD_I2CWB 62


#define PI_CMD_I2CRW 63


#define PI_CMD_I2CWW 64


#define PI_CMD_I2CRK 65


#define PI_CMD_I2CWK 66


#define PI_CMD_I2CRI 67


#define PI_CMD_I2CWI 68


#define PI_CMD_I2CPC 69


#define PI_CMD_I2CPK 70





#define PI_CMD_SPIO  71


#define PI_CMD_SPIC  72


#define PI_CMD_SPIR  73


#define PI_CMD_SPIW  74


#define PI_CMD_SPIX  75





#define PI_CMD_SERO  76


#define PI_CMD_SERC  77


#define PI_CMD_SERRB 78


#define PI_CMD_SERWB 79


#define PI_CMD_SERR  80


#define PI_CMD_SERW  81


#define PI_CMD_SERDA 82





#define PI_CMD_GDC   83


#define PI_CMD_GPW   84





#define PI_CMD_HC    85


#define PI_CMD_HP    86





#define PI_CMD_CF1   87


#define PI_CMD_CF2   88





#define PI_CMD_BI2CC 89


#define PI_CMD_BI2CO 90


#define PI_CMD_BI2CZ 91





#define PI_CMD_I2CZ  92





#define PI_CMD_WVCHA 93





#define PI_CMD_SLRI  94





#define PI_CMD_CGI   95


#define PI_CMD_CSI   96





#define PI_CMD_FG    97


#define PI_CMD_FN    98





#define PI_CMD_NOIB  99





#define PI_CMD_WVTXM 100


#define PI_CMD_WVTAT 101





#define PI_CMD_PADS  102


#define PI_CMD_PADG  103





#define PI_CMD_FO    104


#define PI_CMD_FC    105


#define PI_CMD_FR    106


#define PI_CMD_FW    107


#define PI_CMD_FS    108


#define PI_CMD_FL    109





#define PI_CMD_SHELL 110





#define PI_CMD_BSPIC 111


#define PI_CMD_BSPIO 112


#define PI_CMD_BSPIX 113





#define PI_CMD_BSCX  114





#define PI_CMD_EVM   115


#define PI_CMD_EVT   116





#define PI_CMD_PROCU 117


#define PI_CMD_WVCAP 118





</code></pre>
<h1>Error Codes</h1>
<pre><code>


#define PI_INIT_FAILED       -1 // gpioInitialise failed


#define PI_BAD_USER_GPIO     -2 // GPIO not 0-31


#define PI_BAD_GPIO          -3 // GPIO not 0-53


#define PI_BAD_MODE          -4 // mode not 0-7


#define PI_BAD_LEVEL         -5 // level not 0-1


#define PI_BAD_PUD           -6 // pud not 0-2


#define PI_BAD_PULSEWIDTH    -7 // pulsewidth not 0 or 500-2500


#define PI_BAD_DUTYCYCLE     -8 // dutycycle outside set range


#define PI_BAD_TIMER         -9 // timer not 0-9


#define PI_BAD_MS           -10 // ms not 10-60000


#define PI_BAD_TIMETYPE     -11 // timetype not 0-1


#define PI_BAD_SECONDS      -12 // seconds &lt; 0


#define PI_BAD_MICROS       -13 // micros not 0-999999


#define PI_TIMER_FAILED     -14 // gpioSetTimerFunc failed


#define PI_BAD_WDOG_TIMEOUT -15 // timeout not 0-60000


#define PI_NO_ALERT_FUNC    -16 // DEPRECATED


#define PI_BAD_CLK_PERIPH   -17 // clock peripheral not 0-1


#define PI_BAD_CLK_SOURCE   -18 // DEPRECATED


#define PI_BAD_CLK_MICROS   -19 // clock micros not 1, 2, 4, 5, 8, or 10


#define PI_BAD_BUF_MILLIS   -20 // buf millis not 100-10000


#define PI_BAD_DUTYRANGE    -21 // dutycycle range not 25-40000


#define PI_BAD_DUTY_RANGE   -21 // DEPRECATED (use PI_BAD_DUTYRANGE)


#define PI_BAD_SIGNUM       -22 // signum not 0-63


#define PI_BAD_PATHNAME     -23 // can&#39;t open pathname


#define PI_NO_HANDLE        -24 // no handle available


#define PI_BAD_HANDLE       -25 // unknown handle


#define PI_BAD_IF_FLAGS     -26 // ifFlags &gt; 4


#define PI_BAD_CHANNEL      -27 // DMA channel not 0-15


#define PI_BAD_PRIM_CHANNEL -27 // DMA primary channel not 0-15


#define PI_BAD_SOCKET_PORT  -28 // socket port not 1024-32000


#define PI_BAD_FIFO_COMMAND -29 // unrecognized fifo command


#define PI_BAD_SECO_CHANNEL -30 // DMA secondary channel not 0-15


#define PI_NOT_INITIALISED  -31 // function called before gpioInitialise


#define PI_INITIALISED      -32 // function called after gpioInitialise


#define PI_BAD_WAVE_MODE    -33 // waveform mode not 0-3


#define PI_BAD_CFG_INTERNAL -34 // bad parameter in gpioCfgInternals call


#define PI_BAD_WAVE_BAUD    -35 // baud rate not 50-250K(RX)/50-1M(TX)


#define PI_TOO_MANY_PULSES  -36 // waveform has too many pulses


#define PI_TOO_MANY_CHARS   -37 // waveform has too many chars


#define PI_NOT_SERIAL_GPIO  -38 // no bit bang serial read on GPIO


#define PI_BAD_SERIAL_STRUC -39 // bad (null) serial structure parameter


#define PI_BAD_SERIAL_BUF   -40 // bad (null) serial buf parameter


#define PI_NOT_PERMITTED    -41 // GPIO operation not permitted


#define PI_SOME_PERMITTED   -42 // one or more GPIO not permitted


#define PI_BAD_WVSC_COMMND  -43 // bad WVSC subcommand


#define PI_BAD_WVSM_COMMND  -44 // bad WVSM subcommand


#define PI_BAD_WVSP_COMMND  -45 // bad WVSP subcommand


#define PI_BAD_PULSELEN     -46 // trigger pulse length not 1-100


#define PI_BAD_SCRIPT       -47 // invalid script


#define PI_BAD_SCRIPT_ID    -48 // unknown script id


#define PI_BAD_SER_OFFSET   -49 // add serial data offset &gt; 30 minutes


#define PI_GPIO_IN_USE      -50 // GPIO already in use


#define PI_BAD_SERIAL_COUNT -51 // must read at least a byte at a time


#define PI_BAD_PARAM_NUM    -52 // script parameter id not 0-9


#define PI_DUP_TAG          -53 // script has duplicate tag


#define PI_TOO_MANY_TAGS    -54 // script has too many tags


#define PI_BAD_SCRIPT_CMD   -55 // illegal script command


#define PI_BAD_VAR_NUM      -56 // script variable id not 0-149


#define PI_NO_SCRIPT_ROOM   -57 // no more room for scripts


#define PI_NO_MEMORY        -58 // can&#39;t allocate temporary memory


#define PI_SOCK_READ_FAILED -59 // socket read failed


#define PI_SOCK_WRIT_FAILED -60 // socket write failed


#define PI_TOO_MANY_PARAM   -61 // too many script parameters (&gt; 10)


#define PI_NOT_HALTED       -62 // DEPRECATED


#define PI_SCRIPT_NOT_READY -62 // script initialising


#define PI_BAD_TAG          -63 // script has unresolved tag


#define PI_BAD_MICS_DELAY   -64 // bad MICS delay (too large)


#define PI_BAD_MILS_DELAY   -65 // bad MILS delay (too large)


#define PI_BAD_WAVE_ID      -66 // non existent wave id


#define PI_TOO_MANY_CBS     -67 // No more CBs for waveform


#define PI_TOO_MANY_OOL     -68 // No more OOL for waveform


#define PI_EMPTY_WAVEFORM   -69 // attempt to create an empty waveform


#define PI_NO_WAVEFORM_ID   -70 // no more waveforms


#define PI_I2C_OPEN_FAILED  -71 // can&#39;t open I2C device


#define PI_SER_OPEN_FAILED  -72 // can&#39;t open serial device


#define PI_SPI_OPEN_FAILED  -73 // can&#39;t open SPI device


#define PI_BAD_I2C_BUS      -74 // bad I2C bus


#define PI_BAD_I2C_ADDR     -75 // bad I2C address


#define PI_BAD_SPI_CHANNEL  -76 // bad SPI channel


#define PI_BAD_FLAGS        -77 // bad i2c/spi/ser open flags


#define PI_BAD_SPI_SPEED    -78 // bad SPI speed


#define PI_BAD_SER_DEVICE   -79 // bad serial device name


#define PI_BAD_SER_SPEED    -80 // bad serial baud rate


#define PI_BAD_PARAM        -81 // bad i2c/spi/ser parameter


#define PI_I2C_WRITE_FAILED -82 // i2c write failed


#define PI_I2C_READ_FAILED  -83 // i2c read failed


#define PI_BAD_SPI_COUNT    -84 // bad SPI count


#define PI_SER_WRITE_FAILED -85 // ser write failed


#define PI_SER_READ_FAILED  -86 // ser read failed


#define PI_SER_READ_NO_DATA -87 // ser read no data available


#define PI_UNKNOWN_COMMAND  -88 // unknown command


#define PI_SPI_XFER_FAILED  -89 // spi xfer/read/write failed


#define PI_BAD_POINTER      -90 // bad (NULL) pointer


#define PI_NO_AUX_SPI       -91 // no auxiliary SPI on Pi A or B


#define PI_NOT_PWM_GPIO     -92 // GPIO is not in use for PWM


#define PI_NOT_SERVO_GPIO   -93 // GPIO is not in use for servo pulses


#define PI_NOT_HCLK_GPIO    -94 // GPIO has no hardware clock


#define PI_NOT_HPWM_GPIO    -95 // GPIO has no hardware PWM


#define PI_BAD_HPWM_FREQ    -96 // invalid hardware PWM frequency


#define PI_BAD_HPWM_DUTY    -97 // hardware PWM dutycycle not 0-1M


#define PI_BAD_HCLK_FREQ    -98 // invalid hardware clock frequency


#define PI_BAD_HCLK_PASS    -99 // need password to use hardware clock 1


#define PI_HPWM_ILLEGAL    -100 // illegal, PWM in use for main clock


#define PI_BAD_DATABITS    -101 // serial data bits not 1-32


#define PI_BAD_STOPBITS    -102 // serial (half) stop bits not 2-8


#define PI_MSG_TOOBIG      -103 // socket/pipe message too big


#define PI_BAD_MALLOC_MODE -104 // bad memory allocation mode


#define PI_TOO_MANY_SEGS   -105 // too many I2C transaction segments


#define PI_BAD_I2C_SEG     -106 // an I2C transaction segment failed


#define PI_BAD_SMBUS_CMD   -107 // SMBus command not supported by driver


#define PI_NOT_I2C_GPIO    -108 // no bit bang I2C in progress on GPIO


#define PI_BAD_I2C_WLEN    -109 // bad I2C write length


#define PI_BAD_I2C_RLEN    -110 // bad I2C read length


#define PI_BAD_I2C_CMD     -111 // bad I2C command


#define PI_BAD_I2C_BAUD    -112 // bad I2C baud rate, not 50-500k


#define PI_CHAIN_LOOP_CNT  -113 // bad chain loop count


#define PI_BAD_CHAIN_LOOP  -114 // empty chain loop


#define PI_CHAIN_COUNTER   -115 // too many chain counters


#define PI_BAD_CHAIN_CMD   -116 // bad chain command


#define PI_BAD_CHAIN_DELAY -117 // bad chain delay micros


#define PI_CHAIN_NESTING   -118 // chain counters nested too deeply


#define PI_CHAIN_TOO_BIG   -119 // chain is too long


#define PI_DEPRECATED      -120 // deprecated function removed


#define PI_BAD_SER_INVERT  -121 // bit bang serial invert not 0 or 1


#define PI_BAD_EDGE        -122 // bad ISR edge value, not 0-2


#define PI_BAD_ISR_INIT    -123 // bad ISR initialisation


#define PI_BAD_FOREVER     -124 // loop forever must be last command


#define PI_BAD_FILTER      -125 // bad filter parameter


#define PI_BAD_PAD         -126 // bad pad number


#define PI_BAD_STRENGTH    -127 // bad pad drive strength


#define PI_FIL_OPEN_FAILED -128 // file open failed


#define PI_BAD_FILE_MODE   -129 // bad file mode


#define PI_BAD_FILE_FLAG   -130 // bad file flag


#define PI_BAD_FILE_READ   -131 // bad file read


#define PI_BAD_FILE_WRITE  -132 // bad file write


#define PI_FILE_NOT_ROPEN  -133 // file not open for read


#define PI_FILE_NOT_WOPEN  -134 // file not open for write


#define PI_BAD_FILE_SEEK   -135 // bad file seek


#define PI_NO_FILE_MATCH   -136 // no files match pattern


#define PI_NO_FILE_ACCESS  -137 // no permission to access file


#define PI_FILE_IS_A_DIR   -138 // file is a directory


#define PI_BAD_SHELL_STATUS -139 // bad shell return status


#define PI_BAD_SCRIPT_NAME -140 // bad script name


#define PI_BAD_SPI_BAUD    -141 // bad SPI baud rate, not 50-500k


#define PI_NOT_SPI_GPIO    -142 // no bit bang SPI in progress on GPIO


#define PI_BAD_EVENT_ID    -143 // bad event id


#define PI_CMD_INTERRUPTED -144 // Used by Python


#define PI_NOT_ON_BCM2711  -145 // not available on BCM2711


#define PI_ONLY_ON_BCM2711 -146 // only available on BCM2711





#define PI_PIGIF_ERR_0    -2000


#define PI_PIGIF_ERR_99   -2099





#define PI_CUSTOM_ERR_0   -3000


#define PI_CUSTOM_ERR_999 -3999





</code></pre>
<h1>Defaults</h1>
<pre><code>


#define PI_DEFAULT_BUFFER_MILLIS           120


#define PI_DEFAULT_CLK_MICROS              5


#define PI_DEFAULT_CLK_PERIPHERAL          PI_CLOCK_PCM


#define PI_DEFAULT_IF_FLAGS                0


#define PI_DEFAULT_FOREGROUND              0


#define PI_DEFAULT_DMA_CHANNEL             14


#define PI_DEFAULT_DMA_PRIMARY_CHANNEL     14


#define PI_DEFAULT_DMA_SECONDARY_CHANNEL   6


#define PI_DEFAULT_DMA_PRIMARY_CH_2711     7


#define PI_DEFAULT_DMA_SECONDARY_CH_2711   6


#define PI_DEFAULT_DMA_NOT_SET             15


#define PI_DEFAULT_SOCKET_PORT             8888


#define PI_DEFAULT_SOCKET_PORT_STR         &quot;8888&quot;


#define PI_DEFAULT_SOCKET_ADDR_STR         &quot;localhost&quot;


#define PI_DEFAULT_UPDATE_MASK_UNKNOWN     0x0000000FFFFFFCLL


#define PI_DEFAULT_UPDATE_MASK_B1          0x03E7CF93


#define PI_DEFAULT_UPDATE_MASK_A_B2        0xFBC7CF9C


#define PI_DEFAULT_UPDATE_MASK_APLUS_BPLUS 0x0080480FFFFFFCLL


#define PI_DEFAULT_UPDATE_MASK_ZERO        0x0080000FFFFFFCLL


#define PI_DEFAULT_UPDATE_MASK_PI2B        0x0080480FFFFFFCLL


#define PI_DEFAULT_UPDATE_MASK_PI3B        0x0000000FFFFFFCLL


#define PI_DEFAULT_UPDATE_MASK_PI4B        0x0000000FFFFFFCLL


#define PI_DEFAULT_UPDATE_MASK_COMPUTE     0x00FFFFFFFFFFFFLL


#define PI_DEFAULT_MEM_ALLOC_MODE          PI_MEM_ALLOC_AUTO





#define PI_DEFAULT_CFG_INTERNALS           0





</code></pre>
<h1>SEE ALSO</h1>
<p>pigpiod(1), pig2vcd(1), pigs(1), pigpiod_if(3), pigpiod_if2(3)</p>
<h1>AUTHOR</h1>
<p>joan@abyz.me.uk</p>
<footer style="text-align: center;"><a href="https://blog.tamer.pw" target="_blank">Blog</a> | <a href="https://github.com/linuxtamer" target="_blank">Contact</a></footer>
</div>
</body>
</html>

