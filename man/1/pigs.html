<!DOCTYPE html>
<html lang=en-US>
<head>
<meta charset=utf-8>
<title>Linux command pigs</title><meta name="description" content="Linux command pigs command line socket access to the pigpio daemon."><meta name="keywords" content="linux, command, pigs, bsd, command line socket access to the pigpio daemon."><meta name="robots" content="index,follow">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="container">

<h1>NAME</h1>
<p>pigs - command line socket access to the pigpio daemon.</p>
<p>/dev/pigpio - command line pipe access to the pigpio daemon.</p>
<h1>SYNOPSIS</h1>
<p><strong>sudo pigpiod</strong></p>
<p>then</p>
<p><strong>pigs {command}+</strong></p>
<p>or</p>
<p><strong>echo {command}+ &gt;/dev/pigpio</strong></p>
<h1>DESCRIPTION</h1>
<p><br />
The socket and pipe interfaces allow control of the Pi's GPIO by passing messages to the running pigpio library.</p>
<p><br />
The normal way to start the pigpio library would be as a daemon during boot.</p>
<p><br />
</p>
<pre><code>sudo pigpiod


</code></pre>
<p><br />
</p>
<h2>Features</h2>
<p><br />
o hardware timed PWM on any of GPIO 0-31</p>
<p><br />
o hardware timed servo pulses on any of GPIO 0-31</p>
<p><br />
o reading/writing all of the GPIO in a bank as one operation</p>
<p><br />
o individually setting GPIO modes, reading and writing</p>
<p><br />
o notifications when any of GPIO 0-31 change state</p>
<p><br />
o the construction of output waveforms with microsecond timing</p>
<p><br />
o I2C, SPI, and serial link wrappers</p>
<p><br />
o creating and running scripts on the pigpio daemon</p>
<p><br />
</p>
<h2>GPIO</h2>
<p><br />
ALL GPIO are identified by their Broadcom number.</p>
<p><br />
</p>
<h2>Usage</h2>
<p><br />
pigs is a program and internally uses the socket interface to pigpio whereas /dev/pigpio uses the pipe interface.</p>
<p><br />
pigs and the pipe interface share the same commands and are invoked in a similar fashion from the command line.</p>
<p><br />
The pigpio library must be running, either by running a program linked with the library or starting the pigpio daemon (sudo pigpiod).</p>
<p><br />
pigs {command}+</p>
<p><br />
echo "{command}+" &gt;/dev/pigpio</p>
<p><br />
pigs will show the result of the command on screen.</p>
<p><br />
The pigs process returns an exit status (which can be displayed with the command echo $?).</p>
<p><br />
</p>
<pre><code>PIGS_OK            0


PIGS_CONNECT_ERR 255


PIGS_OPTION_ERR  254


PIGS_SCRIPT_ERR  253






</code></pre>
<p><br />
The results of /dev/pigpio commands need to be read from /dev/pigout, e.g. cat /dev/pigout (try cat /dev/pigout&amp; so that all subsequent results are shown on screen).</p>
<p><br />
In both cases if an error was detected a message will have been written to /dev/pigerr (try cat /dev/pigerr&amp;). This is likely to be more informative than the message returned by pigs or the error code returned by the pipe interface.</p>
<p><br />
Several commands may be entered on a line. If present PROC and PARSE must be the last command on a line.</p>
<p><br />
E.g.</p>
<p><br />
</p>
<pre><code>pigs w 22 1 mils 1000 w 22 0


</code></pre>
<p><br />
is equivalent to</p>
<p><br />
</p>
<pre><code>pigs w 22 1


pigs mils 1000


pigs w 22 0


</code></pre>
<p><br />
and</p>
<p><br />
</p>
<pre><code>echo &quot;m 4 w w 4 0 mils 250 m 4 r r 4&quot; &gt;/dev/pigpio


</code></pre>
<p><br />
is equivalent to</p>
<p><br />
</p>
<pre><code>echo &quot;m 4 w&quot;    &gt;/dev/pigpio


echo &quot;w 4 0&quot;    &gt;/dev/pigpio


echo &quot;mils 250&quot; &gt;/dev/pigpio


echo &quot;m 4 r&quot;    &gt;/dev/pigpio


echo &quot;r 4&quot;      &gt;/dev/pigpio


</code></pre>
<p><br />
</p>
<h2>Notes</h2>
<p><br />
The examples from now on will show the pigs interface but the same commands will also work on the pipe interface.</p>
<p><br />
pigs does not show the status of successful commands unless the command itself returns data. The status (0) will be returned to pigs but will be discarded.</p>
<p><br />
The status/data of each command sent to the pipe interface should be read from /dev/pigout.</p>
<p><br />
When a command takes a number as a parameter it may be entered as hex (precede by 0x), octal (precede by 0), or decimal.</p>
<p><br />
E.g. 23 is 23 decimal, 0x100 is 256 decimal, 070 is 56 decimal.</p>
<p><br />
Some commands can return a variable number of data bytes. By default this data is displayed as decimal. The pigs -a option can be used to force the display as ASCII and the pigs -x option can be used to force the display as hex.</p>
<p><br />
E.g. assuming the transmitted serial data is the letters ABCDEONM</p>
<p><br />
</p>
<pre><code>$ pigs slr 4 100


8 65 66 67 68 69 79 78 77





$ pigs -a slr 4 100


8 ABCDEONM





$ pigs -x slr 4 100


8 41 42 43 44 45 4f 4e 4d


</code></pre>
<p><br />
</p>
<h1>OVERVIEW</h1>
<h2>BASIC</h2>
<p><strong>M/MODES g m</strong> Set GPIO mode</p>
<p><strong>MG/MODEG g</strong> Get GPIO mode</p>
<p><strong>PUD g p</strong> Set GPIO pull up/down</p>
<p><strong>R/READ g</strong> Read GPIO level</p>
<p><strong>W/WRITE g L</strong> Write GPIO level</p>
<h2>PWM (overrides servo commands on same GPIO)</h2>
<p><strong>P/PWM u v</strong> Set GPIO PWM value</p>
<p><strong>PFS u v</strong> Set GPIO PWM frequency</p>
<p><strong>PRS u v</strong> Set GPIO PWM range</p>
<p><strong>GDC u</strong> Get GPIO PWM dutycycle</p>
<p><strong>PFG u</strong> Get GPIO PWM frequency</p>
<p><strong>PRG u</strong> Get GPIO PWM range</p>
<p><strong>PRRG u</strong> Get GPIO PWM real range</p>
<h2>Servo (overrides PWM commands on same GPIO)</h2>
<p><strong>S/SERVO u v</strong> Set GPIO servo pulsewidth</p>
<p><strong>GPW u</strong> Get GPIO servo pulsewidth</p>
<h2>INTERMEDIATE</h2>
<p><strong>TRIG u pl L</strong> Send a trigger pulse</p>
<p><strong>WDOG u v</strong> Set GPIO watchdog</p>
<p><strong>BR1</strong> Read bank 1 GPIO</p>
<p><strong>BR2</strong> Read bank 2 GPIO</p>
<p><strong>BC1 bits</strong> Clear specified GPIO in bank 1</p>
<p><strong>BC2 bits</strong> Clear specified GPIO in bank 2</p>
<p><strong>BS1 bits</strong> Set specified GPIO in bank 1</p>
<p><strong>BS2 bits</strong> Set specified GPIO in bank 2</p>
<h2>ADVANCED</h2>
<p><strong>NO</strong> Request a notification</p>
<p><strong>NC h</strong> Close notification</p>
<p><strong>NB h bits</strong> Start notification</p>
<p><strong>NP h</strong> Pause notification</p>
<p><strong>HC g cf</strong> Set hardware clock frequency</p>
<p><strong>HP g pf pdc</strong> Set hardware PWM frequency and dutycycle</p>
<p><strong>FG u stdy</strong> Set a glitch filter on a GPIO</p>
<p><strong>FN u stdy actv</strong> Set a noise filter on a GPIO</p>
<p><strong>PADS pad padma</strong> Set pad drive strength</p>
<p><strong>PADG pad</strong> Get pad drive strength</p>
<p><strong>SHELL name str</strong> Execute a shell command</p>
<h2>Custom</h2>
<p><strong>CF1 uvs</strong> Custom function 1</p>
<p><strong>CF2 uvs</strong> Custom function 2</p>
<h2>Events</h2>
<p><strong>EVM h bits</strong> Set events to monitor</p>
<p><strong>EVT event</strong> Trigger event</p>
<h2>Scripts</h2>
<p><strong>PROC t</strong> Store script</p>
<p><strong>PROCR sid pars</strong> Run script</p>
<p><strong>PROCU sid pars</strong> Set script parameters</p>
<p><strong>PROCP sid</strong> Get script status and parameters</p>
<p><strong>PROCS sid</strong> Stop script</p>
<p><strong>PROCD sid</strong> Delete script</p>
<p><strong>PARSE t</strong> Validate script</p>
<h2>I2C</h2>
<p><strong>I2CO ib id if</strong> Open I2C bus and device with flags</p>
<p><strong>I2CC h</strong> Close I2C handle</p>
<p><strong>I2CWQ h bit</strong> smb Write Quick: write bit</p>
<p><strong>I2CRS h</strong> smb Read Byte: read byte</p>
<p><strong>I2CWS h bv</strong> smb Write Byte: write byte</p>
<p><strong>I2CRB h r</strong> smb Read Byte Data: read byte from register</p>
<p><strong>I2CWB h r bv</strong> smb Write Byte Data: write byte to register</p>
<p><strong>I2CRW h r</strong> smb Read Word Data: read word from register</p>
<p><strong>I2CWW h r wv</strong> smb Write Word Data: write word to register</p>
<p><strong>I2CRK h r</strong> smb Read Block Data: read data from register</p>
<p><strong>I2CWK h r bvs</strong> smb Write Block Data: write data to register</p>
<p><strong>I2CWI h r bvs</strong> smb Write I2C Block Data</p>
<p><strong>I2CRI h r num</strong> smb Read I2C Block Data: read bytes from register</p>
<p><strong>I2CRD h num</strong> i2c Read device</p>
<p><strong>I2CWD h bvs</strong> i2c Write device</p>
<p><strong>I2CPC h r wv</strong> smb Process Call: exchange register with word</p>
<p><strong>I2CPK h r bvs</strong> smb Block Process Call: exchange data bytes with register</p>
<p><strong>I2CZ h bvs</strong> Performs multiple I2C transactions</p>
<h2>I2C BIT BANG</h2>
<p><strong>BI2CO sda scl b</strong> Open bit bang I2C</p>
<p><strong>BI2CC sda</strong> Close bit bang I2C</p>
<p><strong>BI2CZ sda bvs</strong> I2C bit bang multiple transactions</p>
<h2>I2C/SPI SLAVE</h2>
<p><strong>BSCX bctl bvs</strong> BSC I2C/SPI transfer</p>
<h2>SERIAL</h2>
<p><strong>SERO dev b sef</strong> Open serial device dev at baud b with flags</p>
<p><strong>SERC h</strong> Close serial handle</p>
<p><strong>SERRB</strong> Read byte from serial handle</p>
<p><strong>SERWB h bv</strong> Write byte to serial handle</p>
<p><strong>SERR h num</strong> Read bytes from serial handle</p>
<p><strong>SERW h bvs</strong> Write bytes to serial handle</p>
<p><strong>SERDA h</strong> Check for serial data ready to read</p>
<h2>SERIAL BIT BANG (read only)</h2>
<p><strong>SLRO u b db</strong> Open GPIO for bit bang serial data</p>
<p><strong>SLRC u</strong> Close GPIO for bit bang serial data</p>
<p><strong>SLRI u v</strong> Sets bit bang serial data logic levels</p>
<p><strong>SLR u num</strong> Read bit bang serial data from GPIO</p>
<h2>SPI</h2>
<p><strong>SPIO c b spf</strong> SPI open channel at baud b with flags</p>
<p><strong>SPIC h</strong> SPI close handle</p>
<p><strong>SPIR h num</strong> SPI read bytes from handle</p>
<p><strong>SPIW h bvs</strong> SPI write bytes to handle</p>
<p><strong>SPIX h bvs</strong> SPI transfer bytes to handle</p>
<h2>SPI BIT BANG</h2>
<p><strong>BSPIO cs miso mosi sclk b spf</strong> Open bit bang SPI</p>
<p><strong>BSPIC cs</strong> Close bit bang SPI</p>
<p><strong>BSPIX cs bvs</strong> SPI bit bang transfer</p>
<h2>FILES</h2>
<p><strong>FO file mode</strong> Open a file in mode</p>
<p><strong>FC h</strong> Close file handle</p>
<p><strong>FR h num</strong> Read bytes from file handle</p>
<p><strong>FW h bvs</strong> Write bytes to file handle</p>
<p><strong>FS h num from</strong> Seek to file handle position</p>
<p><strong>FL pat num</strong> List files which match pattern</p>
<h2>WAVES</h2>
<p><strong>WVCLR</strong> Clear all waveforms</p>
<p><strong>WVNEW</strong> Initialise a new waveform</p>
<p><strong>WVAG trips</strong> Add generic pulses to waveform</p>
<p><strong>WVAS u b db sb o bvs</strong> Add serial data to waveform</p>
<p><strong>WVCRE</strong> Create a waveform</p>
<p><strong>WVCAP percent</strong> Create a waveform of fixed size</p>
<p><strong>WVDEL wid</strong> Delete selected waveform</p>
<p><strong>WVTX wid</strong> Transmits waveform once</p>
<p><strong>WVTXM wid wmde</strong> Transmits waveform using mode</p>
<p><strong>WVTXR wid</strong> Transmits waveform repeatedly</p>
<p><strong>WVCHA bvs</strong> Transmits a chain of waveforms</p>
<p><strong>WVTAT</strong> Returns the current transmitting waveform</p>
<p><strong>WVBSY</strong> Check if waveform is being transmitted</p>
<p><strong>WVHLT</strong> Stop waveform</p>
<p><strong>WVSC ws</strong> Get waveform DMA CB stats</p>
<p><strong>WVSM ws</strong> Get waveform time stats</p>
<p><strong>WVSP ws</strong> Get waveform pulse stats</p>
<h2>UTILITIES</h2>
<p><strong>H/HELP</strong> Display command help</p>
<p><strong>HWVER</strong> Get hardware version</p>
<p><strong>MICS v</strong> Microseconds delay</p>
<p><strong>MILS v</strong> Milliseconds delay</p>
<p><strong>PIGPV</strong> Get pigpio library version</p>
<p><strong>T/TICK</strong> Get current tick</p>
<h2>CONFIGURATION</h2>
<p><strong>CGI</strong> Configuration get internals</p>
<p><strong>CSI v</strong> Configuration set internals</p>
<h1>COMMANDS</h1>
<p><br />
</p>
<ul>
<li></li>
<li><p>This command clears (sets low) the GPIO specified by <strong>bits</strong> in bank 1. Bank 1 consists of GPIO 0-31.</p></li>
</ul>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs bc1 0x400010 # clear GPIO 4 (1&lt;&lt;4) and 22 (1&lt;&lt;22)





$ pigs bc1 32 # clear GPIO 5 (1&lt;&lt;5)


-42


ERROR: no permission to update one or more GPIO


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li><p>This command clears (sets low) the GPIO specified by <strong>bits</strong> in bank 2. Bank 2 consists of GPIO 32-53.</p></li>
</ul>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs bc2 0x8000 # clear GPIO 47 (activity LED on A+/B+/Pi2/Pi3)





$ pigs bc2 1 # clear GPIO 32 (first in bank 2)


-42


ERROR: no permission to update one or more GPIO


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li><p>This command signals that bit banging I2C on <strong>sda</strong> (and <strong>scl</strong>) is no longer required.</p></li>
</ul>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs bi2cc 5


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li><p>This command signals that GPIO <strong>sda</strong> and <strong>scl</strong> are to be used for bit banging I2C at <strong>b</strong> baud.</p></li>
</ul>
<p><br />
Bit banging I2C allows for certain operations which are not possible with the standard I2C driver.</p>
<p><br />
o baud rates as low as 50<br />
o repeated starts<br />
o clock stretching<br />
o I2C on any pair of spare GPIO</p>
<p><br />
The baud rate may be between 50 and 500000 bits per second.</p>
<p><br />
The GPIO used for SDA and SCL must have pull-ups to 3V3 connected. As a guide the hardware pull-ups on pins 3 and 5 are 1k8 in value.</p>
<p><br />
</p>
<ul>
<li></li>
<li><p>This function executes a sequence of bit banged I2C operations. The operations to be performed are specified by the contents of <strong>bvs</strong> which contains the concatenated command codes and associated data.</p></li>
</ul>
<p><br />
The following command codes are supported:</p>
<p><br />
</p>
<pre><code>Name      Cmd &amp; Data     Meaning
End       0              No more commands
Escape    1              Next P is two bytes
Start     2              Start condition
Stop      3              Stop condition
Address   4 P            Set I2C address to P
Flags     5 lsb msb      Set I2C flags to lsb + (msb &lt;&lt; 8)
Read      6 P            Read P bytes of data
Write     7 P ...        Write P bytes of data
</code></pre>
<p><br />
The address, read, and write commands take a parameter P. Normally P is one byte (0-255). If the command is preceded by the Escape command then P is two bytes (0-65535, least significant byte first).</p>
<p><br />
The address and flags default to 0. The address and flags maintain their previous value until updated.</p>
<p><br />
No flags are currently defined.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>Set address 0x53


start, write 0x32, (re)start, read 6 bytes, stop


Set address 0x1E


start, write 0x03, (re)start, read 6 bytes, stop


Set address 0x68


start, write 0x1B, (re)start, read 8 bytes, stop


End





0x04 0x53


0x02 0x07 0x01 0x32   0x02 0x06 0x06 0x03





0x04 0x1E


0x02 0x07 0x01 0x03   0x02 0x06 0x06 0x03





0x04 0x68


0x02 0x07 0x01 0x1B   0x02 0x06 0x08 0x03





0x00


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li><p>This command read GPIO 0-31 (bank 1) and returns the levels as a 32-bit hexadecimal value.</p></li>
</ul>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs br1


1001C1CF


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li><p>This command read GPIO 32-53 (bank 2) and returns the levels as a 32-bit hexadecimal value.</p></li>
</ul>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs br2


003F0000


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li><p>This command sets (sets high) the GPIO specified by <strong>bits</strong> in bank 1. Bank 1 consists of GPIO 0-31.</p></li>
</ul>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs bs1 16 # set GPIO 4 (1&lt;&lt;4)





$ pigs bs1 1 # set GPIO 1 (1&lt;&lt;0)


-42


ERROR: no permission to update one or more GPIO


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li><p>This command sets (sets high) the GPIO specified by <strong>bits</strong> in bank 2. Bank 2 consists of GPIO 32-53.</p></li>
</ul>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs bs2 0x40 # set GPIO 38 (enable high current mode A+/B+/Pi2/Pi3)





$ pigs bs2 1 # set GPIO 32 (first in bank 2)


-42


ERROR: no permission to update one or more GPIO


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command performs a BSC I2C/SPI slave transfer as defined by <strong>bctl</strong> with data <strong>bvs</strong>.</p>
<p><br />
This function provides a low-level interface to the SPI/I2C Slave peripheral on the BCM chip.</p>
<p><br />
This peripheral allows the Pi to act as a hardware slave device on an I2C or SPI bus.</p>
<p><br />
This is not a bit bang version and as such is OS timing independent. The bus timing is handled directly by the chip.</p>
<p><br />
The output process is simple. You simply append data to the FIFO buffer on the chip. This works like a queue, you add data to the queue and the master removes it.</p>
<p><br />
The command sets the BSC mode and writes any data <strong>bvs</strong> to the BSC transmit FIFO. It returns the data count (at least 1 for the status word), the status word, followed by any data bytes read from the BSC receive FIFO.</p>
<p><br />
Note that the control word sets the BSC mode. The BSC will stay in that mode until a different control word is sent.</p>
<p><br />
For I2C use a control word of (I2C address &lt;&lt; 16) + 0x305.</p>
<p><br />
E.g. to talk as I2C slave with address 0x13 use 0x130305.</p>
<p><br />
GPIO used for models other than those based on the BCM2711.</p>
<p><br />
</p>
<pre><code>      SDA   SCL   MOSI   SCLK   MISO   CE
I2C   18    19    -      -      -      -
SPI   -     -     20     19     18     21
</code></pre>
<p><br />
GPIO used for models based on the BCM2711 (e.g. the Pi4B).</p>
<p><br />
</p>
<pre><code>      SDA   SCL   MOSI   SCLK   MISO   CE
I2C   10    11    -      -      -      -
SPI   -     -     9      11     10     8
</code></pre>
<p><br />
When a zero control word is received the used GPIO will be reset to INPUT mode.</p>
<p><br />
The control word consists of the following bits.</p>
<p><br />
</p>
<pre><code>22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0


 a  a  a  a  a  a  a  -  - IT HC TF IR RE TE BK EC ES PL PH I2 SP EN


</code></pre>
<p><br />
Bits 0-13 are copied unchanged to the BSC CR register. See pages 163-165 of the Broadcom peripherals document for full details.</p>
<p><br />
</p>
<pre><code>aaaaaaa   defines the I2C slave address (only relevant in I2C mode)
IT        invert transmit status flags
HC        enable host control
TF        enable test FIFO
IR        invert receive status flags
RE        enable receive
TE        enable transmit
BK        abort operation and clear FIFOs
EC        send control register as first I2C byte
ES        send status register as first I2C byte
PL        set SPI polarity high
PH        set SPI phase high
I2        enable I2C mode
SP        enable SPI mode
EN        enable BSC peripheral
</code></pre>
<p><br />
The returned status has the following format</p>
<p><br />
</p>
<pre><code>20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0


 S  S  S  S  S  R  R  R  R  R  T  T  T  T  T RB TE RF TF RE TB


</code></pre>
<p><br />
Bits 0-15 are copied unchanged from the BSC FR register. See pages 165-166 of the Broadcom peripherals document for full details.</p>
<p><br />
</p>
<pre><code>SSSSS   number of bytes successfully copied to transmit FIFO
RRRRR   number of bytes in receieve FIFO
TTTTT   number of bytes in transmit FIFO
RB      receive busy
TE      transmit FIFO empty
RF      receive FIFO full
TF      transmit FIFO full
RE      receive FIFO empty
TB      transmit busy
</code></pre>
<p><br />
This example assumes that GPIO 2/3 are connected to GPIO 18/19 (GPIO 10/11 on the BCM2711).</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs bscx 0x130305 # start BSC as I2C slave 0x13


1 18





$ i2cdetect -y 1


     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f


00:          -- -- -- -- -- -- -- -- -- -- -- -- --


10: -- -- -- 13 -- -- -- -- -- -- -- -- -- -- -- --


20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


70: -- -- -- -- -- -- -- --





$ pigs i2co 1 0x13 0 # get handle for device 0x13 on bus 1


0





$ pigs i2cwd 0 90 87 51 9 23 # write 5 bytes





$ pigs bscx 0x130305 # check for data


6 18 90 87 51 9 23





$ pigs bscx 0x130305 11 13 15 17 # check for data and send 4 bytes


1 262338





$ pigs i2crd 0 4 # read 4 bytes


4 11 13 15 17





$ pigs i2cwd 0 90 87 51 9 23 # write 5 bytes


$ pigs bscx 0x130305 11 13 15 17 # check for data and send 4 bytes


6 262338 90 87 51 9 23





$ pigs i2crd 0 4


4 11 13 15 17





$ pigs bscx 0x130305 22 33 44 55 66


1 327938


$ pigs i2crd 0 5


5 22 33 44 55 66


</code></pre>
<p><br />
The BSC slave in SPI mode deserializes data from the MOSI pin into its receiver/ FIFO when the LSB of the first byte is a 0. No data is output on the MISO pin. When the LSB of the first byte on MOSI is a 1, the transmitter/FIFO data is serialized onto the MISO pin while all other data on the MOSI pin is ignored.</p>
<p><br />
The BK bit of the BSC control register is non-functional when in the SPI mode. The transmitter along with its FIFO can be dequeued by successively disabling and re-enabling the TE bit on the BSC control register while in SPI mode.</p>
<p><br />
This example demonstrates a SPI master talking to the BSC as SPI slave: Requires SPI master SCLK / MOSI / MISO / CE GPIO are connected to BSC peripheral GPIO 11 / 9 / 10 / 8 respectively, on a Pi4B (BCM2711).</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs bspio 15 26 13 14 10000 0 # open bit-bang spi master on random gpio





$ pigs bscx 0x303 # start BSC as SPI slave, both rx and tx enabled


1 18





$ pigs bspix 15 0 0xd 0xe 0xa 0xd # write 0xdead to BSC


5 0 0 0 0 0





$ pigs bscx 0x303 0xb 0xe 0xe 0xf # place 0xbeef in BSC tx FIFO, read rx FIFO


5 262338 13 14 10 13





$ pigs bspix 15 1 0 0 0 0 # read four bytes from BSC


5 0 11 14 14 15


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command stops bit banging SPI on a set of GPIO opened with <strong>BSPIO</strong>.</p>
<p><br />
The set of GPIO is specifed by <strong>cs</strong>.</p>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs bspic 10





$ pigs bspic 10


-142


ERROR: no bit bang SPI in progress on GPIO


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command starts bit banging SPI on a group of GPIO with slave select <strong>cs</strong>, MISO <strong>miso</strong>, MOSI <strong>mosi</strong>, and clock <strong>sclk</strong>.</p>
<p><br />
Data will be transferred at baud <strong>b</strong> bits per second (which may be set in the range 50-250000).</p>
<p><br />
The flags <strong>spf</strong> may be used to modify the default behaviour of mode 0, active low chip select.</p>
<p><br />
The flags consists of the least significant 22 bits.</p>
<p><br />
</p>
<pre><code>21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0


 0  0  0  0  0  0  R  T  0  0  0  0  0  0  0  0  0  0  0  p  m  m


</code></pre>
<p><br />
mm defines the SPI mode.</p>
<p><br />
</p>
<pre><code>Mode POL PHA


 0    0   0


 1    0   1


 2    1   0


 3    1   1


</code></pre>
<p><br />
p is 0 if CS is active low (default) and 1 for active high.</p>
<p><br />
T is 1 if the least significant bit is transmitted on MOSI first, the default (0) shifts the most significant bit out first.</p>
<p><br />
R is 1 if the least significant bit is received on MISO first, the default (0) receives the most significant bit first.</p>
<p><br />
The other bits in flags should be set to zero.</p>
<p><br />
Upon success 0 is returned. On error a negative status code will be returned.</p>
<p><br />
If more than one device is connected to the SPI bus (defined by SCLK, MOSI, and MISO) each must have its own CS.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs bspio  9 11 12 13 50000 0





$ pigs bspio 10 11 12 13 50000 0





$ pigs bspio 29 19 20 21 50000 0 # GPIO 29 not avaialble on this Pi


-41


ERROR: no permission to update GPIO


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command writes bytes <strong>bvs</strong> to the bit bang SPI device associated with slave select <strong>cs</strong>. It returns the same number of bytes read from the device.</p>
<p><br />
Upon success the count of returned bytes followed by the bytes themselves is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs bspio 5 13 19 12 10000 0 # MCP4251 DAC


$ pigs bspio 6 13 19 12 20000 3 # MCP3008 ADC





$ pigs bspix 5 0 16             # set DAC to 16


2 255 255





$ pigs bspix 5 12 0             # read back DAC


2 254 16





$ pigs bspix 6 1 128 0          # read ADC input 0


3 0 3 184                       # 952





$ pigs bspix 5 0 240            # set DAC to 240


2 255 255





$ pigs bspix 5 12 0             # read back DAC


2 254 240





$ pigs bspix 6 1 128 0          # read ADC input 0


3 0 0 63                        # 63





$ pigs bspix 5 0 128            # set DAC to 128


2 255 255





$ pigs bspix 5 12 0             # read back DAC


2 254 128





$ pigs bspix 6 1 128 0          # read ADC input 0


3 0 1 255                       # 511





$ pigs bspic 5                  # close SPI CS 5


$ pigs bspic 6                  # close SPI CS 6





$ pigs bspic 5                  # try to close SPI CS 5 again


-142


ERROR: no bit bang SPI in progress on GPIO


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command calls a user customised function. The meaning of any paramaters and the returned value is defined by the customiser.</p>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command calls a user customised function. The meaning of any paramaters and the returned value is defined by the customiser.</p>
<p><br />
</p>
<ul>
<li></li>
<li><p>This command returns the value of the internal library configuration settings.</p></li>
</ul>
<p><br />
</p>
<ul>
<li></li>
<li><p>This command sets the value of the internal library configuration settings to <strong>v</strong>.</p></li>
</ul>
<p><br />
</p>
<ul>
<li></li>
<li><p>This command starts event reporting on handle <strong>h</strong> (returned by a prior call to <strong>NO</strong>).</p></li>
</ul>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
The notification gets reports for each event specified by <strong>bits</strong>.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs evm 0 -1 # Shorthand for events 0-31.


$ pigs evm 0 0xf0 # Get notifications for events 4-7.





$ pigs evm 1 0xf


-25


ERROR: unknown handle


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li><p>This command triggers event <strong>event</strong>.</p></li>
</ul>
<p><br />
One event, number 31, is predefined. This event is auto generated on BSC slave activity.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs evt 12


$ pigs evt 5





$ pigs evt 32


-143


ERROR: bad event id


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li><p>This command closes a file handle <strong>h</strong> previously opened with <strong>FO</strong>.</p></li>
</ul>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs fc 0 # First close okay.





$ pigs fc 0 # Second fails.


-25


ERROR: unknown handle


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
Level changes on the GPIO <strong>u</strong> are not reported unless the level has been stable for at least <strong>stdy</strong> microseconds. The level is then reported. Level changes of less than <strong>stdy</strong> microseconds are ignored.</p>
<p><br />
The filter only affects callbacks (including pipe notifications).</p>
<p><br />
The <strong>R/READ</strong>, <strong>BR1</strong>, and <strong>BR2</strong> commands are not affected.</p>
<p><br />
Note, each (stable) edge will be timestamped <strong>stdy</strong> microseconds after it was first detected.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs fg 4 250





$ pigs fg 4 1000000


-125


ERROR: bad filter parameter


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li><p>This command returns a list of the files matching <strong>pat</strong>. Up to <strong>num</strong> bytes may be returned.</p></li>
</ul>
<p><br />
Upon success the count of returned bytes followed by the matching files is returned. On error a negative status code will be returned.</p>
<p><br />
A newline (0x0a) character separates each file name.</p>
<p><br />
Only files which have a matching entry in /opt/pigpio/access may be listed.</p>
<p><br />
Suppose /opt/pigpio/access contains</p>
<p><br />
/sys/bus/w1/devices/28*/w1_slave r</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs -a fl &quot;/sys/bus/w1/devices/28*/w1_slave&quot; 5000


90 /sys/bus/w1/devices/28-000005d34cd2/w1_slave


/sys/bus/w1/devices/28-001414abbeff/w1_slave





$ pigs -a fl &quot;/sys/bus/*&quot; 5000


ERROR: no permission to access file


-137


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
Level changes on the GPIO <strong>u</strong> are ignored until a level which has been stable for <strong>stdy</strong> microseconds is detected. Level changes on the GPIO are then reported for <strong>actv</strong> microseconds after which the process repeats.</p>
<p><br />
The filter only affects callbacks (including pipe notifications).</p>
<p><br />
The <strong>R/READ</strong>, <strong>BR1</strong>, and <strong>BR2</strong> commands are not affected.</p>
<p><br />
Note, level changes before and after the active period may be reported. Your software must be designed to cope with such reports.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs fn 7 250 1000





$ pigs fn 7 2500000 1000


-125


ERROR: bad filter parameter


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li><p>This function returns a handle to a file <strong>file</strong> opened in a specified mode <strong>mode</strong>.</p></li>
</ul>
<p><br />
Upon success a handle (&gt;=0) is returned. On error a negative status code will be returned.</p>
<p><br />
File</p>
<p><br />
A file may only be opened if permission is granted by an entry in /opt/pigpio/access. This is intended to allow remote access to files in a more or less controlled manner.</p>
<p><br />
Each entry in /opt/pigpio/access takes the form of a file path which may contain wildcards followed by a single letter permission. The permission may be R for read, W for write, U for read/write, and N for no access.</p>
<p><br />
Where more than one entry matches a file the most specific rule applies. If no entry matches a file then access is denied.</p>
<p><br />
Suppose /opt/pigpio/access contains the following entries</p>
<p><br />
</p>
<pre><code>/home/* n


/home/pi/shared/dir_1/* w


/home/pi/shared/dir_2/* r


/home/pi/shared/dir_3/* u


/home/pi/shared/dir_1/file.txt n


</code></pre>
<p><br />
Files may be written in directory dir_1 with the exception of file.txt.</p>
<p><br />
Files may be read in directory dir_2.</p>
<p><br />
Files may be read and written in directory dir_3.</p>
<p><br />
If a directory allows read, write, or read/write access then files may be created in that directory.</p>
<p><br />
In an attempt to prevent risky permissions the following paths are ignored in /opt/pigpio/access.</p>
<p><br />
</p>
<pre><code>a path containing ..


a path containing only wildcards (*?)


a path containing less than two non-wildcard parts


</code></pre>
<p><br />
Mode</p>
<p><br />
The mode may have the following values.</p>
<p><br />
</p>
<pre><code>        Value   Meaning
READ      1     open file for reading
WRITE     2     open file for writing
RW        3     open file for reading and writing
</code></pre>
<p><br />
The following values may be or'd into the mode.</p>
<p><br />
</p>
<pre><code>         Value   Meaning
APPEND     4     All writes append data to the end of the file
CREATE     8     The file is created if it doesn&#39;t exist
TRUNC     16     The file is truncated
</code></pre>
<p><br />
Newly created files are owned by root with permissions owner read and write.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ ls /ram/*.c


/ram/command.c      /ram/pigpiod.c  /ram/pigs.c


/ram/x_pigpiod_if.c /ram/pig2vcd.c  /ram/pigpiod_if2.c


/ram/x_pigpio.c     /ram/x_repeat.c /ram/pigpio.c


/ram/pigpiod_if.c   /ram/x_pigpiod_if2.c





# assumes /opt/pigpio/access contains the following line


# /ram/*.c r





$ pigs fo /ram/pigpio.c 1


0





$ pigs fo /ram/new.c 1


-128


ERROR: file open failed





$ pigs fo /ram/new.c 9


1





$ ls /ram/*.c -l


-rw-r--r-- 1 joan joan  42923 Jul 10 11:22 /ram/command.c


-rw------- 1 root root      0 Jul 10 16:54 /ram/new.c


-rw-r--r-- 1 joan joan   2971 Jul 10 11:22 /ram/pig2vcd.c


-rw------- 1 joan joan 296235 Jul 10 11:22 /ram/pigpio.c


-rw-r--r-- 1 joan joan   9266 Jul 10 11:22 /ram/pigpiod.c


-rw-r--r-- 1 joan joan  37331 Jul 10 11:22 /ram/pigpiod_if2.c


-rw-r--r-- 1 joan joan  33088 Jul 10 11:22 /ram/pigpiod_if.c


-rw-r--r-- 1 joan joan   7990 Jul 10 11:22 /ram/pigs.c


-rw-r--r-- 1 joan joan  19970 Jul 10 11:22 /ram/x_pigpio.c


-rw-r--r-- 1 joan joan  20804 Jul 10 11:22 /ram/x_pigpiod_if2.c


-rw-r--r-- 1 joan joan  19844 Jul 10 11:22 /ram/x_pigpiod_if.c


-rw-r--r-- 1 joan joan  19907 Jul 10 11:22 /ram/x_repeat.c


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li><p>This command returns up to <strong>num</strong> bytes of data read from the file associated with handle <strong>h</strong>.</p></li>
</ul>
<p><br />
Upon success the count of returned bytes followed by the bytes themselves is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs fr 0 10


5 48 49 128 144 255





$ pigs fr 0 10


0


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li><p>This command seeks to a position within the file associated with handle <strong>h</strong>.</p></li>
</ul>
<p><br />
The number of bytes to move is <strong>num</strong>. Positive offsets move forward, negative offsets backwards. The move start position is determined by <strong>from</strong> as follows.</p>
<p><br />
</p>
<pre><code>    From
0   start
1   current position
2   end
</code></pre>
<p><br />
Upon success the new byte position within the file (&gt;=0) is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs fs 0 200 0 # Seek to start of file plus 200


200





$ pigs fs 0 0 1 # Return current position


200





$ pigs fs 0 0 2 # Seek to end of file, return size


296235


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li><p>This command writes bytes <strong>bvs</strong> to the file associated with handle <strong>h</strong>.</p></li>
</ul>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs fw 0 23 45 67 89


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command returns the PWM dutycycle in use on GPIO <strong>u</strong>.</p>
<p><br />
Upon success the dutycycle is returned. On error a negative status code will be returned.</p>
<p><br />
For normal PWM the dutycycle will be out of the defined range for the GPIO (see <strong>PRG</strong>).</p>
<p><br />
If a hardware clock is active on the GPIO the reported dutycycle will be 500000 (500k) out of 1000000 (1M).</p>
<p><br />
If hardware PWM is active on the GPIO the reported dutycycle will be out of a 1000000 (1M).</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs p 4 129


$ pigs gdc 4


129





pigs gdc 5


-92


ERROR: GPIO is not in use for PWM


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command returns the servo pulsewidth in use on GPIO <strong>u</strong>.</p>
<p><br />
Upon success the servo pulsewidth is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs s 4 1235


$ pigs gpw 4


1235





$ pigs gpw 9


-93


ERROR: GPIO is not in use for servo pulses


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li><p>This command displays a brief list of the commands and their parameters.</p></li>
</ul>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs h





$ pigs help


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li><p>This command sets the hardware clock associated with GPIO <strong>g</strong> to frequency <strong>cf</strong>. Frequencies above 30MHz are unlikely to work.</p></li>
</ul>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs hc 4 5000 # start a 5 KHz clock on GPIO 4 (clock 0)





$ pigs hc 5 5000000 # start a 5 MHz clcok on GPIO 5 (clock 1)


-99


ERROR: need password to use hardware clock 1


</code></pre>
<p><br />
The same clock is available on multiple GPIO. The latest frequency setting will be used by all GPIO which share a clock.</p>
<p><br />
The GPIO must be one of the following.</p>
<p><br />
</p>
<pre><code>4   clock 0  All models
5   clock 1  All models but A and B (reserved for system use)
6   clock 2  All models but A and B
20  clock 0  All models but A and B
21  clock 1  All models but A and B Rev.2 (reserved for system use)
</code></pre>
<p><br />
</p>
<pre><code>32  clock 0  Compute module only
34  clock 0  Compute module only
42  clock 1  Compute module only (reserved for system use)
43  clock 2  Compute module only
44  clock 1  Compute module only (reserved for system use)
</code></pre>
<p><br />
Access to clock 1 is protected by a password as its use will likely crash the Pi. The password is given by or'ing 0x5A000000 with the GPIO number.</p>
<p><br />
</p>
<ul>
<li></li>
<li><p>This command sets the hardware PWM associated with GPIO <strong>g</strong> to frequency <strong>pf</strong> with dutycycle <strong>pdc</strong>. Frequencies above 30MHz are unlikely to work.</p></li>
</ul>
<p><br />
NOTE: Any waveform started by <strong>WVTX</strong>, <strong>WVTXR</strong>, or <strong>WVCHA</strong> will be cancelled.</p>
<p><br />
This function is only valid if the pigpio main clock is PCM. The main clock defaults to PCM but may be overridden when the pigpio daemon is started (option -t).</p>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<pre><code>$ pigs hp 18 100 800000 # 80% dutycycle





$ pigs hp 19 100 200000 # 20% dutycycle





$ pigs hp 19 400000000 100000


-96


ERROR: invalid hardware PWM frequency


</code></pre>
<p><br />
The same PWM channel is available on multiple GPIO. The latest frequency and dutycycle setting will be used by all GPIO which share a PWM channel.</p>
<p><br />
The GPIO must be one of the following.</p>
<p><br />
</p>
<pre><code>12  PWM channel 0  All models but A and B
13  PWM channel 1  All models but A and B
18  PWM channel 0  All models
19  PWM channel 1  All models but A and B
</code></pre>
<p><br />
</p>
<pre><code>40  PWM channel 0  Compute module only
41  PWM channel 1  Compute module only
45  PWM channel 1  Compute module only
52  PWM channel 0  Compute module only
53  PWM channel 1  Compute module only
</code></pre>
<p><br />
The actual number of steps beween off and fully on is the integral part of 250M/<strong>pf</strong> (375M/<strong>pf</strong> for the BCM2711).</p>
<p><br />
The actual frequency set is 250M/steps (375M/steps for the BCM2711).</p>
<p><br />
There will only be a million steps for a <strong>pf</strong> of 250 (375 for the BCM2711). Lower frequencies will have more steps and higher frequencies will have fewer steps. <strong>pdc</strong> is automatically scaled to take this into account.</p>
<p><br />
</p>
<ul>
<li></li>
<li><p>This command returns the hardware revision of the Pi.</p></li>
</ul>
<p><br />
The hardware revision is found in the last 4 characters on the revision line of /proc/cpuinfo.</p>
<p><br />
If the hardware revision can not be found or is not a valid hexadecimal number the command returns 0.</p>
<p><br />
The revision number can be used to determine the assignment of GPIO to pins (see <strong>g</strong>).</p>
<p><br />
There are currently three types of board.</p>
<p><br />
Type 1 boards have hardware revision numbers of 2 and 3.</p>
<p><br />
Type 2 boards have hardware revision numbers of 4, 5, 6, and 15.</p>
<p><br />
Type 3 boards have hardware revision numbers of 16 or greater.</p>
<p><br />
for "Revision : 0002" the command returns 2.</p>
<p><br />
for "Revision : 000f" the command returns 15.</p>
<p><br />
for "Revision : 000g" the command returns 0.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs hwver # On a B+


16


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li><p>This command closes an I2C handle <strong>h</strong> previously opened with <strong>I2CO</strong>.</p></li>
</ul>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs i2cc 0 # First close okay.





$ pigs i2cc 0 # Second fails.


-25


ERROR: unknown handle


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li><p>This command returns a handle to access device <strong>id</strong> on I2C bus <strong>ib</strong>. The device is opened with flags <strong>if</strong>.</p></li>
</ul>
<p><br />
Physically buses 0 and 1 are available on the Pi. Higher numbered buses will be available if a kernel supported bus multiplexor is being used.</p>
<p><br />
The GPIO used are given in the following table.</p>
<p><br />
</p>
<pre><code>        SDA   SCL
I2C 0    0     1
I2C 1    2     3
</code></pre>
<p><br />
No flags are currently defined. The parameter <strong>if</strong> should be 0.</p>
<p><br />
Upon success the next free handle (&gt;=0) is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs i2co 1 0x70 0 # Bus 1, device 0x70, flags 0.


0





$ pigs i2co 1 0x53 0 # Bus 1, device 0x53, flags 0.


1


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li><p>This command writes <strong>wv</strong> to register <strong>r</strong> of the I2C device associated with handle <strong>h</strong> and returns a 16-bit word read from the device.</p></li>
</ul>
<p><br />
Upon success a value between 0 and 65535 will be returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs i2cpc 0 37 43210


39933





$ pigs i2cpc 0 256 43210


ERROR: bad i2c/spi/ser parameter


-81


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command writes the data bytes <strong>bvs</strong> to register <strong>r</strong> of the I2C device associated with handle <strong>h</strong> and returns a device specific number of bytes.</p>
<p><br />
Upon success the count of returned bytes followed by the bytes themselves is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs i2cpk 0 0 0x11 0x12


6 0 0 0 0 0 0


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command returns a single byte read from register <strong>r</strong> of the I2C device associated with handle <strong>h</strong>.</p>
<p><br />
Upon success a value between 0 and 255 will be returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs i2crb 0 0


6


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command returns <strong>num</strong> bytes read from the I2C device associated with handle <strong>h</strong>.</p>
<p><br />
Upon success the count of returned bytes followed by the bytes themselves is returned. On error a negative status code will be returned.</p>
<p><br />
This command operates on the raw I2C device. The maximum value of the parameter <strong>num</strong> is dependent on the I2C drivers and the device itself. pigs imposes a limit of about 8000 bytes.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs i2crd 0 16


16 6 24 0 0 0 0 0 0 0 0 0 0 0 0 32 78


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command returns <strong>num</strong> bytes from register <strong>r</strong> of the I2C device associated with handle <strong>h</strong>.</p>
<p><br />
Upon success the count of returned bytes followed by the bytes themselves is returned. On error a negative status code will be returned.</p>
<p><br />
The parameter <strong>num</strong> may be 1-32.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs i2cri 0 0 16


16 237 155 155 155 155 155 155 155 155 155 155 155 155 155 155 155


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command returns between 1 and 32 bytes read from register <strong>r</strong> of the I2C device associated with handle <strong>h</strong>.</p>
<p><br />
Upon success the count of returned bytes followed by the bytes themselves is returned. On error a negative status code will be returned.</p>
<p><br />
The number of bytes of returned data is specific to the device and register.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs i2crk 0 0


6 0 0 0 0 0 0





$ pigs i2crk 0 1


24 0 0 0 0 0 0 0 0 0 0 0 0 120 222 105 215 128 87 195 217 0 0 0 0


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command returns a single byte read from the I2C device associated with handle <strong>h</strong>.</p>
<p><br />
Upon success a value between 0 and 255 will be returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs i2crs 0


0


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command returns a single 16 bit word read from register <strong>r</strong> of the I2C device associated with handle <strong>h</strong>.</p>
<p><br />
Upon success a value between 0 and 65535 will be returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs i2crw 0 0


6150


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command writes a single byte <strong>bv</strong> to register <strong>r</strong> of the I2C device associated with handle <strong>h</strong>.</p>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs i2cwb 0 10 0x54


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command writes a block of bytes <strong>bvs</strong> to the I2C device associated with handle <strong>h</strong>.</p>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
The number of bytes which may be written in one transaction is dependent on the I2C drivers and the device itself. pigs imposes a limit of about 500 bytes.</p>
<p><br />
This command operates on the raw I2C device.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs i2cwd 0 0x01 0x02 0x03 0x04


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command writes between 1 and 32 bytes <strong>bvs</strong> to register <strong>r</strong> of the I2C device associated with handle <strong>h</strong>.</p>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs i2cwi 0 4 0x01 0x04 0xc0


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command writes between 1 and 32 bytes <strong>bvs</strong> to register <strong>r</strong> of the I2C device associated with handle <strong>h</strong>.</p>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>pigs i2cwk 0 4 0x01 0x04 0xc0


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command writes a single <strong>bit</strong> to the I2C device associated with handle <strong>h</strong>.</p>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs i2cwq 0 1


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command writes a single byte <strong>bv</strong> to the I2C device associated with handle <strong>h</strong>.</p>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs i2cws 0 0x12





$ pigs i2cws 0 0xff


-82


ERROR: I2C write failed


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command writes a single 16 bit word <strong>wv</strong> to register <strong>r</strong> of the I2C device associated with handle <strong>h</strong>.</p>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs i2cww 0 0 0xffff


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li><p>This command executes a sequence of I2C operations. The operations to be performed are specified by the contents of <strong>bvs</strong> which contains the concatenated command codes and associated data.</p></li>
</ul>
<p><br />
The following command codes are supported:</p>
<p><br />
</p>
<pre><code>Name      Cmd &amp; Data   Meaning
End       0            No more commands
Escape    1            Next P is two bytes
On        2            Switch combined flag on
Off       3            Switch combined flag off
Address   4 P          Set I2C address to P
Flags     5 lsb msb    Set I2C flags to lsb + (msb &lt;&lt; 8)
Read      6 P          Read P bytes of data
Write     7 P ...      Write P bytes of data
</code></pre>
<p><br />
The address, read, and write commands take a parameter P. Normally P is one byte (0-255). If the command is preceded by the Escape command then P is two bytes (0-65535, least significant byte first).</p>
<p><br />
The address defaults to that associated with the handle <strong>h</strong>. The flags default to 0. The address and flags maintain their previous value until updated.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>Set address 0x53, write 0x32, read 6 bytes


Set address 0x1E, write 0x03, read 6 bytes


Set address 0x68, write 0x1B, read 8 bytes


End





0x04 0x53   0x07 0x01 0x32   0x06 0x06


0x04 0x1E   0x07 0x01 0x03   0x06 0x06


0x04 0x68   0x07 0x01 0x1B   0x06 0x08


0x00


</code></pre>
<p><br />
</p>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command sets GPIO <strong>g</strong> to mode <strong>m</strong>, typically input (read) or output (write).</p>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
Each GPIO can be configured to be in one of 8 different modes. The modes are named Input, Output, ALT0, ALT1, ALT2, ALT3, ALT4, and ALT5.</p>
<p><br />
To set the mode use the code for the mode.</p>
<p><br />
</p>
<pre><code>Mode  Input Output ALT0 ALT1 ALT2 ALT3 ALT4 ALT5
Code      R      W    0    1    2    3    4    5
</code></pre>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs m 4 r # Input (read)


$ pigs m 4 w # Output (write)


$ pigs m 4 0 # ALT 0


$ pigs m 4 5 # ALT 5


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command returns the current mode of GPIO <strong>g</strong>.</p>
<p><br />
Upon success the value of the GPIO mode is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<pre><code>Value      0      1    2    3    4    5    6    7
Mode   Input Output ALT5 ALT4 ALT0 ALT1 ALT2 ALT3
</code></pre>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs mg 4


1


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li><p>This command delays execution for <strong>v</strong> microseconds.</p></li>
</ul>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
The main use of this command is expected to be within <strong>Scripts</strong>.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs mics 20 # Delay 20 microseconds.


$ pigs mics 1000000 # Delay 1 second.





$ pigs mics 2000000


-64


ERROR: bad MICS delay (too large)


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command delays execution for <strong>v</strong> milliseconds.</p>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs mils 2000 # Delay 2 seconds.





$ pigs mils 61000


-65


ERROR: bad MILS delay (too large)


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command starts notifications on handle <strong>h</strong> returned by a prior call to <strong>NO</strong>.</p>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
The notification gets state changes for each GPIO specified by <strong>bits</strong>.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs nb 0 -1 # Shorthand for GPIO 0-31.


$ pigs nb 0 0xf0 # Get notifications for GPIO 4-7.





$ pigs nb 1 0xf


-25


ERROR: unknown handle


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command stops notifications on handle <strong>h</strong> returned by a prior call to <strong>NO</strong> and releases the handle for reuse.</p>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs nc 0 # First call succeeds.





$ pigs nc 1 # Second call fails.


-25


ERROR: unknown handle


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command requests a free notification handle.</p>
<p><br />
A notification is a method for being notified of GPIO state changes via a pipe.</p>
<p><br />
Upon success the command returns a handle greater than or equal to zero. On error a negative status code will be returned.</p>
<p><br />
Notifications for handle x will be available at the pipe named /dev/pigpiox (where x is the handle number).</p>
<p><br />
E.g. if the command returns 15 then the notifications must be read from /dev/pigpio15.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs no


0


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command pauses notifications on handle <strong>h</strong> returned by a prior call to <strong>NO</strong>.</p>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
Notifications for the handle are suspended until a new <strong>NB</strong> command is given for the handle.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs np 0


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command starts PWM on GPIO <strong>u</strong> with dutycycle <strong>v</strong>. The dutycycle varies from 0 (off) to range (fully on). The range defaults to 255.</p>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
This and the servo functionality use the DMA and PWM or PCM peripherals to control and schedule the pulsewidths and dutycycles.</p>
<p><br />
The <strong>PRS</strong> command may be used to change the default range of 255.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs p 4 64  # Start PWM on GPIO 4 with 25% dutycycle


$ pigs p 4 128 # 50%


$ pigs p 4 192 # 75%


$ pigs p 4 255 # 100%


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command gets the <strong>pad</strong> drive strength <strong>padma</strong> in mA.</p>
<p><br />
Returns the pad drive strength if OK. On error a negative status code will be returned.</p>
<p><br />
</p>
<pre><code>Pad   GPIO
0     0-27
1     28-45
2     46-53
</code></pre>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs padg 0


8


$ pigs pads 0 16


$ pigs padg 0


16


pigs padg 3


-126


ERROR: bad pad number


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command sets the <strong>pad</strong> drive strength <strong>padma</strong> in mA.</p>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<pre><code>Pad   GPIO
0     0-27
1     28-45
2     46-53
</code></pre>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs pads 0 16


$ pigs padg 0


16


$ pigs pads 0 17


-127


ERROR: bad pad drive strength


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
Validates the text <strong>t</strong> of a script without storing the script.</p>
<p><br />
Upon success nothing is returned. On error a list of detected script errors will be given.</p>
<p><br />
See <strong>Scripts</strong>.</p>
<p><br />
This command may be used to find script syntax faults.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs parse tag 100 w 22 1 mils 200 w 22 0 mils 800 jmp 100





$ pigs parse tag 0 w 22 1 mills 50 w 22 0 dcr p10 jp 99


Unknown command: mills


Unknown command: 50


Bad parameter to dcr


Can&#39;t resolve tag 99


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command returns the PWM frequency in Hz used for GPIO <strong>u</strong>.</p>
<p><br />
Upon success the PWM frequency is returned. On error a negative status code will be returned.</p>
<p><br />
For normal PWM the frequency will be that defined for the GPIO by <strong>PFS</strong>.</p>
<p><br />
If a hardware clock is active on the GPIO the reported frequency will be that set by <strong>HC</strong>.</p>
<p><br />
If hardware PWM is active on the GPIO the reported frequency will be that set by <strong>HP</strong>.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs pfg 4


800





$ pigs pfg 34


ERROR: GPIO not 0-31


-2


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li><p>This command sets the PWM frequency <strong>v</strong> to be used for GPIO <strong>u</strong>.</p></li>
</ul>
<p><br />
The numerically closest frequency to <strong>v</strong> will be selected.</p>
<p><br />
Upon success the new frequency is returned. On error a negative status code will be returned.</p>
<p><br />
If PWM is currently active on the GPIO it will be switched off and then back on at the new frequency.</p>
<p><br />
Each GPIO can be independently set to one of 18 different PWM frequencies.</p>
<p><br />
The selectable frequencies depend upon the sample rate which may be 1, 2, 4, 5, 8, or 10 microseconds (default 5). The sample rate is set when the pigpio daemon is started.</p>
<p><br />
The frequencies for each sample rate are:</p>
<p><br />
</p>
<pre><code>                       Hertz





       1: 40000 20000 10000 8000 5000 4000 2500 2000 1600


           1250  1000   800  500  400  250  200  100   50





       2: 20000 10000  5000 4000 2500 2000 1250 1000  800


            625   500   400  250  200  125  100   50   25





       4: 10000  5000  2500 2000 1250 1000  625  500  400


            313   250   200  125  100   63   50   25   13


sample


 rate


 (us)  5:  8000  4000  2000 1600 1000  800  500  400  320


            250   200   160  100   80   50   40   20   10





       8:  5000  2500  1250 1000  625  500  313  250  200


            156   125   100   63   50   31   25   13    6





      10:  4000  2000  1000  800  500  400  250  200  160


            125   100    80   50   40   25   20   10    5


</code></pre>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>pigs pfs 4 0 # 0 selects the lowest frequency.


10





$ pigs pfs 4 1000 # Set 1000Hz PWM.


1000





$ pigs pfs 4 100000 # Very big number selects the highest frequency.


8000


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command returns the pigpio library version.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs pigpv


17


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command returns the dutycycle range for GPIO <strong>u</strong>.</p>
<p><br />
Upon success the range is returned. On error a negative status code will be returned.</p>
<p><br />
If a hardware clock or hardware PWM is active on the GPIO the reported range will be 1000000 (1M).</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs prg 4


255


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command stores a script <strong>t</strong> for later execution.</p>
<p><br />
If the script is valid a script id (&gt;=0) is returned which is passed to the other script commands. On error a negative status code will be returned.</p>
<p><br />
See <strong>Scripts</strong>.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs proc tag 123 w 4 0 mils 200 w 4 1 mils 300 dcr p0 jp 123


0





$ pigs proc tag 123 w 4 0 mils 5 w 4 1 mils 5 jmp 12


ERROR: script has unresolved tag


-63


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command deletes script <strong>sid</strong>.</p>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
See <strong>Scripts</strong>.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs procd 1





$ pigs procd 1


ERROR: unknown script id


-48


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command returns the status of script <strong>sid</strong> as well as the current value of its 10 parameters.</p>
<p><br />
Upon success the script status and parameters are returned. On error a negative status code will be returned.</p>
<p><br />
The script status may be one of</p>
<p><br />
</p>
<pre><code>0   being initialised
1   halted
2   running
3   waiting
4   failed
</code></pre>
<p><br />
See <strong>Scripts</strong>.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs procp 0


1 0 0 0 0 0 0 0 0 0 0


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command runs stored script <strong>sid</strong> passing it up to 10 optional parameters.</p>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
See <strong>Scripts</strong>.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs proc tag 123 w 4 0 mils 200 w 4 1 mils 300 dcr p0 jp 123


0





$ pigs procr 0 50 # Run script 0 with parameter 0 of 50.





$ pigs procp 0


2 44 0 0 0 0 0 0 0 0 0


$ pigs procp 0


2 37 0 0 0 0 0 0 0 0 0


$ pigs procp 0


2 10 0 0 0 0 0 0 0 0 0


$ pigs procp 0


2 5 0 0 0 0 0 0 0 0 0


$ pigs procp 0


2 2 0 0 0 0 0 0 0 0 0


$ pigs procp 0


1 -1 0 0 0 0 0 0 0 0 0


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command stops a running script <strong>sid</strong>.</p>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
See <strong>Scripts</strong>.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs procs 0





$ pigs procs 1


-48


ERROR: unknown script id


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command sets the parameters of a stored script <strong>sid</strong> passing it up to 10 parameters.</p>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
See <strong>Scripts</strong>.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs proc tag 0 hp 18 p0 p1 mils 1000 jmp 0


0


$ pigs procu 0 50 500000


$ pigs procr 0


$ pigs procu 0 100


$ pigs procu 0 200


$ pigs procu 0 200 100000


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command returns the real underlying range used by GPIO <strong>u</strong>.</p>
<p><br />
If a hardware clock is active on the GPIO the reported real range will be 1000000 (1M).</p>
<p><br />
If hardware PWM is active on the GPIO the reported real range will be approximately 250M divided by the set PWM frequency.</p>
<p><br />
On error a negative status code will be returned.</p>
<p><br />
See <strong>PRS</strong>.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs prrg 17


250





$ pigs pfs 17 0


10


$ pigs prrg 17


20000





$ pigs pfs 17 100000


8000


$ pigs prrg 17


25


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command sets the dutycycle range <strong>v</strong> to be used for GPIO <strong>u</strong>. Subsequent uses of command <strong>P/PWM</strong> will use a dutycycle between 0 (off) and <strong>v</strong> (fully on).</p>
<p><br />
Upon success the real underlying range used by the GPIO is returned. On error a negative status code will be returned.</p>
<p><br />
If PWM is currently active on the GPIO its dutycycle will be scaled to reflect the new range.</p>
<p><br />
The real range, the number of steps between fully off and fully on for each frequency, is given in the following table.</p>
<p><br />
</p>
<pre><code> #1   #2   #3   #4   #5   #6   #7    #8    #9
 25   50  100  125  200  250  400   500   625
                                        
#10  #11  #12  #13  #14  #15  #16   #17   #18
800 1000 1250 2000 2500 4000 5000 10000 20000
</code></pre>
<p><br />
The real value set by <strong>PRS</strong> is (dutycycle * real range) / range.</p>
<p><br />
See <strong>PRRG</strong></p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs prs 18 1000


250


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command sets the internal pull/up down for GPIO <strong>g</strong> to mode <strong>p</strong>.</p>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
The mode may be pull-down (D), pull-up (U), or off (O).</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs pud 4 d # Set pull-down on GPIO 4.


$ pigs pud 4 u # Set pull-up on GPIO 4.


$ pigs pud 4 o # No pull-up/down on GPIO 4.


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This reads the current level of GPIO <strong>g</strong>.</p>
<p><br />
Upon success the current level is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs r 17 # Get level of GPIO 17.


0





$ pigs r 4 # Get level of GPIO 4.


1


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command starts servo pulses of <strong>v</strong> microseconds on GPIO <strong>u</strong>.</p>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
The servo pulsewidth may be 0 (off), 500 (most anti-clockwise) to 2500 (most clockwise).</p>
<p><br />
The range supported by servos varies and should probably be determined by experiment. Generally values between 1000-2000 should be safe. A value of 1500 should always be safe and represents the mid-point of rotation.</p>
<p><br />
You can DAMAGE a servo if you command it to move beyond its limits.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs SERVO 17 1500


</code></pre>
<p><br />
This example causes an on pulse of 1500 microseconds duration to be transmitted on GPIO 17 at a rate of 50 times per second.</p>
<p><br />
This will command a servo connected to GPIO 17 to rotate to its mid-point.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>pigs s 17 0 # Switch servo pulses off.


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command closes a serial handle <strong>h</strong> previously opened with <strong>SERO</strong>.</p>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs serc 0 # First close okay.





$ pigs serc 0 # Second close gives error.


-25


ERROR: unknown handle


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command returns the number of bytes of data available to be read from the serial device associated with handle <strong>h</strong>.</p>
<p><br />
Upon success the count of bytes available to be read is returned (which may be 0). On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs serda 0


0


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command opens the serial <strong>dev</strong> at <strong>b</strong> bits per second.</p>
<p><br />
No flags are currently defined. <strong>sef</strong> should be set to zero.</p>
<p><br />
Upon success a handle (&gt;=0) is returned. On error a negative status code will be returned.</p>
<p><br />
The device name must start with /dev/tty or /dev/serial.</p>
<p><br />
</p>
<p><br />
The baud rate must be one of 50, 75, 110, 134, 150, 200, 300, 600, 1200, 1800, 2400, 4800, 9600, 19200, 38400, 57600, 115200, or 230400.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs sero /dev/ttyAMA0 9600 0


0





$ pigs sero /dev/tty1 38400 0


1


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command returns up to <strong>num</strong> bytes of data read from the serial device associated with handle <strong>h</strong>.</p>
<p><br />
Upon success the count of returned bytes followed by the bytes themselves is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs serr 0 10


5 48 49 128 144 255





$ pigs serr 0 10


0


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command returns a byte of data read from the serial device associated with handle <strong>h</strong>.</p>
<p><br />
Upon success a number between 0 and 255 is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs serrb 0


23


$ pigs serrb 0


45


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command writes bytes <strong>bvs</strong> to the serial device associated with handle <strong>h</strong>.</p>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs serw 0 23 45 67 89


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command writes a single byte <strong>bv</strong> to the serial device associated with handle <strong>h</strong>.</p>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs serwb 0 23


$ pigs serwb 0 0xf0


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command uses the system call to execute a shell script <strong>name</strong> with the given string <strong>str</strong> as its parameter.</p>
<p><br />
The exit status of the system call is returned if OK, otherwise PI_BAD_SHELL_STATUS.</p>
<p><br />
<strong>name</strong> must exist in /opt/pigpio/cgi and must be executable.</p>
<p><br />
The returned exit status is normally 256 times that set by the shell script exit function. If the script can't be found 32512 will be returned.</p>
<p><br />
The following table gives some example returned statuses.</p>
<p><br />
</p>
<pre><code>Script exit status   Returned system call status
1                    256
5                    1280
10                   2560
200                  51200
script not found     32512
</code></pre>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code># pass two parameters, hello and world


$ pigs shell scr1 hello world


256





# pass three parameters, hello, string with spaces, and world


$ pigs shell scr1 &quot;hello &#39;string with spaces&#39; world&quot;


256





# pass one parameter, hello string with spaces world


$ pigs shell scr1 &quot;


256





# non-existent script


$ pigs shell scr78 par1


32512


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command returns up to <strong>num</strong> bytes of bit bang serial data read from GPIO <strong>u</strong>.</p>
<p><br />
Upon success the count of returned bytes followed by the bytes themselves is returned. On error a negative status code will be returned.</p>
<p><br />
The GPIO <strong>u</strong> should have been initialised with the <strong>SLRO</strong> command.</p>
<p><br />
The bytes returned for each character depend upon the number of data bits <strong>db</strong> specified in the <strong>SLRO</strong> command.</p>
<p><br />
For <strong>db</strong> 1-8 there will be one byte per character.<br />
For <strong>db</strong> 9-16 there will be two bytes per character.<br />
For <strong>db</strong> 17-32 there will be four bytes per character.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs slr 15 20


6 1 0 23 45 89 0


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command closes GPIO <strong>u</strong> for reading bit bang serial data.</p>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs slrc 23





$ pigs slrc 23


-38


ERROR: no serial read in progress on GPIO


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command sets the logic level for reading bit bang serial data on GPIO <strong>u</strong>.</p>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
The invert parameter <strong>v</strong> is 1 for inverted signal, 0 for normal.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs slri 17 1 # invert logic on GPIO 17





$ pigs slri 23 0 # use normal logic on GPIO 23


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command opens GPIO <strong>u</strong> for reading bit bang serial data at <strong>b</strong> baud and <strong>db</strong> data bits.</p>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
The baud rate may be between 50 and 250000 bits per second.</p>
<p><br />
The received data is held in a cyclic buffer.</p>
<p><br />
It is the user's responsibility to read the data (with <strong>SLR</strong>) in a timely fashion.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs slro 23 19200 8





$ pigs slro 23 19200 8


-50


ERROR: GPIO already in use


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command closes the SPI handle <strong>h</strong> returned by a prior call to <strong>SPIO</strong>.</p>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs spic 1





$ pigs spic 1


-25


ERROR: unknown handle


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command returns a handle to a SPI device on channel <strong>c</strong>.</p>
<p><br />
Data will be transferred at <strong>b</strong> bits per second. The flags <strong>spf</strong> may be used to modify the default behaviour of 4-wire operation, mode 0, active low chip select.</p>
<p><br />
Speeds between 32kbps and 125Mbps are allowed. Speeds above 30Mbps are unlikely to work.</p>
<p><br />
The Pi has two SPI peripherals: main and auxiliary.</p>
<p><br />
The main SPI has two chip selects (channels), the auxiliary has three.</p>
<p><br />
The auxiliary SPI is available on all models but the A and B.</p>
<p><br />
The GPIO used are given in the following table.</p>
<p><br />
</p>
<pre><code>           MISO   MOSI   SCLK   CE0   CE1   CE2
Main SPI      9     10     11     8     7     -
Aux SPI      19     20     21    18    17    16
</code></pre>
<p><br />
The flags consists of the least significant 22 bits.</p>
<p><br />
</p>
<pre><code>21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0


 b  b  b  b  b  b  R  T  n  n  n  n  W  A u2 u1 u0 p2 p1 p0  m  m


</code></pre>
<p><br />
mm defines the SPI mode.</p>
<p><br />
Warning: modes 1 and 3 do not appear to work on the auxiliary SPI.</p>
<p><br />
</p>
<pre><code>Mode POL PHA


 0    0   0


 1    0   1


 2    1   0


 3    1   1


</code></pre>
<p><br />
px is 0 if CEx is active low (default) and 1 for active high.</p>
<p><br />
ux is 0 if the CEx GPIO is reserved for SPI (default) and 1 otherwise.</p>
<p><br />
A is 0 for the main SPI, 1 for the auxiliary SPI.</p>
<p><br />
W is 0 if the device is not 3-wire, 1 if the device is 3-wire. Main SPI only.</p>
<p><br />
nnnn defines the number of bytes (0-15) to write before switching the MOSI line to MISO to read data. This field is ignored if W is not set. Main SPI only.</p>
<p><br />
T is 1 if the least significant bit is transmitted on MOSI first, the default (0) shifts the most significant bit out first. Auxiliary SPI only.</p>
<p><br />
R is 1 if the least significant bit is received on MISO first, the default (0) receives the most significant bit first. Auxiliary SPI only.</p>
<p><br />
bbbbbb defines the word size in bits (0-32). The default (0) sets 8 bits per word. Auxiliary SPI only.</p>
<p><br />
The <strong>SPIR</strong>, <strong>SPIW</strong>, and <strong>SPIX</strong> commands transfer data packed into 1, 2, or 4 bytes according to the word size in bits.</p>
<p><br />
For bits 1-8 there will be one byte per character.<br />
For bits 9-16 there will be two bytes per character.<br />
For bits 17-32 there will be four bytes per character.</p>
<p><br />
Multi-byte transfers are made in least significant byte first order.</p>
<p><br />
E.g. to transfer 32 11-bit words 64 bytes need to be sent.</p>
<p><br />
E.g. to transfer the 14 bit value 0x1ABC send the bytes 0xBC followed by 0x1A.</p>
<p><br />
The other bits in flags should be set to zero.</p>
<p><br />
Upon success a handle (&gt;=0) is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs spio 0 100000 3 # Open channel 0 at 100kbps in mode 3.


0





$ pigs spio 0 32000 256 # Open channel 0 of auxiliary spi at 32kbps.


1


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command returns <strong>num</strong> bytes read from the SPI device associated with handle <strong>h</strong>.</p>
<p><br />
Upon success the count of returned bytes followed by the bytes themselves is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs spir 0 10 # Read 10 bytes from the SPI device.


10 0 0 0 0 0 0 0 0 0 0


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command writes bytes <strong>bvs</strong> to the SPI device associated with handle <strong>h</strong>.</p>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs spiw 0 0x22 0x33 0xcc 0xff


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command writes bytes <strong>bvs</strong> to the SPI device associated with handle <strong>h</strong>. It returns the same number of bytes read from the device.</p>
<p><br />
Upon success the count of returned bytes followed by the bytes themselves is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs spix 0 0x22 0x33 0xcc 0xff


4 0 0 0 0


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command returns the current system tick.</p>
<p><br />
Tick is the number of microseconds since system boot.</p>
<p><br />
As tick is an unsigned 32 bit quantity it wraps around after 2^32 microseconds, which is approximately 1 hour 12 minutes.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs t mils 1000 t


3691823946


3692833987


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command sends a trigger pulse of <strong>pl</strong> microseconds at level <strong>L</strong> to GPIO <strong>u</strong>.</p>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
The GPIO is set to not level at the end of the pulse.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs trig 4 10 1





$ pigs trig 4 51 1


-46


ERROR: trigger pulse &gt; 50 microseconds


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command sets GPIO <strong>g</strong> to level <strong>L</strong>. The level may be 0 (low, off, clear) or 1 (high, on, set).</p>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs w 23 0


$ pigs w 23 1





$ pigs w 23 2


-5


ERROR: level not 0-1


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command sets a watchdog of <strong>v</strong> milliseconds on GPIO <strong>u</strong>.</p>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
The watchdog is nominally in milliseconds.</p>
<p><br />
One watchdog may be registered per GPIO.</p>
<p><br />
The watchdog may be cancelled by setting timeout to 0.</p>
<p><br />
Once a watchdog has been started monitors of the GPIO will be triggered every timeout interval after the last GPIO activity. The watchdog expiry will be indicated by a special TIMEOUT value.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs wdog 23 90000


-15


ERROR: timeout not 0-60000





$ pigs wdog 23 9000


</code></pre>
<p><br />
This example causes a report to be written to any notification pipes listening on GPIO 23 whenever GPIO 23 changes state or approximately every 9000 ms.</p>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command adds 1 one or more triplets <strong>trips</strong> of GPIO on, GPIO off, delay to the existing waveform (if any).</p>
<p><br />
Upon success the total number of pulses in the waveform so far is returned. On error a negative status code will be returned.</p>
<p><br />
The triplets will be added at the start of the existing waveform. If they are to start offset from the start then the first triplet should consist solely of a delay i.e. 0 0 offset.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs wvag 0x10 0x80 1000 0x80 0x10 9000


2





$ pigs wvag 0 0 10000 0x10 0x80 1000 0x80 0x10 9000


4


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command adds a waveform representing serial data <strong>bvs</strong> to GPIO <strong>u</strong> at <strong>b</strong> baud to the existing waveform (if any). The serial data starts <strong>o</strong> microseconds from the start of the waveform.</p>
<p><br />
Upon success the total number of pulses in the waveform so far is returned. On error a negative status code will be returned.</p>
<p><br />
The serial data is formatted as one start bit, <strong>db</strong> data bits, and <strong>sb</strong>/2 stop bits.</p>
<p><br />
The baud rate may be between 50 and 1000000 bits per second.</p>
<p><br />
It is legal to add serial data streams with different baud rates to the same waveform.</p>
<p><br />
The bytes required for each character depend upon <strong>db</strong>.</p>
<p><br />
For <strong>db</strong> 1-8 there will be one byte per character.<br />
For <strong>db</strong> 9-16 there will be two bytes per character.<br />
For <strong>db</strong> 17-32 there will be four bytes per character.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs wvas 4 9600 8 2 0 0x30 0x31 0x32 0x33


23





$ pigs wvas 7 38400 8 2 0 0x41 0x42


35


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command returns the id of the waveform currently being transmitted. Chained waves are not supported.</p>
<p><br />
Returns the waveform id or one of the following special values:</p>
<p><br />
9998 - transmitted wave not found<br />
9999 - no wave being transmitted</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs wvtat


9999


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command checks to see if a waveform is currently being transmitted.</p>
<p><br />
Returns 1 if a waveform is currently being transmitted, otherwise 0.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs wvbsy


0


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command transmits a chain of waveforms.</p>
<p><br />
NOTE: Any hardware PWM started by <strong>HP</strong> will be cancelled.</p>
<p><br />
The waves to be transmitted are specified by the contents of <strong>bvs</strong> which contains an ordered list of wave_ids and optional command codes and related data.</p>
<p><br />
Upon success 0 is returned. On error a negative status code will be returned.</p>
<p><br />
Each wave is transmitted in the order specified. A wave may occur multiple times per chain.</p>
<p><br />
A blocks of waves may be transmitted multiple times by using the loop commands. The block is bracketed by loop start and end commands. Loops may be nested.</p>
<p><br />
Delays between waves may be added with the delay command.</p>
<p><br />
The following command codes are supported:</p>
<p><br />
</p>
<pre><code>Name           Cmd &amp; Data   Meaning
Loop Start     255 0        Identify start of a wave block
Loop Repeat    255 1 x y    loop x + y*256 times
Delay          255 2 x y    delay x + y*256 microseconds
Loop Forever   255 3        loop forever
</code></pre>
<p><br />
If present Loop Forever must be the last entry in the chain.</p>
<p><br />
The code is currently dimensioned to support a chain with roughly 600 entries and 20 loop counters.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>#!/bin/bash





GPIO=4


WAVES=5





pigs m $GPIO w





for ((i=0; i&lt;$WAVES; i++))


do


   pigs wvag $((1&lt;&lt;GPIO)) 0 20 0 $((1&lt;&lt;GPIO)) $(((i+1)*200))


   w[i]=$(pigs wvcre)


done





# transmit waves 4+3+2


# loop start


#    transmit waves 0+0+0


#    loop start


#       transmit waves 0+1


#       delay 5000us


#    loop end (repeat 30 times)


#    loop start


#       transmit waves 2+3+0


#       transmit waves 3+1+2


#    loop end (repeat 10 times)


# loop end (repeat 5 times)


# transmit waves 4+4+4


# delay 20000us


# transmit waves 0+0+0





pigs wvcha .br
   ${w[4]} ${w[3]} ${w[2]} .br
   255 0 .br
      ${w[0]} ${w[0]} ${w[0]} .br
      255 0 .br
         ${w[0]} ${w[1]} .br
         255 2 0x88 0x13 .br
      255 1 30 0 .br
      255 0 .br
         ${w[2]} ${w[3]} ${w[0]} .br
         ${w[3]} ${w[1]} ${w[2]} .br
      255 1 10 0 .br
   255 1 5 0 .br
   ${w[4]} ${w[4]} ${w[4]} .br
   255 2 0x20 0x4E .br
   ${w[0]} ${w[0]} ${w[0]}





while [[ $(pigs wvbsy) -eq 1 ]]; do sleep 0.1; done





for ((i=0; i&lt;$WAVES; i++)); do echo ${w[i]}; pigs wvdel ${w[i]}; done


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command clears all waveforms.</p>
<p><br />
Nothing is returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs wvclr


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command creates a waveform from the data provided by the prior calls to the <strong>WVAG</strong> and <strong>WVAS</strong> commands.</p>
<p><br />
Upon success a wave id (&gt;=0) is returned. On error a negative status code will be returned.</p>
<p><br />
The data provided by the <strong>WVAG</strong> and <strong>WVAS</strong> commands is consumed by this command.</p>
<p><br />
As many waveforms may be created as there is space available. The wave id is passed to <strong>WVTX</strong> or <strong>WVTXR</strong> to specify the waveform to transmit.</p>
<p><br />
Normal usage would be</p>
<p><br />
Step 1. <strong>WVCLR</strong> to clear all waveforms and added data.</p>
<p><br />
Step 2. <strong>WVAG</strong>/<strong>WVAS</strong> calls to supply the waveform data.</p>
<p><br />
Step 3. <strong>WVCRE</strong> to create the waveform and get a unique id.</p>
<p><br />
Repeat steps 2 and 3 as needed.</p>
<p><br />
Step 4. <strong>WVTX</strong> or <strong>WVTXR</strong> with the id of the waveform to transmit.</p>
<p><br />
A waveform comprises of one or more pulses.</p>
<p><br />
A pulse specifies</p>
<p><br />
1) the GPIO to be switched on at the start of the pulse.<br />
2) the GPIO to be switched off at the start of the pulse.<br />
3) the delay in microseconds before the next pulse.</p>
<p><br />
Any or all the fields can be zero. It doesn't make any sense to set all the fields to zero (the pulse will be ignored).</p>
<p><br />
When a waveform is started each pulse is executed in order with the specified delay between the pulse and the next.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs wvas 4 9600 0 23 45 67 89 90


37


$ pigs wvcre


0





$ pigs wvcre


-69


ERROR: attempt to create an empty waveform


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
Create a waveform of fixed size. Similar to <strong>WVCRE</strong>, this command creates a waveform but pads the consumed resources to a fixed size, specified as a <strong>percent</strong> of the total resources. Padded waves of equal size can be re-cycled efficiently allowing newly created waves to re-use the resources of deleted waves of the same dimension.</p>
<p><br />
Upon success a wave id (&gt;=0) is returned. On error a negative status code will be returned.</p>
<p><br />
The data provided by the <strong>WVAG</strong> and <strong>WVAS</strong> commands are consumed by this command.</p>
<p><br />
As many waveforms may be created as there is space available. The wave id is passed to <strong>WVTX</strong> or <strong>WVTXR</strong> to specify the waveform to transmit.</p>
<p><br />
Normal usage would be</p>
<p><br />
Step 1. <strong>WVCLR</strong> to clear all waveforms and added data.</p>
<p><br />
Step 2. <strong>WVAG</strong>/<strong>WVAS</strong> calls to supply the waveform data.</p>
<p><br />
Step 3. <strong>WVCAP</strong> to create a waveform of a uniform size.</p>
<p><br />
Step 4. <strong>WVTX</strong> or <strong>WVTXR</strong> with the id of the waveform to transmit.</p>
<p><br />
Repeat steps 2 - 4 as needed.</p>
<p><br />
Step 5. Any wave id can now be deleted and another wave of the same size can be created in its place.</p>
<p><br />
Example</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code># Create a wave that consumes 50% of the total resource:





$ pigs wvag 16 0 5000000 0 16 5000000


2


$ pigs wvcap 50


0


$ pigs wvtx 0


11918


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command deletes the waveform with id <strong>wid</strong>.</p>
<p><br />
The wave is flagged for deletion. The resources used by the wave will only be reused when either of the following apply.</p>
<p><br />
- all waves with higher numbered wave ids have been deleted or have been flagged for deletion.</p>
<p><br />
- a new wave is created which uses exactly the same resources as the current wave (see the C source for gpioWaveCreate for details).</p>
<p><br />
Upon success nothing is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs wvdel 0





$ pigs wvdel 0


-66


ERROR: non existent wave id


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command aborts the transmission of the current waveform.</p>
<p><br />
Nothing is returned.</p>
<p><br />
This command is intended to stop a waveform started in the repeat mode.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs wvhlt


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This clears any existing waveform data ready for the creation of a new waveform.</p>
<p><br />
Nothing is returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs wvnew


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
The statistic requested by <strong>ws</strong> is returned.</p>
<p><br />
<strong>ws</strong> identifies the subcommand as follows.</p>
<p><br />
0 Get Cbs<br />
1 Get High Cbs<br />
2 Get Max Cbs</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs wvas 4 9600 0 23 45 67 89 90


37





$ pigs wvsc 0


74


$ pigs wvsc 1


74


$ pigs wvsc 2


25016


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
The statistic requested by <strong>ws</strong> is returned.</p>
<p><br />
<strong>ws</strong> identifies the subcommand as follows.</p>
<p><br />
0 Get Micros<br />
1 Get High Micros<br />
2 Get Max Micros</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs wvsm 0


5314


$ pigs wvsm 1


5314


$ pigs wvsm 2


1800000000


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
The statistic requested by <strong>ws</strong> is returned.</p>
<p><br />
<strong>ws</strong> identifies the subcommand as follows.</p>
<p><br />
0 Get Pulses<br />
1 Get High Pulses<br />
2 Get Max Pulses</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs wvsp 0


37


$ pigs wvsp 1


37


$ pigs wvsp 2


12000


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command transmits the waveform with id <strong>wid</strong> once.</p>
<p><br />
NOTE: Any hardware PWM started by <strong>HP</strong> will be cancelled.</p>
<p><br />
Upon success the number of DMA control blocks in the waveform is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs wvtx 1


75





$ pigs wvtx 2


-66


ERROR: non existent wave id


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command transmits the waveform with id <strong>wid</strong> using mode <strong>wmde</strong>.</p>
<p><br />
The mode may be send once (0), send repeatedly (1), send once but first sync with previous wave (2), or send repeatedly but first sync with previous wave (3).</p>
<p><br />
WARNING: bad things may happen if you delete the previous waveform before it has been synced to the new waveform.</p>
<p><br />
NOTE: Any hardware PWM started by <strong>HP</strong> will be cancelled.</p>
<p><br />
Upon success the number of DMA control blocks in the waveform is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs wvtxm 1 3


75





$ pigs wvtxm 2 0


-66


ERROR: non existent wave id


</code></pre>
<p><br />
</p>
<ul>
<li></li>
<li></li>
</ul>
<p><br />
This command transmits the waveform with id <strong>wid</strong> repeatedly.</p>
<p><br />
NOTE: Any hardware PWM started by <strong>HP</strong> will be cancelled.</p>
<p><br />
Upon success the number of DMA control blocks in the waveform is returned. On error a negative status code will be returned.</p>
<p><br />
</p>
<p><strong>Example</strong><br />
</p>
<pre><code>$ pigs wvtxr 1


75





$ pigs wvtxr 2


-66


ERROR: non existent wave id


</code></pre>
<p><br />
</p>
<h1>PARAMETERS</h1>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
The number of microseconds level changes are reported for once a noise filter has been triggered (by <strong>stdy</strong> microseconds of a stable level).</p>
<p><br />
</p>
<ul>
<li><p>The command expects the baud rate in bits per second for the transmission of serial data (I2C/SPI/serial link, waves).</p></li>
</ul>
<p><br />
</p>
<ul>
<li><p>The command expects a BSC control word, see <strong>BSCX</strong>.</p></li>
</ul>
<p><br />
</p>
<ul>
<li><p>The command expects 0 or 1.</p></li>
</ul>
<p><br />
</p>
<ul>
<li><p>A mask is used to select one or more GPIO. A GPIO is selected if bit (1&lt;&lt;GPIO) is set in the mask.</p></li>
</ul>
<p><br />
E.g. a mask of 6 (binary 110) select GPIO 1 and 2, a mask of 0x103 (binary 100000011) selects GPIO 0, 1, and 8.</p>
<p><br />
</p>
<ul>
<li><p>The command expects a byte value.</p></li>
</ul>
<p><br />
</p>
<ul>
<li><p>The command expects one or more byte values.</p></li>
</ul>
<p><br />
</p>
<ul>
<li><p>The command expects a SPI channel.</p></li>
</ul>
<p><br />
</p>
<ul>
<li><p>The command expects a frequency.</p></li>
</ul>
<p><br />
</p>
<ul>
<li><p>The GPIO used for the slave select signal when bit banging SPI.</p></li>
</ul>
<p><br />
</p>
<ul>
<li><p>The command expects the number of data bits per serial character.</p></li>
</ul>
<p><br />
</p>
<ul>
<li><p>The command expects the name of a tty serial device, e.g.</p></li>
</ul>
<p><br />
</p>
<pre><code>/dev/ttyAMA0


/dev/ttyUSB0


/dev/tty0


/dev/serial0


</code></pre>
<p><br />
</p>
<ul>
<li><p>An event is a signal used to inform one or more consumers to start an action.</p></li>
</ul>
<p><br />
</p>
<ul>
<li><p>The file name must match an entry in /opt/pigpio/access.</p></li>
</ul>
<p><br />
</p>
<ul>
<li><p>Position to seek from <strong>FS</strong>.</p></li>
</ul>
<p><br />
</p>
<pre><code>    From
0   start
1   current position
2   end
</code></pre>
<p><br />
</p>
<ul>
<li><p>The command expects a GPIO.</p></li>
</ul>
<p><br />
There are 54 General Purpose Input Outputs (GPIO) named gpio0 through gpio53.</p>
<p><br />
They are split into two banks. Bank 1 consists of gpio0 through gpio31. Bank 2 consists of gpio32 through gpio53.</p>
<p><br />
All the GPIO which are safe for the user to read and write are in bank 1. Not all GPIO in bank 1 are safe though. Type 1 boards have 17 safe GPIO. Type 2 boards have 21. Type 3 boards have 26.</p>
<p><br />
See <strong>HWVER</strong>.</p>
<p><br />
The user GPIO are marked with an X in the following table.</p>
<p><br />
</p>
<pre><code>          0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
Type 1    X  X  -  -  X  -  -  X  X  X  X  X  -  -  X  X
Type 2    -  -  X  X  X  -  -  X  X  X  X  X  -  -  X  X
Type 3          X  X  X  X  X  X  X  X  X  X  X  X  X  X
                                                      
         16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
Type 1    -  X  X  -  -  X  X  X  X  X  -  -  -  -  -  -
Type 2    -  X  X  -  -  -  X  X  X  X  -  X  X  X  X  X
Type 3    X  X  X  X  X  X  X  X  X  X  X  X  -  -  -  -
</code></pre>
<p><br />
You are not prevented from writing to unsafe GPIO. The consequences of doing so range from no effect, to a crash, or corrupted data.</p>
<p><br />
</p>
<ul>
<li><p>The command expects a handle.</p></li>
</ul>
<p><br />
A handle is a number referencing an object opened by one of <strong>FO</strong>, <strong>I2CO</strong>, <strong>NO</strong>, <strong>SERO</strong>, <strong>SPIO</strong>.</p>
<p><br />
</p>
<ul>
<li><p>The command expects an I2C bus number.</p></li>
</ul>
<p><br />
</p>
<ul>
<li><p>The command expects the address of an I2C device.</p></li>
</ul>
<p><br />
</p>
<ul>
<li><p>The command expects an I2C flags value. No flags are currently defined.</p></li>
</ul>
<p><br />
</p>
<ul>
<li><p>The command expects a GPIO level.</p></li>
</ul>
<p><br />
</p>
<ul>
<li><p>The command expects a mode character.</p></li>
</ul>
<p><br />
Each GPIO can be configured to be in one of 8 different modes. The modes are named Input, Output, ALT0, ALT1, ALT2, ALT3, ALT4, and ALT5.</p>
<p><br />
To set the mode use the code for the mode.</p>
<p><br />
The value is returned by the mode get command.</p>
<p><br />
</p>
<pre><code>Mode    Input   Output   ALT0   ALT1   ALT2   ALT3   ALT4   ALT5
Code      R        W       0      1      2      3      4      5
Value     0        1       4      5      6      7      3      2
</code></pre>
<p><br />
</p>
<ul>
<li><p>The GPIO used for the MISO signal when bit banging SPI.</p></li>
</ul>
<p><br />
</p>
<ul>
<li><p>One of the following values.</p></li>
</ul>
<p><br />
</p>
<pre><code>        Value   Meaning
READ      1     open file for reading
WRITE     2     open file for writing
RW        3     open file for reading and writing
</code></pre>
<p><br />
The following values can be or'd into the mode.</p>
<p><br />
</p>
<pre><code>         Value   Meaning
APPEND   4       All writes append data to the end of the file
CREATE   8       The file is created if it doesn&#39;t exist
TRUNC    16      The file is truncated
</code></pre>
<p><br />
</p>
<ul>
<li><p>The GPIO used for the MOSI signal when bit banging SPI.</p></li>
</ul>
<p><br />
</p>
<ul>
<li><p>Only alphanumeric characters, '-' and '_' are allowed in the name.</p></li>
</ul>
<p><br />
</p>
<ul>
<li><p>The command expects the maximum number of bytes to return.</p></li>
</ul>
<p><br />
For the I2C and SPI commands the requested number of bytes will always be returned.</p>
<p><br />
For the serial and file commands the smaller of the number of bytes available to be read (which may be zero) and <strong>num</strong> bytes will be returned.</p>
<p><br />
</p>
<ul>
<li><p>Serial data is stored offset microseconds from the start of the waveform.</p></li>
</ul>
<p><br />
</p>
<ul>
<li><p>The command expects a PUD character.</p></li>
</ul>
<p><br />
Each GPIO can be configured to use or not use an internal pull up or pull down resistor. This is useful to provide a default state for inputs.</p>
<p><br />
A pull up will default the input to 1 (high).</p>
<p><br />
A pull down will default the input to 0 (low).</p>
<p><br />
To set the pull up down state use the command character for the state.</p>
<p><br />
</p>
<pre><code>Pull Up Down      Off Pull Down Pull Up
Command Character   O         D       U
</code></pre>
<p><br />
There is no mechanism to read the pull up down state.</p>
<p><br />
</p>
<ul>
<li><p>A set of GPIO which share common drivers.</p></li>
</ul>
<p><br />
</p>
<pre><code>Pad   GPIO
0     0-27
1     28-45
2     46-53
</code></pre>
<p><br />
</p>
<ul>
<li><p>The mA which may be drawn from each GPIO whilst still guaranteeing the high and low levels.</p></li>
</ul>
<p><br />
</p>
<ul>
<li><p>The command expects 0 to 10 numbers as parameters to be passed to the script.</p></li>
</ul>
<p><br />
</p>
<ul>
<li><p>A file path which may contain wildcards. To be accessible the path must match an entry in /opt/pigpio/access.</p></li>
</ul>
<p><br />
</p>
<ul>
<li><p>The command expects a dutycycle.</p></li>
</ul>
<p><br />
</p>
<ul>
<li><p>The percent of wave resources to allocate to a wave. It can be useful to create waves of fixed sizes to prevent wave fragmentation (where there are plenty of resources but not a large enough contiguous space).</p></li>
</ul>
<p><br />
</p>
<ul>
<li><p>The command expects a frequency.</p></li>
</ul>
<p><br />
</p>
<ul>
<li><p>The command expects a pulse length in microseconds.</p></li>
</ul>
<p><br />
</p>
<ul>
<li><p>The command expects an I2C register number.</p></li>
</ul>
<p><br />
</p>
<ul>
<li><p>The command expects the number of stop (half) bits per serial character.</p></li>
</ul>
<p><br />
</p>
<ul>
<li><p>The command expects the number of the GPIO to be used for SCL when bit banging I2C.</p></li>
</ul>
<p><br />
</p>
<ul>
<li><p>The GPIO used for the SCLK signal when bit banging SPI.</p></li>
</ul>
<p><br />
</p>
<ul>
<li><p>The command expects the number of the GPIO to be used for SDA when bit banging I2C.</p></li>
</ul>
<p><br />
</p>
<ul>
<li><p>The command expects a flag value. No serial flags are currently defined.</p></li>
</ul>
<p><br />
</p>
<ul>
<li><p>The command expects a script id as returned by a call to <strong>PROC</strong>.</p></li>
</ul>
<p><br />
</p>
<ul>
<li><p>See <strong>SPIO</strong> and <strong>BSPIO</strong>.</p></li>
</ul>
<p><br />
</p>
<ul>
<li></li>
</ul>
<p><br />
The number of microseconds level changes must be stable for before reporting the level changed (<strong>FG</strong>) or triggering the active part of a noise filter (<strong>FN</strong>).</p>
<p><br />
</p>
<ul>
<li><p>The command expects a string.</p></li>
</ul>
<p><br />
</p>
<ul>
<li><p>The command expects a string.</p></li>
</ul>
<p><br />
</p>
<ul>
<li><p>The command expects 1 or more triplets of GPIO on, GPIO off, delay.</p></li>
</ul>
<p><br />
E.g. 0x400000 0 100000 0 0x400000 900000 defines two pulses as follows</p>
<p><br />
</p>
<pre><code>     GPIO on           GPIO off           delay
0x400000 (GPIO 22)           0 (None) 100000 (1/10th s)
          0 (None) 0x400000 (GPIO 22) 900000 (9/10th s)
</code></pre>
<p><br />
</p>
<ul>
<li><p>The command expects the number of a user GPIO.</p></li>
</ul>
<p><br />
A number of commands are restricted to GPIO in bank 1, in particular the PWM commands, the servo command, the watchdog command, and the notification command.</p>
<p><br />
It is your responsibility to ensure that the PWM and servo commands are only used on safe GPIO.</p>
<p><br />
See <strong>g</strong></p>
<p><br />
</p>
<ul>
<li><p>The command expects an arbitrary number of &gt;=0 values (possibly none). Any after the first two must be &lt;= 255.</p></li>
</ul>
<p><br />
</p>
<ul>
<li><p>The command expects a number.</p></li>
</ul>
<p><br />
</p>
<ul>
<li><p>The command expects a wave id.</p></li>
</ul>
<p><br />
When a waveform is created it is given an id (0, 1, 2, ...).</p>
<p><br />
</p>
<ul>
<li><p>The command expects a wave transmission mode.</p></li>
</ul>
<p><br />
0 = send once<br />
1 = send repeatedly<br />
2 = send once but first sync with previous wave<br />
3 = send repeatedly but first sync with previous wave<br />
</p>
<p><br />
</p>
<ul>
<li><p>The command expects a subcommand.</p></li>
</ul>
<p><br />
0 = current value.<br />
1 = highest value so far.<br />
2 = maximum possible value.</p>
<p><br />
</p>
<ul>
<li><p>The command expects a word value.</p></li>
</ul>
<p><br />
</p>
<h1>SCRIPTS</h1>
<p><br />
Scripts are programs to be stored and executed by the pigpio daemon. They are intended to mitigate any performance problems associated with the pigpio daemon server/client model.</p>
<p><br />
</p>
<h2>Example</h2>
<p><br />
A trivial example might be useful. Suppose you want to toggle a GPIO on and off as fast as possible.</p>
<p><br />
From the command line you could write</p>
<p><br />
</p>
<pre><code>for ((i=0; i&lt;1000;i++)); do pigs w 22 1 w 22 0; done


</code></pre>
<p><br />
Timing that you will see it takes about 14 seconds, or roughly 70 toggles per second.</p>
<p><br />
Using the pigpio Python module you could use code such as</p>
<p><br />
</p>
<pre><code>#!/usr/bin/env python





import time





import pigpio





PIN=4





TOGGLE=10000





pi = pigpio.pi() # Connect to local Pi.





s = time.time()





for i in range(TOGGLE):


   pi.write(PIN, 1)


   pi.write(PIN, 0)





e = time.time()





print(&quot;pigpio did {} toggles per second&quot;.format(int(TOGGLE/(e-s))))





pi.stop()


</code></pre>
<p><br />
Timing that shows a speed improvement to roughly 800 toggles per second.</p>
<p><br />
Now let's use a script.</p>
<p><br />
</p>
<pre><code>pigs proc tag 999 w 22 1 w 22 0 dcr p0 jp 999


</code></pre>
<p><br />
Ignore the details for now.</p>
<p><br />
Let's time the script running.</p>
<p><br />
Again, ignore the details for now.</p>
<p><br />
</p>
<pre><code>time (pigs procr 0 10000000; while a=$(pigs procp 0); [[ ${a::1} -eq 2 ]];.br
 do sleep 0.2; done)


</code></pre>
<p><br />
The script takes roughly 12 seconds to complete, or 800,000 toggles per second.</p>
<p><br />
That is the advantage of a stored script.</p>
<p><br />
Some details.</p>
<p><br />
</p>
<pre><code>pigs proc tag 999 w 22 1 w 22 0 dcr p0 jp 999


</code></pre>
<p><br />
proc introduces a script. Everything after proc is part of the script.<br />
tag 999 names the current position in the script.<br />
w 22 1 writes 1 to GPIO 22.<br />
w 22 0 writes 0 to GPIO 22.<br />
dcr p0 decrements parameter 0.<br />
jp 999 jumps to tag 999 if the result is positive.</p>
<p><br />
</p>
<pre><code>time (pigs procr 0 10000000; while a=$(pigs procp 0); [[ ${a::1} -eq 2 ]];.br
 do sleep 0.2; done)


</code></pre>
<p><br />
pigs procr 0 10000000 starts script 0 with parameter 0 of 10 million.</p>
<p><br />
The rest is bash apart from</p>
<p><br />
pigs procp 0 asks for the status and parameters of script 0. The status will be 2 while the script is running and 1 when it is complete.</p>
<p><br />
</p>
<h2>Virtual machine</h2>
<p><br />
A script runs within a virtual machine with</p>
<p><br />
a 32 bit accumulator A.<br />
a flags register F.<br />
a program counter PC.</p>
<p><br />
Each script has</p>
<p><br />
10 parameters named 0 through 9.<br />
150 variables named 0 through 149.<br />
50 labels which are named by any unique number.</p>
<p><br />
</p>
<h2>Commands</h2>
<p><br />
Many pigpio commands may be used within a script. However some commands do not work within the script model as designed and are not permitted.</p>
<p><br />
The following commands are not permitted within a script:</p>
<p><br />
File - FL FO FR FW</p>
<p><br />
I2C - BI2CZ I2CPK I2CRD I2CRI I2CRK I2CWD I2CWI I2CWK I2CZ</p>
<p><br />
Misc - BSCX CF1 CF2 SHELL</p>
<p><br />
Script control - PARSE PROC PROCD PROCP PROCR PROCS PROCU</p>
<p><br />
Serial - SERO SERR SERW SLR</p>
<p><br />
SPI - BSPIO BSPIX SPIR SPIW SPIX</p>
<p><br />
Waves - WVAG WVAS WVCHA WVGO WVGOR</p>
<p><br />
The following commands are only permitted within a script:</p>
<p><br />
</p>
<pre><code>Command Description                                   Definition
ADD x   Add x to accumulator                          A+=x; F=A
AND x   And x with accumulator                        A&amp;=x; F=A
CALL L  Call subroutine at tag L                      push(PC+1); PC=L
CMP x   Compare x with accumulator                    F=A-x
DCR y   Decrement register                            --*y; F=*y
DCRA    Decrement accumulator                         --A; F=A
DIV x   Divide x into accumulator                     A/=x; F=A
EVTWT   Wait for an event to occur                    A=wait(x); F=A
HALT    Halt                                          Halt
INR y   Increment register                            ++*y; F=*y
INRA    Increment accumulator                         ++A; F=A
JM L    Jump if minus to tag L                        if (F&lt;0) PC=L
JMP L   Jump to tag L                                 PC=L
JNZ L   Jump if non-zero to tag L                     if (F) PC=L
JP L    Jump if positive to tag L                     if (F&gt;=0) PC=L
JZ L    Jump if zero to tag L                         if (!F) PC=L
LD y x  Load register with x                          *y=x
LDA x   Load accumulator with x                       A=x
MLT x   Multiply x with accumulator                   A*=x; F=A
MOD x   Modulus x with accumulator                    A%=x; F=A
OR x    Or x with accumulator                         A|=x; F=A
POP y   Pop register                                  y=pop()
POPA    Pop accumulator                               A=pop()
PUSH y  Push register                                 push(y)
PUSHA   Push accumulator                              push(A)
RET     Return from subroutine                        PC=pop()
RL y x  Rotate left register x bits                   *y&lt;&lt;=x; F=*y
RLA x   Rotate left accumulator x bits                A&lt;&lt;=x; F=A
RR y x  Rotate right register x bits                  *y&gt;&gt;=x; F=*y
RRA x   Rotate right accumulator x bits               A&gt;&gt;=x; F=A
STA y   Store accumulator in register                 y=A
SUB x   Subtract x from accumulator                   A-=x; F=A
SYS str Run external script (/opt/pigpio/cgi/str)     system(str); F=A
TAG L   Label the current script position             N/A
WAIT x  Wait for a GPIO in x to change state          A=wait(x); F=A
X y1 y2 Exchange contents of registers y1 and y2      t=*y1;*y1=*y2;*y2=t
XA y    Exchange contents of accumulator and register t=A;A=*y;*y=t
XOR x   Xor x with accumulator                        A^=x; F=A
</code></pre>
<p><br />
x may be a constant, a parameter (p0-p9), or a variable (v0-v149).</p>
<p><br />
y may be a parameter (p0-p9), or a variable (v0-v149). If p or v isn't specified y is assumed to be a variable.</p>
<p><br />
The EVTWT command parameter is a bit-mask with 1 set for events of interest.</p>
<p><br />
The WAIT command parameter is a bit-mask with 1 set for GPIO of interest.</p>
<p><br />
The SYS script receives two unsigned parameters: the accumulator A and the current GPIO levels.</p>
<p><br />
</p>
<h1>SEE ALSO</h1>
<p>pigpiod(1), pig2vcd(1), pigpio(3), pigpiod_if(3), pigpiod_if2(3)</p>
<h1>AUTHOR</h1>
<p>joan@abyz.me.uk</p>
<footer style="text-align: center;"><a href="https://blog.tamer.pw" target="_blank">Blog</a> | <a href="https://github.com/linuxtamer" target="_blank">Contact</a></footer>
</div>
</body>
</html>

