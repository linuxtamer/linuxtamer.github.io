<!DOCTYPE html>
<html lang=en-US>
<head>
<meta charset=utf-8>
<title>Linux command tc-etf</title><meta name="description" content="Linux command tc-etf Earliest TxTime First (ETF) Qdisc"><meta name="keywords" content="linux, command, tc-etf, bsd, Earliest TxTime First (ETF) Qdisc"><meta name="robots" content="index,follow">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="container">

<h1>NAME</h1>
<p>ETF - Earliest TxTime First (ETF) Qdisc</p>
<h1>SYNOPSIS</h1>
<p><strong>tc qdisc ... dev</strong> dev <strong>parent</strong> classid <strong>[ handle</strong> major: <strong>] etf clockid</strong> clockid <strong>[ delta</strong> delta_nsecs <strong>] [ deadline_mode ]</strong> <strong>[ offload ]</strong></p>
<h1>DESCRIPTION</h1>
<p>The ETF (Earliest TxTime First) qdisc allows applications to control the instant when a packet should be dequeued from the traffic control layer into the netdevice. If <strong>offload</strong> is configured and supported by the network interface card, the it will also control when packets leave the network controller.</p>
<p>ETF achieves that by buffering packets until a configurable time before their transmission time (i.e. txtime, or deadline), which can be configured through the <strong>delta</strong> option.</p>
<p>The qdisc uses a rb-tree internally so packets are always 'ordered' by their txtime and will be dequeued following the (next) earliest txtime first.</p>
<p>It relies on the SO_TXTIME socket option and the SCM_TXTIME CMSG in each packet field to configure the behavior of time dependent sockets: the clockid to be used as a reference, if the expected mode of txtime for that socket is deadline or strict mode, and if packet drops should be reported on the socket's error queue. See <strong>socket(7)</strong> for more information.</p>
<p>The etf qdisc will drop any packets with a txtime in the past, or if a packet expires while waiting for being dequeued.</p>
<p>This queueing discipline is intended to be used by TSN (Time Sensitive Networking) applications, and it exposes a traffic shaping functionality that is commonly documented as "Launch Time" or "Time-Based Scheduling" by vendors and the documentation of network interface controllers.</p>
<p>ETF is meant to be installed under another qdisc that maps packet flows to traffic classes, one example is <strong>mqprio(8).</strong></p>
<h1>PARAMETERS</h1>
<dl>
<dt>clockid</dt>
<dd><p><br />
Specifies the clock to be used by qdisc's internal timer for measuring time and scheduling events. The qdisc expects that packets passing through it to be using this same <strong>clockid</strong> as the reference of their txtime timestamps. It will drop packets coming from sockets that do not comply with that.</p>
</dd>
</dl>
<p>For more information about time and clocks on Linux, please refer to <strong>time(7)</strong> and <strong>clock_gettime(3).</strong></p>
<dl>
<dt>delta</dt>
<dd><p><br />
After enqueueing or dequeueing a packet, the qdisc will schedule its next wake-up time for the next txtime minus this delta value. This means <strong>delta</strong> can be used as a fudge factor for the scheduler latency of a system. This value must be specified in nanoseconds. The default value is 0 nanoseconds.</p>
</dd>
</dl>
<dl>
<dt>deadline_mode</dt>
<dd><p><br />
When <strong>deadline_mode</strong> is set, the qdisc will handle txtime with a different semantics, changed from a 'strict' transmission time to a deadline. In practice, this means during the dequeue flow <strong>etf(8)</strong> will set the txtime of the packet being dequeued to 'now'. The default is for this option to be disabled.</p>
</dd>
</dl>
<dl>
<dt>offload</dt>
<dd><p><br />
When <strong>offload</strong> is set, <strong>etf(8)</strong> will try to configure the network interface so time-based transmission arbitration is enabled in the controller. This feature is commonly referred to as "Launch Time" or "Time-Based Scheduling" by the documentation of network interface controllers. The default is for this option to be disabled.</p>
</dd>
</dl>
<dl>
<dt>skip_sock_check</dt>
<dd><p><br />
<strong>etf(8)</strong> currently drops any packet which does not have a socket associated with it or if the socket does not have SO_TXTIME socket option set. But, this will not work if the launchtime is set by another entity inside the kernel (e.g. some other Qdisc). Setting the skip_sock_check will skip checking for a socket associated with the packet.</p>
</dd>
</dl>
<h1>EXAMPLES</h1>
<p>ETF is used to enforce a Quality of Service. It controls when each packets should be dequeued and transmitted, and can be used for limiting the data rate of a traffic class. To separate packets into traffic classes the user may choose <strong>mqprio(8),</strong> and configure it like this:</p>
<pre><code># tc qdisc add dev eth0 handle 100: parent root mqprio num_tc 3 \
	map 2 2 1 0 2 2 2 2 2 2 2 2 2 2 2 2 \
	queues 1@0 1@1 2@2 \
	hw 0</code></pre>
<p>To replace the current queueing discipline by ETF in traffic class number 0, issue:</p>
<pre><code># tc qdisc replace dev eth0 parent 100:1 etf \
	clockid CLOCK_TAI delta 300000 offload</code></pre>
<p>With the options above, etf will be configured to use CLOCK_TAI as its clockid_t, will schedule packets for 300 us before their txtime, and will enable the functionality on that in the network interface card. Deadline mode will not be configured for this mode.</p>
<h1>AUTHORS</h1>
<p>Jesus Sanchez-Palencia &lt;jesus.sanchez-palencia@intel.com&gt;<br />
Vinicius Costa Gomes &lt;vinicius.gomes@intel.com&gt;</p>
<footer style="text-align: center;"><a href="https://blog.tamer.pw" target="_blank">Blog</a> | <a href="https://github.com/linuxtamer" target="_blank">Contact</a></footer>
</div>
</body>
</html>

